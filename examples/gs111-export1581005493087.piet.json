{
  "pietFileVersion": "0.0.1",
  "contracts": [
    {
      "elementType": 0,
      "name": "GnosisSafe",
      "baseContracts": [
        "MasterCopy",
        "ModuleManager",
        "OwnerManager",
        "SignatureDecoder",
        "SecuredTokenTransfer",
        "ISignatureValidatorConstants",
        "FallbackManager"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "DOMAIN_SEPARATOR_TYPEHASH",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "DOMAIN_SEPARATOR_TYPEHASH",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "SAFE_TX_TYPEHASH",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SAFE_TX_TYPEHASH",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "SAFE_MSG_TYPEHASH",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SAFE_MSG_TYPEHASH",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "nonce",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "nonce",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "domainSeparator",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "domainSeparator",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "signedMessages",
          "solidityType": {
            "name": "(bytes32 => uint256)",
            "mapping": {
              "key": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "signedMessages",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "approvedHashes",
          "solidityType": {
            "name": "(address => (bytes32 => uint256))",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "(bytes32 => uint256)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "approvedHashes",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "(bytes32 => uint256)",
                  "mapping": {
                    "key": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "value": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }",
          "start": {
            "line": 60,
            "column": 4
          },
          "end": {
            "line": 65,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "setup",
          "params": [
            {
              "name": "_owners",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of Safe owners."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Number of required confirmations for a Safe transaction."
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Contract address for optional delegate call."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload for optional delegate call."
            },
            {
              "name": "fallbackHandler",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Handler for fallback calls to this contract"
            },
            {
              "name": "paymentToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token that should be used for the payment (0 is ETH)"
            },
            {
              "name": "payment",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Value that should be paid"
            },
            {
              "name": "paymentReceiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Adddress that should receive the payment (or 0 if tx.origin)"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }",
          "start": {
            "line": 76,
            "column": 4
          },
          "end": {
            "line": 100,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)",
              "subAnnotation": {
                "name": "paymentReceiver",
                "value": "Adddress that should receive the payment (or 0 if tx.origin)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "payment Value that should be paid",
              "subAnnotation": {
                "name": "payment",
                "value": "Value that should be paid",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "paymentToken Token that should be used for the payment (0 is ETH)",
              "subAnnotation": {
                "name": "paymentToken",
                "value": "Token that should be used for the payment (0 is ETH)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "fallbackHandler Handler for fallback calls to this contract",
              "subAnnotation": {
                "name": "fallbackHandler",
                "value": "Handler for fallback calls to this contract",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload for optional delegate call.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload for optional delegate call.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Contract address for optional delegate call.",
              "subAnnotation": {
                "name": "to",
                "value": "Contract address for optional delegate call.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_threshold Number of required confirmations for a Safe transaction.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "Number of required confirmations for a Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_owners List of Safe owners.",
              "subAnnotation": {
                "name": "_owners",
                "value": "List of Safe owners.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "execTransaction",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of Safe transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of Safe transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of Safe transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of Safe transaction."
            },
            {
              "name": "safeTxGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Gas that should be used for the Safe transaction."
            },
            {
              "name": "baseGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)"
            },
            {
              "name": "gasPrice",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Gas price that should be used for the payment calculation."
            },
            {
              "name": "gasToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token address (or 0 if ETH) that is used for the payment."
            },
            {
              "name": "refundReceiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of receiver of gas payment (or 0 if tx.origin)."
            },
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})"
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }",
          "start": {
            "line": 114,
            "column": 4
          },
          "end": {
            "line": 157,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
              "subAnnotation": {
                "name": "signatures",
                "value": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": {
                "name": "refundReceiver",
                "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": {
                "name": "gasToken",
                "value": "Token address (or 0 if ETH) that is used for the payment.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasPrice Gas price that should be used for the payment calculation.",
              "subAnnotation": {
                "name": "gasPrice",
                "value": "Gas price that should be used for the payment calculation.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
              "subAnnotation": {
                "name": "baseGas",
                "value": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "safeTxGas Gas that should be used for the Safe transaction.",
              "subAnnotation": {
                "name": "safeTxGas",
                "value": "Gas that should be used for the Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "operation Operation type of Safe transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of Safe transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of Safe transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of Safe transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of Safe transaction.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "handlePayment",
          "params": [
            {
              "name": "gasUsed",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "baseGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "gasPrice",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "gasToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "refundReceiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "payment",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "private",
            null
          ],
          "source": "function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }",
          "start": {
            "line": 159,
            "column": 4
          },
          "end": {
            "line": 180,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "checkSignatures",
          "params": [
            {
              "name": "dataHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Hash of the data (could be either a message hash or transaction hash)"
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "That should be signed (this is passed to an external validator contract)"
            },
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash."
            },
            {
              "name": "consumeHash",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Indicates that in case of an approved hash the storage can be freed to save gas"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }",
          "start": {
            "line": 189,
            "column": 4
          },
          "end": {
            "line": 259,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "consumeHash Indicates that in case of an approved hash the storage can be freed to save gas",
              "subAnnotation": {
                "name": "consumeHash",
                "value": "Indicates that in case of an approved hash the storage can be freed to save gas",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
              "subAnnotation": {
                "name": "signatures",
                "value": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data That should be signed (this is passed to an external validator contract)",
              "subAnnotation": {
                "name": "data",
                "value": "That should be signed (this is passed to an external validator contract)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "dataHash Hash of the data (could be either a message hash or transaction hash)",
              "subAnnotation": {
                "name": "dataHash",
                "value": "Hash of the data (could be either a message hash or transaction hash)",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "requiredTxGas",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of Safe transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of Safe transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of Safe transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of Safe transaction."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "authorized",
            "external",
            null
          ],
          "source": "function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }",
          "start": {
            "line": 272,
            "column": 4
          },
          "end": {
            "line": 284,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Estimate without refunds and overhead fees (base transaction and payload data gas costs).",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "operation Operation type of Safe transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of Safe transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of Safe transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of Safe transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of Safe transaction.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "approveHash",
          "params": [
            {
              "name": "hashToApprove",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "The hash that should be marked as approved for signatures that are verified by this contract."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }",
          "start": {
            "line": 290,
            "column": 4
          },
          "end": {
            "line": 296,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.",
              "subAnnotation": {
                "name": "hashToApprove",
                "value": "The hash that should be marked as approved for signatures that are verified by this contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Marks a hash as approved. This can be used to validate a hash that is used by a signature.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "signMessage",
          "params": [
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Arbitrary length data that should be marked as signed on the behalf of address(this)"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "external",
            null
          ],
          "source": "function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }",
          "start": {
            "line": 302,
            "column": 4
          },
          "end": {
            "line": 309,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_data Arbitrary length data that should be marked as signed on the behalf of address(this)",
              "subAnnotation": {
                "name": "_data",
                "value": "Arbitrary length data that should be marked as signed on the behalf of address(this)",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Marks a message as signed",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "isValidSignature",
          "params": [
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Arbitrary length data signed on the behalf of address(this)"
            },
            {
              "name": "_signature",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Signature byte array associated with _data"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }",
          "start": {
            "line": 320,
            "column": 4
          },
          "end": {
            "line": 332,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "return",
              "value": "a bool upon valid or invalid signature with corresponding _data",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signature Signature byte array associated with _data",
              "subAnnotation": {
                "name": "_signature",
                "value": "Signature byte array associated with _data",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_data Arbitrary length data signed on the behalf of address(this)",
              "subAnnotation": {
                "name": "_data",
                "value": "Arbitrary length data signed on the behalf of address(this)",
                "subAnnotation": null
              }
            },
            {
              "name": "*",
              "value": "      The method will not perform any state changes (see parameters of `checkSignatures`)",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "      The save does not implement the interface since `checkSignatures` is not a view method.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Should return whether the signature provided is valid for the provided data.",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getMessageHash",
          "params": [
            {
              "name": "message",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Message that should be hashed"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }",
          "start": {
            "line": 337,
            "column": 4
          },
          "end": {
            "line": 350,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Message hash.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "message Message that should be hashed",
              "subAnnotation": {
                "name": "message",
                "value": "Message that should be hashed",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns hash of a message that can be signed by owners.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "encodeTransactionData",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type."
            },
            {
              "name": "safeTxGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Fas that should be used for the safe transaction."
            },
            {
              "name": "baseGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Gas costs for data used to trigger the safe transaction."
            },
            {
              "name": "gasPrice",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Maximum gas price that should be used for this transaction."
            },
            {
              "name": "gasToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token address (or 0 if ETH) that is used for the payment."
            },
            {
              "name": "refundReceiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of receiver of gas payment (or 0 if tx.origin)."
            },
            {
              "name": "_nonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Transaction nonce."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }",
          "start": {
            "line": 364,
            "column": 4
          },
          "end": {
            "line": 384,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Transaction hash bytes.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_nonce Transaction nonce.",
              "subAnnotation": {
                "name": "_nonce",
                "value": "Transaction nonce.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": {
                "name": "refundReceiver",
                "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": {
                "name": "gasToken",
                "value": "Token address (or 0 if ETH) that is used for the payment.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasPrice Maximum gas price that should be used for this transaction.",
              "subAnnotation": {
                "name": "gasPrice",
                "value": "Maximum gas price that should be used for this transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "baseGas Gas costs for data used to trigger the safe transaction.",
              "subAnnotation": {
                "name": "baseGas",
                "value": "Gas costs for data used to trigger the safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "safeTxGas Fas that should be used for the safe transaction.",
              "subAnnotation": {
                "name": "safeTxGas",
                "value": "Fas that should be used for the safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "operation Operation type.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns the bytes that are hashed to be signed by owners.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getTransactionHash",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type."
            },
            {
              "name": "safeTxGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Fas that should be used for the safe transaction."
            },
            {
              "name": "baseGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Gas costs for data used to trigger the safe transaction."
            },
            {
              "name": "gasPrice",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Maximum gas price that should be used for this transaction."
            },
            {
              "name": "gasToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token address (or 0 if ETH) that is used for the payment."
            },
            {
              "name": "refundReceiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of receiver of gas payment (or 0 if tx.origin)."
            },
            {
              "name": "_nonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Transaction nonce."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }",
          "start": {
            "line": 398,
            "column": 4
          },
          "end": {
            "line": 415,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Transaction hash.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_nonce Transaction nonce.",
              "subAnnotation": {
                "name": "_nonce",
                "value": "Transaction nonce.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": {
                "name": "refundReceiver",
                "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": {
                "name": "gasToken",
                "value": "Token address (or 0 if ETH) that is used for the payment.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "gasPrice Maximum gas price that should be used for this transaction.",
              "subAnnotation": {
                "name": "gasPrice",
                "value": "Maximum gas price that should be used for this transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "baseGas Gas costs for data used to trigger the safe transaction.",
              "subAnnotation": {
                "name": "baseGas",
                "value": "Gas costs for data used to trigger the safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "safeTxGas Fas that should be used for the safe transaction.",
              "subAnnotation": {
                "name": "safeTxGas",
                "value": "Fas that should be used for the safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "operation Operation type.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns hash to be signed by owners.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "ApproveHash",
          "params": [
            {
              "name": "approvedHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        },
        {
          "name": "SignMsg",
          "params": [
            {
              "name": "msgHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionFailure",
          "params": [
            {
              "name": "txHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "payment",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionSuccess",
          "params": [
            {
              "name": "txHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "payment",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "SENTINEL_MODULES",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SENTINEL_MODULES",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "modules",
          "solidityType": {
            "name": "(address => address)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "modules",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "SENTINEL_OWNERS",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SENTINEL_OWNERS",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "owners",
          "solidityType": {
            "name": "(address => address)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "owners",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "ownerCount",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "default",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "ownerCount",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "threshold",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "threshold",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "EIP1271_MAGIC_VALUE",
          "solidityType": {
            "name": "bytes4",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "EIP1271_MAGIC_VALUE",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes4",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "FALLBACK_HANDLER_STORAGE_SLOT",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "FALLBACK_HANDLER_STORAGE_SLOT",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "setupModules",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }",
          "start": {
            "line": 22,
            "column": 4
          },
          "end": {
            "line": 30,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "enableModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module to be whitelisted."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }",
          "start": {
            "line": 35,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "module Module to be whitelisted.",
              "subAnnotation": {
                "name": "module",
                "value": "Module to be whitelisted.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "disableModule",
          "params": [
            {
              "name": "prevModule",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module that pointed to the module to be removed in the linked list"
            },
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module to be removed."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }",
          "start": {
            "line": 52,
            "column": 4
          },
          "end": {
            "line": 62,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "module Module to be removed.",
              "subAnnotation": {
                "name": "module",
                "value": "Module to be removed.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevModule Module that pointed to the module to be removed in the linked list",
              "subAnnotation": {
                "name": "prevModule",
                "value": "Module that pointed to the module to be removed in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "execTransactionFromModule",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of module transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of module transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of module transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of module transaction."
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }",
          "start": {
            "line": 69,
            "column": 4
          },
          "end": {
            "line": 79,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "operation Operation type of module transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of module transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of module transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of module transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows a Module to execute a Safe transaction without any further confirmations.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "execTransactionFromModuleReturnData",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of module transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of module transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of module transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of module transaction."
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "returnData",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }",
          "start": {
            "line": 86,
            "column": 4
          },
          "end": {
            "line": 105,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "operation Operation type of module transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of module transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of module transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of module transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows a Module to execute a Safe transaction without any further confirmations and return data",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getModules",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }",
          "start": {
            "line": 109,
            "column": 4
          },
          "end": {
            "line": 116,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of modules.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns array of first 10 modules.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getModulesPaginated",
          "params": [
            {
              "name": "start",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Start of the page."
            },
            {
              "name": "pageSize",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Maximum number of modules that should be returned."
            }
          ],
          "returnParams": [
            {
              "name": "array",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "next",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }",
          "start": {
            "line": 122,
            "column": 4
          },
          "end": {
            "line": 144,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of modules.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "pageSize Maximum number of modules that should be returned.",
              "subAnnotation": {
                "name": "pageSize",
                "value": "Maximum number of modules that should be returned.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "start Start of the page.",
              "subAnnotation": {
                "name": "start",
                "value": "Start of the page.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns array of modules.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "execute",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
          "start": {
            "line": 9,
            "column": 4
          },
          "end": {
            "line": 19,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 21,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeDelegateCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 31,
            "column": 4
          },
          "end": {
            "line": 39,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "setupOwners",
          "params": [
            {
              "name": "_owners",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of Safe owners."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Number of required confirmations for a Safe transaction."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }",
          "start": {
            "line": 22,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold Number of required confirmations for a Safe transaction.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "Number of required confirmations for a Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_owners List of Safe owners.",
              "subAnnotation": {
                "name": "_owners",
                "value": "List of Safe owners.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "addOwnerWithThreshold",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New owner address."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
          "start": {
            "line": 52,
            "column": 4
          },
          "end": {
            "line": 67,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "owner New owner address.",
              "subAnnotation": {
                "name": "owner",
                "value": "New owner address.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "removeOwner",
          "params": [
            {
              "name": "prevOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner that pointed to the owner to be removed in the linked list"
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner address to be removed."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
          "start": {
            "line": 74,
            "column": 4
          },
          "end": {
            "line": 90,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "owner Owner address to be removed.",
              "subAnnotation": {
                "name": "owner",
                "value": "Owner address to be removed.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevOwner Owner that pointed to the owner to be removed in the linked list",
              "subAnnotation": {
                "name": "prevOwner",
                "value": "Owner that pointed to the owner to be removed in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "swapOwner",
          "params": [
            {
              "name": "prevOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner that pointed to the owner to be replaced in the linked list"
            },
            {
              "name": "oldOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner address to be replaced."
            },
            {
              "name": "newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New owner address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }",
          "start": {
            "line": 97,
            "column": 4
          },
          "end": {
            "line": 113,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "newOwner New owner address.",
              "subAnnotation": {
                "name": "newOwner",
                "value": "New owner address.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "oldOwner Owner address to be replaced.",
              "subAnnotation": {
                "name": "oldOwner",
                "value": "Owner address to be replaced.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
              "subAnnotation": {
                "name": "prevOwner",
                "value": "Owner that pointed to the owner to be replaced in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "changeThreshold",
          "params": [
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }",
          "start": {
            "line": 118,
            "column": 4
          },
          "end": {
            "line": 128,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "getThreshold",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }",
          "start": {
            "line": 130,
            "column": 4
          },
          "end": {
            "line": 136,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "isOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }",
          "start": {
            "line": 138,
            "column": 4
          },
          "end": {
            "line": 144,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "getOwners",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }",
          "start": {
            "line": 148,
            "column": 4
          },
          "end": {
            "line": 164,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of Safe owners.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns array of owners.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "recoverKey",
          "params": [
            {
              "name": "messageHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "operation ethereum signed message hash"
            },
            {
              "name": "messageSignature",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "message `txHash` signature"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
          "start": {
            "line": 13,
            "column": 4
          },
          "end": {
            "line": 27,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "pos which signature to read",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageSignature message `txHash` signature",
              "subAnnotation": {
                "name": "messageSignature",
                "value": "message `txHash` signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageHash operation ethereum signed message hash",
              "subAnnotation": {
                "name": "messageHash",
                "value": "operation ethereum signed message hash",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Recovers address who signed the message",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "signatureSplit",
          "params": [
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "concatenated rsv signatures"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
            }
          ],
          "returnParams": [
            {
              "name": "v",
              "solidityType": {
                "name": "uint8",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "r",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "s",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 53,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "signatures concatenated rsv signatures",
              "subAnnotation": {
                "name": "signatures",
                "value": "concatenated rsv signatures",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transferToken",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token that should be transferred"
            },
            {
              "name": "receiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Receiver to whom the token should be transferred"
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "The amount of tokens that should be transferred"
            }
          ],
          "returnParams": [
            {
              "name": "transferred",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 32,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "amount The amount of tokens that should be transferred",
              "subAnnotation": {
                "name": "amount",
                "value": "The amount of tokens that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "receiver Receiver to whom the token should be transferred",
              "subAnnotation": {
                "name": "receiver",
                "value": "Receiver to whom the token should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "token Token that should be transferred",
              "subAnnotation": {
                "name": "token",
                "value": "Token that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Transfers a token and returns if it was a success",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "internalSetFallbackHandler",
          "params": [
            {
              "name": "handler",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 18,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "setFallbackHandler",
          "params": [
            {
              "name": "handler",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "contract to handle fallbacks calls."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }",
          "start": {
            "line": 24,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "handler contract to handle fallbacks calls.",
              "subAnnotation": {
                "name": "handler",
                "value": "contract to handle fallbacks calls.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }",
          "start": {
            "line": 31,
            "column": 4
          },
          "end": {
            "line": 56,
            "column": 4
          },
          "annotations": []
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "EnabledModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "DisabledModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionFromModuleSuccess",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionFromModuleFailure",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        },
        {
          "name": "AddedOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "RemovedOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "ChangedThreshold",
          "params": [
            {
              "name": "threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/MasterCopy.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/SafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\n/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\ncontract GnosisSafe\n    is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {\n\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Gnosis Safe\";\n    string public constant VERSION = \"1.1.1\";\n\n    //keccak256(\n    //    \"EIP712Domain(address verifyingContract)\"\n    //);\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    //keccak256(\n    //    \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    //);\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    //keccak256(\n    //    \"SafeMessage(bytes message)\"\n    //);\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n\n    event ApproveHash(\n        bytes32 indexed approvedHash,\n        address indexed owner\n    );\n    event SignMsg(\n        bytes32 indexed msgHash\n    );\n    event ExecutionFailure(\n        bytes32 txHash, uint256 payment\n    );\n    event ExecutionSuccess(\n        bytes32 txHash, uint256 payment\n    );\n\n    uint256 public nonce;\n    bytes32 public domainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transfered, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }\n\n    /**\n    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n    * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n    * @param data That should be signed (this is passed to an external validator contract)\n    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\n    */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:\n    ///      1.) The method can only be called from the safe itself\n    ///      2.) The response is returned with a revert\n    ///      When estimating set `from` to the address of the safe.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n    */\n    function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n    * @dev Marks a message as signed\n    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\n    */\n    function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }\n\n    /**\n    * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n    * @dev Should return whether the signature provided is valid for the provided data.\n    *       The save does not implement the interface since `checkSignatures` is not a view method.\n    *       The method will not perform any state changes (see parameters of `checkSignatures`)\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    * @return a bool upon valid or invalid signature with corresponding _data\n    */\n    function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /// @dev Returns hash of a message that can be signed by owners.\n    /// @param message Message that should be hashed\n    /// @return Message hash.\n    function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n",
      "inFile": "GnosisSafe.sol",
      "references": [
        "MasterCopy",
        "ModuleManager",
        "OwnerManager",
        "SignatureDecoder",
        "SecuredTokenTransfer",
        "ISignatureValidatorConstants",
        "FallbackManager",
        "Enum.Operation"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "Migrations",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "owner",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "owner",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "last_completed_migration",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "last_completed_migration",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor()\n        public\n    {\n        owner = msg.sender;\n    }",
          "start": {
            "line": 11,
            "column": 4
          },
          "end": {
            "line": 15,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "setCompleted",
          "params": [
            {
              "name": "completed",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "restricted",
            "public",
            null
          ],
          "source": "function setCompleted(uint completed)\n        public\n        restricted\n    {\n        last_completed_migration = completed;\n    }",
          "start": {
            "line": 17,
            "column": 4
          },
          "end": {
            "line": 22,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "upgrade",
          "params": [
            {
              "name": "new_address",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "restricted",
            "public",
            null
          ],
          "source": "function upgrade(address new_address)\n        public\n        restricted\n    {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }",
          "start": {
            "line": 24,
            "column": 4
          },
          "end": {
            "line": 30,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [
        {
          "name": "restricted",
          "params": []
        }
      ],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed)\n        public\n        restricted\n    {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address)\n        public\n        restricted\n    {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
      "inFile": "Migrations.sol",
      "references": [
        "Migrations"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "Executor",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "execute",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
          "start": {
            "line": 9,
            "column": 4
          },
          "end": {
            "line": 19,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 21,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeDelegateCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 31,
            "column": 4
          },
          "end": {
            "line": 39,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Executor - A contract that can execute transactions",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/Enum.sol\";\n\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }\n\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n}\n",
      "inFile": "Executor.sol",
      "references": [
        "Enum.Operation"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "FallbackManager",
      "baseContracts": [
        "SelfAuthorized"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "FALLBACK_HANDLER_STORAGE_SLOT",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "FALLBACK_HANDLER_STORAGE_SLOT",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "internalSetFallbackHandler",
          "params": [
            {
              "name": "handler",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 18,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "setFallbackHandler",
          "params": [
            {
              "name": "handler",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "contract to handle fallbacks calls."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }",
          "start": {
            "line": 24,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "handler contract to handle fallbacks calls.",
              "subAnnotation": {
                "name": "handler",
                "value": "contract to handle fallbacks calls.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }",
          "start": {
            "line": 31,
            "column": 4
          },
          "end": {
            "line": 56,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Fallback Manager - A contract that manages fallback calls made to this contract",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallbacks calls.\n    function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }\n\n    function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }\n}",
      "inFile": "FallbackManager.sol",
      "references": [
        "SelfAuthorized"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "Module",
      "baseContracts": [
        "MasterCopy"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "manager",
          "solidityType": {
            "name": "ModuleManager",
            "userDefined": true,
            "references": [
              "ModuleManager"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "manager",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "ModuleManager",
                  "userDefined": true,
                  "references": [
                    "ModuleManager"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setManager",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Module - Base class for modules.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/MasterCopy.sol\";\nimport \"./ModuleManager.sol\";\n\n\n/// @title Module - Base class for modules.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Module is MasterCopy {\n\n    ModuleManager public manager;\n\n    modifier authorized() {\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\n        _;\n    }\n\n    function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }\n}\n",
      "inFile": "Module.sol",
      "references": [
        "MasterCopy",
        "ModuleManager"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "ModuleManager",
      "baseContracts": [
        "SelfAuthorized",
        "Executor"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "SENTINEL_MODULES",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SENTINEL_MODULES",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "modules",
          "solidityType": {
            "name": "(address => address)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "modules",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setupModules",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }",
          "start": {
            "line": 22,
            "column": 4
          },
          "end": {
            "line": 30,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "enableModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module to be whitelisted."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }",
          "start": {
            "line": 35,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "module Module to be whitelisted.",
              "subAnnotation": {
                "name": "module",
                "value": "Module to be whitelisted.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "disableModule",
          "params": [
            {
              "name": "prevModule",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module that pointed to the module to be removed in the linked list"
            },
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module to be removed."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }",
          "start": {
            "line": 52,
            "column": 4
          },
          "end": {
            "line": 62,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "module Module to be removed.",
              "subAnnotation": {
                "name": "module",
                "value": "Module to be removed.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevModule Module that pointed to the module to be removed in the linked list",
              "subAnnotation": {
                "name": "prevModule",
                "value": "Module that pointed to the module to be removed in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "execTransactionFromModule",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of module transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of module transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of module transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of module transaction."
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }",
          "start": {
            "line": 69,
            "column": 4
          },
          "end": {
            "line": 79,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "operation Operation type of module transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of module transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of module transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of module transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows a Module to execute a Safe transaction without any further confirmations.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "execTransactionFromModuleReturnData",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of module transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of module transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of module transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of module transaction."
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "returnData",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }",
          "start": {
            "line": 86,
            "column": 4
          },
          "end": {
            "line": 105,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "operation Operation type of module transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of module transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of module transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of module transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of module transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows a Module to execute a Safe transaction without any further confirmations and return data",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getModules",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }",
          "start": {
            "line": 109,
            "column": 4
          },
          "end": {
            "line": 116,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of modules.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns array of first 10 modules.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getModulesPaginated",
          "params": [
            {
              "name": "start",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Start of the page."
            },
            {
              "name": "pageSize",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Maximum number of modules that should be returned."
            }
          ],
          "returnParams": [
            {
              "name": "array",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "next",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }",
          "start": {
            "line": 122,
            "column": 4
          },
          "end": {
            "line": 144,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of modules.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "pageSize Maximum number of modules that should be returned.",
              "subAnnotation": {
                "name": "pageSize",
                "value": "Maximum number of modules that should be returned.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "start Start of the page.",
              "subAnnotation": {
                "name": "start",
                "value": "Start of the page.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns array of modules.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Module Manager - A contract that manages modules that can execute transactions via this contract",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "EnabledModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "DisabledModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionFromModuleSuccess",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        },
        {
          "name": "ExecutionFromModuleFailure",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [],
      "inheritedFunctions": [
        {
          "name": "execute",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
          "start": {
            "line": 9,
            "column": 4
          },
          "end": {
            "line": 19,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 21,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "executeDelegateCall",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "txGas",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "success",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
          "start": {
            "line": 31,
            "column": 4
          },
          "end": {
            "line": 39,
            "column": 4
          },
          "annotations": []
        }
      ],
      "inheritedEvents": [],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\nimport \"./Module.sol\";\n\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n\n    event EnabledModule(Module module);\n    event DisabledModule(Module module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping (address => address) internal modules;\n\n    function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @param module Module to be whitelisted.\n    function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns array of first 10 modules.\n    /// @return Array of modules.\n    function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return Array of modules.\n    function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n",
      "inFile": "ModuleManager.sol",
      "references": [
        "SelfAuthorized",
        "Executor",
        "Module",
        "Enum.Operation"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "OwnerManager",
      "baseContracts": [
        "SelfAuthorized"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "SENTINEL_OWNERS",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "SENTINEL_OWNERS",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "owners",
          "solidityType": {
            "name": "(address => address)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "owners",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "ownerCount",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "default",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "ownerCount",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "threshold",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "threshold",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setupOwners",
          "params": [
            {
              "name": "_owners",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of Safe owners."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Number of required confirmations for a Safe transaction."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }",
          "start": {
            "line": 22,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold Number of required confirmations for a Safe transaction.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "Number of required confirmations for a Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_owners List of Safe owners.",
              "subAnnotation": {
                "name": "_owners",
                "value": "List of Safe owners.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "addOwnerWithThreshold",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New owner address."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
          "start": {
            "line": 52,
            "column": 4
          },
          "end": {
            "line": 67,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "owner New owner address.",
              "subAnnotation": {
                "name": "owner",
                "value": "New owner address.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "removeOwner",
          "params": [
            {
              "name": "prevOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner that pointed to the owner to be removed in the linked list"
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner address to be removed."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
          "start": {
            "line": 74,
            "column": 4
          },
          "end": {
            "line": 90,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "owner Owner address to be removed.",
              "subAnnotation": {
                "name": "owner",
                "value": "Owner address to be removed.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevOwner Owner that pointed to the owner to be removed in the linked list",
              "subAnnotation": {
                "name": "prevOwner",
                "value": "Owner that pointed to the owner to be removed in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "swapOwner",
          "params": [
            {
              "name": "prevOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner that pointed to the owner to be replaced in the linked list"
            },
            {
              "name": "oldOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner address to be replaced."
            },
            {
              "name": "newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New owner address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }",
          "start": {
            "line": 97,
            "column": 4
          },
          "end": {
            "line": 113,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "newOwner New owner address.",
              "subAnnotation": {
                "name": "newOwner",
                "value": "New owner address.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "oldOwner Owner address to be replaced.",
              "subAnnotation": {
                "name": "oldOwner",
                "value": "Owner address to be replaced.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
              "subAnnotation": {
                "name": "prevOwner",
                "value": "Owner that pointed to the owner to be replaced in the linked list",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "changeThreshold",
          "params": [
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New threshold."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }",
          "start": {
            "line": 118,
            "column": 4
          },
          "end": {
            "line": 128,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold New threshold.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "New threshold.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "getThreshold",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }",
          "start": {
            "line": 130,
            "column": 4
          },
          "end": {
            "line": 136,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "isOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }",
          "start": {
            "line": 138,
            "column": 4
          },
          "end": {
            "line": 144,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "getOwners",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }",
          "start": {
            "line": 148,
            "column": 4
          },
          "end": {
            "line": 164,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Array of Safe owners.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns array of owners.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "OwnerManager - Manages a set of owners and a threshold to perform actions.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "AddedOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "RemovedOwner",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "ChangedThreshold",
          "params": [
            {
              "name": "threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}\n",
      "inFile": "OwnerManager.sol",
      "references": [
        "SelfAuthorized"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "Enum",
      "baseContracts": [],
      "enumerations": [
        {
          "name": "Enum.Operation",
          "shortName": "Operation",
          "parentName": "Enum",
          "elementType": 2,
          "entries": [
            {
              "name": "Call",
              "index": 0
            },
            {
              "name": "DelegateCall",
              "index": 1
            }
          ]
        }
      ],
      "structs": [],
      "stateVariables": [],
      "functions": [],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Enum - Collection of enums",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n",
      "inFile": "Enum.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "EtherPaymentFallback",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n\n    }",
          "start": {
            "line": 9,
            "column": 4
          },
          "end": {
            "line": 14,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Fallback function accepts Ether transactions.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "EtherPaymentFallback - A contract that has a fallback to accept ether payments",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n\n    /// @dev Fallback function accepts Ether transactions.\n    function ()\n        external\n        payable\n    {\n\n    }\n}\n",
      "inFile": "EtherPaymentFallback.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "MasterCopy",
      "baseContracts": [
        "SelfAuthorized"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./SelfAuthorized.sol\";\n\n\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/Proxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MasterCopy is SelfAuthorized {\n\n    event ChangedMasterCopy(address masterCopy);\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private masterCopy;\n\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\n    /// @param _masterCopy New contract address.\n    function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }\n}\n",
      "inFile": "MasterCopy.sol",
      "references": [
        "SelfAuthorized"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "SecuredTokenTransfer",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "transferToken",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token that should be transferred"
            },
            {
              "name": "receiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Receiver to whom the token should be transferred"
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "The amount of tokens that should be transferred"
            }
          ],
          "returnParams": [
            {
              "name": "transferred",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 32,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "amount The amount of tokens that should be transferred",
              "subAnnotation": {
                "name": "amount",
                "value": "The amount of tokens that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "receiver Receiver to whom the token should be transferred",
              "subAnnotation": {
                "name": "receiver",
                "value": "Receiver to whom the token should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "token Token that should be transferred",
              "subAnnotation": {
                "name": "token",
                "value": "Token that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Transfers a token and returns if it was a success",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "SecuredTokenTransfer - Secure token transfer",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }\n}\n",
      "inFile": "SecuredTokenTransfer.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "SelfAuthorized",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "SelfAuthorized - authorizes current contract to perform actions",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    modifier authorized() {\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\n        _;\n    }\n}\n",
      "inFile": "SelfAuthorized.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "SignatureDecoder",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "recoverKey",
          "params": [
            {
              "name": "messageHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "operation ethereum signed message hash"
            },
            {
              "name": "messageSignature",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "message `txHash` signature"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
          "start": {
            "line": 13,
            "column": 4
          },
          "end": {
            "line": 27,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "pos which signature to read",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageSignature message `txHash` signature",
              "subAnnotation": {
                "name": "messageSignature",
                "value": "message `txHash` signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageHash operation ethereum signed message hash",
              "subAnnotation": {
                "name": "messageHash",
                "value": "operation ethereum signed message hash",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Recovers address who signed the message",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "signatureSplit",
          "params": [
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "concatenated rsv signatures"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
            }
          ],
          "returnParams": [
            {
              "name": "v",
              "solidityType": {
                "name": "uint8",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "r",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "s",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 53,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "signatures concatenated rsv signatures",
              "subAnnotation": {
                "name": "signatures",
                "value": "concatenated rsv signatures",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Ricardo Guilherme Schmidt (Status Research & Development GmbH)",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "SignatureDecoder - Decodes signatures that a encoded as bytes",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    \n    /// @dev Recovers address who signed the message\n    /// @param messageHash operation ethereum signed message hash\n    /// @param messageSignature message `txHash` signature\n    /// @param pos which signature to read\n    function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }\n\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n",
      "inFile": "SignatureDecoder.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "SafeMath",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "mul",
          "params": [
            {
              "name": "a",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "b",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }",
          "start": {
            "line": 13,
            "column": 2
          },
          "end": {
            "line": 25,
            "column": 2
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Multiplies two numbers, reverts on overflow.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "div",
          "params": [
            {
              "name": "a",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "b",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }",
          "start": {
            "line": 30,
            "column": 2
          },
          "end": {
            "line": 36,
            "column": 2
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Integer division of two numbers truncating the quotient, reverts on division by zero.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "sub",
          "params": [
            {
              "name": "a",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "b",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }",
          "start": {
            "line": 41,
            "column": 2
          },
          "end": {
            "line": 46,
            "column": 2
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "add",
          "params": [
            {
              "name": "a",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "b",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }",
          "start": {
            "line": 51,
            "column": 2
          },
          "end": {
            "line": 56,
            "column": 2
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Adds two numbers, reverts on overflow.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "mod",
          "params": [
            {
              "name": "a",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "b",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }",
          "start": {
            "line": 62,
            "column": 2
          },
          "end": {
            "line": 65,
            "column": 2
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "reverts when dividing by zero.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Divides two numbers and returns the remainder (unsigned integer modulo),",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "*",
          "value": "*/",
          "subAnnotation": null
        },
        {
          "name": "*",
          "value": "TODO: remove once open zeppelin update to solc 0.5.0",
          "subAnnotation": null
        },
        {
          "name": "dev",
          "value": "Math operations with safety checks that revert on error",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "SafeMath",
          "subAnnotation": null
        },
        {
          "name": "/*",
          "value": "/**",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "library",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}",
      "inFile": "SafeMath.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "DefaultCallbackHandler",
      "baseContracts": [
        "ERC1155TokenReceiver",
        "ERC777TokensRecipient",
        "ERC721TokenReceiver"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "onERC1155Received",
          "params": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xf23a6e61;\n    }",
          "start": {
            "line": 14,
            "column": 4
          },
          "end": {
            "line": 19,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "onERC1155BatchReceived",
          "params": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256[]",
                "pureName": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256[]",
                "pureName": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xbc197c81;\n    }",
          "start": {
            "line": 21,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "onERC721Received",
          "params": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0x150b7a02;\n    }",
          "start": {
            "line": 28,
            "column": 4
          },
          "end": {
            "line": 33,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "tokensReceived",
          "params": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external {\n        // We implement this for completeness, doesn't really have any value\n    }",
          "start": {
            "line": 36,
            "column": 4
          },
          "end": {
            "line": 38,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Default Callback Handler - returns true for known token callbacks",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../interfaces/ERC1155TokenReceiver.sol\";\nimport \"../interfaces/ERC721TokenReceiver.sol\";\nimport \"../interfaces/ERC777TokensRecipient.sol\";\n\n/// @title Default Callback Handler - returns true for known token callbacks\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract DefaultCallbackHandler is ERC1155TokenReceiver, ERC777TokensRecipient, ERC721TokenReceiver {\n\n    string public constant NAME = \"Default Callback Handler\";\n    string public constant VERSION = \"1.0.0\";\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xbc197c81;\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0x150b7a02;\n    }\n\n    // solium-disable-next-line no-empty-blocks\n    function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external {\n        // We implement this for completeness, doesn't really have any value\n    }\n\n}",
      "inFile": "DefaultCallbackHandler.sol",
      "references": [
        "ERC1155TokenReceiver",
        "ERC777TokensRecipient",
        "ERC721TokenReceiver"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "ERC1155TokenReceiver",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "onERC1155Received",
          "params": [
            {
              "name": "_operator",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_id",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);",
          "start": {
            "line": 20,
            "column": 4
          },
          "end": {
            "line": 20,
            "column": 140
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "onERC1155BatchReceived",
          "params": [
            {
              "name": "_operator",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_ids",
              "solidityType": {
                "name": "uint256[]",
                "pureName": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_values",
              "solidityType": {
                "name": "uint256[]",
                "pureName": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);",
          "start": {
            "line": 35,
            "column": 4
          },
          "end": {
            "line": 35,
            "column": 169
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "*",
          "value": "*/",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface ERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        \n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _id        The ID of the token being transferred\n        @param _value     The amount of tokens being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.        \n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);       \n}",
      "inFile": "ERC1155TokenReceiver.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "ERC721TokenReceiver",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "onERC721Received",
          "params": [
            {
              "name": "_operator",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_tokenId",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);",
          "start": {
            "line": 17,
            "column": 4
          },
          "end": {
            "line": 17,
            "column": 128
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "dev",
          "value": "Note: the ERC-165 identifier for this interface is 0x150b7a02.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}",
      "inFile": "ERC721TokenReceiver.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "ERC777TokensRecipient",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "tokensReceived",
          "params": [
            {
              "name": "operator",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "operatorData",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;",
          "start": {
            "line": 4,
            "column": 4
          },
          "end": {
            "line": 11,
            "column": 14
          },
          "annotations": []
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\ninterface ERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}",
      "inFile": "ERC777TokensRecipient.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "ISignatureValidatorConstants",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "EIP1271_MAGIC_VALUE",
          "solidityType": {
            "name": "bytes4",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "EIP1271_MAGIC_VALUE",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes4",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\ncontract ISignatureValidator is ISignatureValidatorConstants {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);\n}",
      "inFile": "ISignatureValidator.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "ISignatureValidator",
      "baseContracts": [
        "ISignatureValidatorConstants"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "isValidSignature",
          "params": [
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_signature",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);",
          "start": {
            "line": 19,
            "column": 4
          },
          "end": {
            "line": 24,
            "column": 24
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "MUST allow external calls",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "MUST return the bytes4 magic value 0x20c13b0b when function passes.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "EIP1271_MAGIC_VALUE",
          "solidityType": {
            "name": "bytes4",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "EIP1271_MAGIC_VALUE",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes4",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\ncontract ISignatureValidator is ISignatureValidatorConstants {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);\n}",
      "inFile": "ISignatureValidator.sol",
      "references": [
        "ISignatureValidatorConstants"
      ],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "CreateAndAddModules",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "enableModule",
          "params": [
            {
              "name": "module",
              "solidityType": {
                "name": "Module",
                "userDefined": true,
                "references": [
                  "Module"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Not used."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function enableModule(Module module)\n        public\n    {\n        revert();\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 16,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "module Not used.",
              "subAnnotation": {
                "name": "module",
                "value": "Not used.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Function required to compile contract. Gnosis Safe function is called instead.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "createAndAddModules",
          "params": [
            {
              "name": "proxyFactory",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Module proxy factory contract."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function createAndAddModules(address proxyFactory, bytes memory data)\n        public\n    {\n        uint256 length = data.length;\n        Module module;\n        uint256 i = 0;\n        while (i < length) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let createBytesLength := mload(add(0x20, add(data, i)))\n                let createBytes := add(0x40, add(data, i))\n\n                let output := mload(0x40)\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\n\n                // Data is always padded to 32 bytes\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\n            }\n            this.enableModule(module);\n        }\n    }",
          "start": {
            "line": 21,
            "column": 4
          },
          "end": {
            "line": 42,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)",
              "subAnnotation": {
                "name": "data",
                "value": "Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "proxyFactory Module proxy factory contract.",
              "subAnnotation": {
                "name": "proxyFactory",
                "value": "Module proxy factory contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to create and add multiple module in one transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Create and Add Modules - Allows to create and add multiple module in one transaction.",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0xF61A721642B0c0C8b334bA3763BA1326F53798C0",
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\n\n\n/// @title Create and Add Modules - Allows to create and add multiple module in one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract CreateAndAddModules {\n\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\n    /// @param module Not used.\n    function enableModule(Module module)\n        public\n    {\n        revert();\n    }\n\n    /// @dev Allows to create and add multiple module in one transaction.\n    /// @param proxyFactory Module proxy factory contract.\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)\n    function createAndAddModules(address proxyFactory, bytes memory data)\n        public\n    {\n        uint256 length = data.length;\n        Module module;\n        uint256 i = 0;\n        while (i < length) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let createBytesLength := mload(add(0x20, add(data, i)))\n                let createBytes := add(0x40, add(data, i))\n\n                let output := mload(0x40)\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\n\n                // Data is always padded to 32 bytes\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\n            }\n            this.enableModule(module);\n        }\n    }\n}\n",
      "inFile": "CreateAndAddModules.sol",
      "references": [
        "Module"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "CreateCall",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "performCreate2",
          "params": [
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "deploymentData",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "salt",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "newContract",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function performCreate2(uint256 value, bytes memory deploymentData, bytes32 salt) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }",
          "start": {
            "line": 9,
            "column": 4
          },
          "end": {
            "line": 16,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "performCreate",
          "params": [
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "deploymentData",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": "newContract",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function performCreate(uint256 value, bytes memory deploymentData) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Create Call - Allows to use the different create opcodes to deploy a contract",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x8538FcBccba7f5303d2C679Fa5d7A629A8c9bf4A",
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "ContractCreation",
          "params": [
            {
              "name": "newContract",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Create Call - Allows to use the different create opcodes to deploy a contract\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract CreateCall {\n    event ContractCreation(address newContract);\n\n    function performCreate2(uint256 value, bytes memory deploymentData, bytes32 salt) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }\n\n    function performCreate(uint256 value, bytes memory deploymentData) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }\n}",
      "inFile": "CreateCall.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "MultiSend",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "GUARD_VALUE",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "GUARD_VALUE",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "guard",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "default",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "guard",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor() public {\n        guard = GUARD_VALUE;\n    }",
          "start": {
            "line": 15,
            "column": 4
          },
          "end": {
            "line": 17,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "multiSend",
          "params": [
            {
              "name": "transactions",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function multiSend(bytes memory transactions)\n        public\n    {\n        require(guard != GUARD_VALUE, \"MultiSend should only be called via delegatecall\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\n                if eq(success, 0) { revert(0, 0) }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }",
          "start": {
            "line": 27,
            "column": 4
          },
          "end": {
            "line": 58,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "GonÃ§alo SÃ¡ - <goncalo.sa@consensys.net>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Nick Dodson - <nick.dodson@consensys.net>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Multi Send - Allows to batch multiple transactions into one.",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Multi Send - Allows to batch multiple transactions into one.\n/// @author Nick Dodson - <nick.dodson@consensys.net>\n/// @author GonÃ§alo SÃ¡ - <goncalo.sa@consensys.net>\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MultiSend {\n\n    bytes32 constant private GUARD_VALUE = keccak256(\"multisend.guard.bytes32\");\n\n    bytes32 guard;\n\n    constructor() public {\n        guard = GUARD_VALUE;\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    function multiSend(bytes memory transactions)\n        public\n    {\n        require(guard != GUARD_VALUE, \"MultiSend should only be called via delegatecall\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\n                if eq(success, 0) { revert(0, 0) }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}\n",
      "inFile": "MultiSend.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "ERC1155Token",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "_balances",
          "solidityType": {
            "name": "(uint256 => (address => uint256))",
            "mapping": {
              "key": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "(address => uint256)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "_balances",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "(address => uint256)",
                  "mapping": {
                    "key": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "value": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "_operatorApprovals",
          "solidityType": {
            "name": "(address => (address => bool))",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "(address => bool)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "_operatorApprovals",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "(address => bool)",
                  "mapping": {
                    "key": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "value": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "balanceOf",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "id",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function balanceOf(address owner, uint256 id) public view returns (uint256) {\n        require(owner != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][owner];\n    }",
          "start": {
            "line": 22,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "safeTransferFrom",
          "params": [
            {
              "name": "from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "id",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }",
          "start": {
            "line": 37,
            "column": 4
          },
          "end": {
            "line": 56,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "mint",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "The address that will own the minted token"
            },
            {
              "name": "id",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "ID of the token to be minted"
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Amount of the token to be minted"
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data forwarded to `onERC1155Received` if `to` is a contract receiver"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function mint(address to, uint256 id, uint256 value, bytes calldata data) external {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n    }",
          "start": {
            "line": 65,
            "column": 4
          },
          "end": {
            "line": 71,
            "column": 4
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "data Data forwarded to `onERC1155Received` if `to` is a contract receiver",
              "subAnnotation": {
                "name": "data",
                "value": "Data forwarded to `onERC1155Received` if `to` is a contract receiver",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Amount of the token to be minted",
              "subAnnotation": {
                "name": "value",
                "value": "Amount of the token to be minted",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "id ID of the token to be minted",
              "subAnnotation": {
                "name": "id",
                "value": "ID of the token to be minted",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to The address that will own the minted token",
              "subAnnotation": {
                "name": "to",
                "value": "The address that will own the minted token",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Test function to mint an amount of a token with the given ID",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "isContract",
          "params": [
            {
              "name": "account",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "view"
          ],
          "source": "function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }",
          "start": {
            "line": 73,
            "column": 4
          },
          "end": {
            "line": 82,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "_doSafeTransferAcceptanceCheck",
          "params": [
            {
              "name": "operator",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "id",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n    {\n        if(isContract(to)) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    ERC1155TokenReceiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }",
          "start": {
            "line": 84,
            "column": 4
          },
          "end": {
            "line": 101,
            "column": 4
          },
          "annotations": []
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../interfaces/ERC1155TokenReceiver.sol\";\nimport \"../external/SafeMath.sol\";\n\ncontract ERC1155Token {\n\n    using SafeMath for uint256;\n\n    // Mapping from token ID to owner balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n        @dev Get the specified address' balance for token with specified ID.\n        @param owner The address of the token holder\n        @param id ID of the token\n        @return The owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id) public view returns (uint256) {\n        require(owner != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][owner];\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }\n\n    /**\n     * @dev Test function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function mint(address to, uint256 id, uint256 value, bytes calldata data) external {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n    {\n        if(isContract(to)) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    ERC1155TokenReceiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }\n}",
      "inFile": "ERC1155Token.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "Token",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "transfer",
          "params": [
            {
              "name": "_to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function transfer(address _to, uint value) public returns (bool);",
          "start": {
            "line": 4,
            "column": 1
          },
          "end": {
            "line": 4,
            "column": 65
          },
          "annotations": []
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"@gnosis.pm/mock-contract/contracts/MockContract.sol\";\ncontract Token {\n\tfunction transfer(address _to, uint value) public returns (bool);\n}\n",
      "inFile": "Token.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "DailyLimitModule",
      "baseContracts": [
        "Module"
      ],
      "enumerations": [],
      "structs": [
        {
          "name": "DailyLimitModule.DailyLimit",
          "shortName": "DailyLimit",
          "parentName": "DailyLimitModule",
          "elementType": 1,
          "fields": [
            {
              "name": "dailyLimit",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "spentToday",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "lastDay",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        }
      ],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "dailyLimits",
          "solidityType": {
            "name": "(address => DailyLimit)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "DailyLimit",
                "userDefined": true,
                "references": [
                  "DailyLimit"
                ],
                "isArray": false
              }
            },
            "userDefined": true,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "dailyLimits",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "DailyLimit",
                  "userDefined": true,
                  "references": [
                    "DailyLimit"
                  ],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "DailyLimit",
                  "userDefined": true,
                  "references": [
                    "DailyLimit"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setup",
          "params": [
            {
              "name": "tokens",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of token addresses. Ether is represented with address 0x0."
            },
            {
              "name": "_dailyLimits",
              "solidityType": {
                "name": "uint256[]",
                "pureName": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of daily limits in smalles units (e.g. Wei for Ether)."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function setup(address[] memory tokens, uint256[] memory _dailyLimits)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < tokens.length; i++)\n            dailyLimits[tokens[i]].dailyLimit = _dailyLimits[i];\n    }",
          "start": {
            "line": 27,
            "column": 4
          },
          "end": {
            "line": 33,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_dailyLimits List of daily limits in smalles units (e.g. Wei for Ether).",
              "subAnnotation": {
                "name": "_dailyLimits",
                "value": "List of daily limits in smalles units (e.g. Wei for Ether).",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "tokens List of token addresses. Ether is represented with address 0x0.",
              "subAnnotation": {
                "name": "tokens",
                "value": "List of token addresses. Ether is represented with address 0x0.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "changeDailyLimit",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token contract address."
            },
            {
              "name": "dailyLimit",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Daily limit in smallest token unit."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeDailyLimit(address token, uint256 dailyLimit)\n        public\n        authorized\n    {\n        dailyLimits[token].dailyLimit = dailyLimit;\n    }",
          "start": {
            "line": 38,
            "column": 4
          },
          "end": {
            "line": 43,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "dailyLimit Daily limit in smallest token unit.",
              "subAnnotation": {
                "name": "dailyLimit",
                "value": "Daily limit in smallest token unit.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "token Token contract address.",
              "subAnnotation": {
                "name": "token",
                "value": "Token contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to update the daily limit for a specified token. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "executeDailyLimit",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of the token that should be transfered (0 for Ether)"
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address to which the tokens should be transfered"
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Amount of tokens (or Ether) that should be transfered"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function executeDailyLimit(address token, address to, uint256 amount)\n        public\n    {\n        // Only Safe owners are allowed to execute daily limit transactions.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(to != address(0), \"Invalid to address provided\");\n        require(amount > 0, \"Invalid amount provided\");\n        // Validate that transfer is not exceeding daily limit.\n        require(isUnderLimit(token, amount), \"Daily limit has been reached\");\n        dailyLimits[token].spentToday += amount;\n        if (token == address(0)) {\n            require(manager.execTransactionFromModule(to, amount, \"\", Enum.Operation.Call), \"Could not execute ether transfer\");\n        } else {\n            bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n            require(manager.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \"Could not execute token transfer\");\n        }\n    }",
          "start": {
            "line": 50,
            "column": 4
          },
          "end": {
            "line": 66,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Returns if transaction can be executed.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "amount Amount of tokens (or Ether) that should be transfered",
              "subAnnotation": {
                "name": "amount",
                "value": "Amount of tokens (or Ether) that should be transfered",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Address to which the tokens should be transfered",
              "subAnnotation": {
                "name": "to",
                "value": "Address to which the tokens should be transfered",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "token Address of the token that should be transfered (0 for Ether)",
              "subAnnotation": {
                "name": "token",
                "value": "Address of the token that should be transfered (0 for Ether)",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns if Safe transaction is a valid daily limit transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "isUnderLimit",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function isUnderLimit(address token, uint256 amount)\n        internal\n        returns (bool)\n    {\n        DailyLimit storage dailyLimit = dailyLimits[token];\n        if (today() > dailyLimit.lastDay) {\n            dailyLimit.lastDay = today();\n            dailyLimit.spentToday = 0;\n        }\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit && \n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\n            return true;\n        return false;\n    }",
          "start": {
            "line": 68,
            "column": 4
          },
          "end": {
            "line": 81,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "today",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function today()\n        public\n        view\n        returns (uint)\n    {\n        return now - (now % 1 days);\n    }",
          "start": {
            "line": 85,
            "column": 4
          },
          "end": {
            "line": 91,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Unix timestamp.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns last midnight as Unix timestamp.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Daily Limit Module - Allows to transfer limited amounts of ERC20 tokens and Ether without confirmations.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "manager",
          "solidityType": {
            "name": "ModuleManager",
            "userDefined": true,
            "references": [
              "ModuleManager"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "manager",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "ModuleManager",
                  "userDefined": true,
                  "references": [
                    "ModuleManager"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "setManager",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Daily Limit Module - Allows to transfer limited amounts of ERC20 tokens and Ether without confirmations.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract DailyLimitModule is Module {\n\n    string public constant NAME = \"Daily Limit Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // dailyLimits mapping maps token address to daily limit settings.\n    mapping (address => DailyLimit) public dailyLimits;\n\n    struct DailyLimit {\n        uint256 dailyLimit;\n        uint256 spentToday;\n        uint256 lastDay;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param tokens List of token addresses. Ether is represented with address 0x0.\n    /// @param _dailyLimits List of daily limits in smalles units (e.g. Wei for Ether).\n    function setup(address[] memory tokens, uint256[] memory _dailyLimits)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < tokens.length; i++)\n            dailyLimits[tokens[i]].dailyLimit = _dailyLimits[i];\n    }\n\n    /// @dev Allows to update the daily limit for a specified token. This can only be done via a Safe transaction.\n    /// @param token Token contract address.\n    /// @param dailyLimit Daily limit in smallest token unit.\n    function changeDailyLimit(address token, uint256 dailyLimit)\n        public\n        authorized\n    {\n        dailyLimits[token].dailyLimit = dailyLimit;\n    }\n\n    /// @dev Returns if Safe transaction is a valid daily limit transaction.\n    /// @param token Address of the token that should be transfered (0 for Ether)\n    /// @param to Address to which the tokens should be transfered\n    /// @param amount Amount of tokens (or Ether) that should be transfered\n    /// @return Returns if transaction can be executed.\n    function executeDailyLimit(address token, address to, uint256 amount)\n        public\n    {\n        // Only Safe owners are allowed to execute daily limit transactions.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(to != address(0), \"Invalid to address provided\");\n        require(amount > 0, \"Invalid amount provided\");\n        // Validate that transfer is not exceeding daily limit.\n        require(isUnderLimit(token, amount), \"Daily limit has been reached\");\n        dailyLimits[token].spentToday += amount;\n        if (token == address(0)) {\n            require(manager.execTransactionFromModule(to, amount, \"\", Enum.Operation.Call), \"Could not execute ether transfer\");\n        } else {\n            bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n            require(manager.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \"Could not execute token transfer\");\n        }\n    }\n\n    function isUnderLimit(address token, uint256 amount)\n        internal\n        returns (bool)\n    {\n        DailyLimit storage dailyLimit = dailyLimits[token];\n        if (today() > dailyLimit.lastDay) {\n            dailyLimit.lastDay = today();\n            dailyLimit.spentToday = 0;\n        }\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit && \n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\n            return true;\n        return false;\n    }\n\n    /// @dev Returns last midnight as Unix timestamp.\n    /// @return Unix timestamp.\n    function today()\n        public\n        view\n        returns (uint)\n    {\n        return now - (now % 1 days);\n    }\n}\n",
      "inFile": "DailyLimitModule.sol",
      "references": [
        "Module",
        "DailyLimit"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "SocialRecoveryModule",
      "baseContracts": [
        "Module"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "threshold",
          "solidityType": {
            "name": "uint256",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "threshold",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "friends",
          "solidityType": {
            "name": "address[]",
            "pureName": "address",
            "userDefined": false,
            "references": [],
            "isArray": true
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "friends",
            "params": [
              {
                "solidityType": {
                  "isArray": false,
                  "name": "uint256",
                  "references": [],
                  "userDefined": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "isFriend",
          "solidityType": {
            "name": "(address => bool)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "isFriend",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "isExecuted",
          "solidityType": {
            "name": "(bytes32 => bool)",
            "mapping": {
              "key": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "isExecuted",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "isConfirmed",
          "solidityType": {
            "name": "(bytes32 => (address => bool))",
            "mapping": {
              "key": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "(address => bool)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "isConfirmed",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "(address => bool)",
                  "mapping": {
                    "key": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "value": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setup",
          "params": [
            {
              "name": "_friends",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of friends' addresses."
            },
            {
              "name": "_threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Required number of friends to confirm replacement."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function setup(address[] memory _friends, uint256 _threshold)\n        public\n    {\n        require(_threshold <= _friends.length, \"Threshold cannot exceed friends count\");\n        require(_threshold >= 2, \"At least 2 friends required\");\n        setManager();\n        // Set allowed friends.\n        for (uint256 i = 0; i < _friends.length; i++) {\n            address friend = _friends[i];\n            require(friend != address(0), \"Invalid friend address provided\");\n            require(!isFriend[friend], \"Duplicate friend address provided\");\n            isFriend[friend] = true;\n        }\n        friends = _friends;\n        threshold = _threshold;\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 48,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_threshold Required number of friends to confirm replacement.",
              "subAnnotation": {
                "name": "_threshold",
                "value": "Required number of friends to confirm replacement.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_friends List of friends' addresses.",
              "subAnnotation": {
                "name": "_friends",
                "value": "List of friends' addresses.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "confirmTransaction",
          "params": [
            {
              "name": "dataHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Safe transaction hash."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "onlyFriend",
            "public",
            null
          ],
          "source": "function confirmTransaction(bytes32 dataHash)\n        public\n        onlyFriend\n    {\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        isConfirmed[dataHash][msg.sender] = true;\n    }",
          "start": {
            "line": 52,
            "column": 4
          },
          "end": {
            "line": 58,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "dataHash Safe transaction hash.",
              "subAnnotation": {
                "name": "dataHash",
                "value": "Safe transaction hash.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows a friend to confirm a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "recoverAccess",
          "params": [
            {
              "name": "prevOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner that pointed to the owner to be replaced in the linked list"
            },
            {
              "name": "oldOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Owner address to be replaced."
            },
            {
              "name": "newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New owner address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "onlyFriend",
            "public",
            null
          ],
          "source": "function recoverAccess(address prevOwner, address oldOwner, address newOwner)\n        public\n        onlyFriend\n    {\n        bytes memory data = abi.encodeWithSignature(\"swapOwner(address,address,address)\", prevOwner, oldOwner, newOwner);\n        bytes32 dataHash = getDataHash(data);\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        require(isConfirmedByRequiredFriends(dataHash), \"Recovery has not enough confirmations\");\n        isExecuted[dataHash] = true;\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \"Could not execute recovery\");\n    }",
          "start": {
            "line": 65,
            "column": 4
          },
          "end": {
            "line": 75,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Returns if transaction can be executed.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "newOwner New owner address.",
              "subAnnotation": {
                "name": "newOwner",
                "value": "New owner address.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "oldOwner Owner address to be replaced.",
              "subAnnotation": {
                "name": "oldOwner",
                "value": "Owner address to be replaced.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
              "subAnnotation": {
                "name": "prevOwner",
                "value": "Owner that pointed to the owner to be replaced in the linked list",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns if Safe transaction is a valid owner replacement transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "isConfirmedByRequiredFriends",
          "params": [
            {
              "name": "dataHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Data hash."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function isConfirmedByRequiredFriends(bytes32 dataHash)\n        public\n        view\n        returns (bool)\n    {\n        uint256 confirmationCount;\n        for (uint256 i = 0; i < friends.length; i++) {\n            if (isConfirmed[dataHash][friends[i]])\n                confirmationCount++;\n            if (confirmationCount == threshold)\n                return true;\n        }\n        return false;\n    }",
          "start": {
            "line": 80,
            "column": 4
          },
          "end": {
            "line": 93,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Confirmation status.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "dataHash Data hash.",
              "subAnnotation": {
                "name": "dataHash",
                "value": "Data hash.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns if Safe transaction is a valid owner replacement transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getDataHash",
          "params": [
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "pure"
          ],
          "source": "function getDataHash(bytes memory data)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(data);\n    }",
          "start": {
            "line": 98,
            "column": 4
          },
          "end": {
            "line": 104,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Data hash.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "data Data payload.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns hash of data encoding owner replacement.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Social Recovery Module - Allows to replace an owner without Safe confirmations if friends approve the replacement.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [
        {
          "name": "onlyFriend",
          "params": []
        }
      ],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "manager",
          "solidityType": {
            "name": "ModuleManager",
            "userDefined": true,
            "references": [
              "ModuleManager"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "manager",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "ModuleManager",
                  "userDefined": true,
                  "references": [
                    "ModuleManager"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "setManager",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Social Recovery Module - Allows to replace an owner without Safe confirmations if friends approve the replacement.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract SocialRecoveryModule is Module {\n\n    string public constant NAME = \"Social Recovery Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    uint256 public threshold;\n    address[] public friends;\n\n    // isFriend mapping maps friend's address to friend status.\n    mapping (address => bool) public isFriend;\n    // isExecuted mapping maps data hash to execution status.\n    mapping (bytes32 => bool) public isExecuted;\n    // isConfirmed mapping maps data hash to friend's address to confirmation status.\n    mapping (bytes32 => mapping (address => bool)) public isConfirmed;\n\n    modifier onlyFriend() {\n        require(isFriend[msg.sender], \"Method can only be called by a friend\");\n        _;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _friends List of friends' addresses.\n    /// @param _threshold Required number of friends to confirm replacement.\n    function setup(address[] memory _friends, uint256 _threshold)\n        public\n    {\n        require(_threshold <= _friends.length, \"Threshold cannot exceed friends count\");\n        require(_threshold >= 2, \"At least 2 friends required\");\n        setManager();\n        // Set allowed friends.\n        for (uint256 i = 0; i < _friends.length; i++) {\n            address friend = _friends[i];\n            require(friend != address(0), \"Invalid friend address provided\");\n            require(!isFriend[friend], \"Duplicate friend address provided\");\n            isFriend[friend] = true;\n        }\n        friends = _friends;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows a friend to confirm a Safe transaction.\n    /// @param dataHash Safe transaction hash.\n    function confirmTransaction(bytes32 dataHash)\n        public\n        onlyFriend\n    {\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        isConfirmed[dataHash][msg.sender] = true;\n    }\n\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    /// @return Returns if transaction can be executed.\n    function recoverAccess(address prevOwner, address oldOwner, address newOwner)\n        public\n        onlyFriend\n    {\n        bytes memory data = abi.encodeWithSignature(\"swapOwner(address,address,address)\", prevOwner, oldOwner, newOwner);\n        bytes32 dataHash = getDataHash(data);\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        require(isConfirmedByRequiredFriends(dataHash), \"Recovery has not enough confirmations\");\n        isExecuted[dataHash] = true;\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \"Could not execute recovery\");\n    }\n\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\n    /// @param dataHash Data hash.\n    /// @return Confirmation status.\n    function isConfirmedByRequiredFriends(bytes32 dataHash)\n        public\n        view\n        returns (bool)\n    {\n        uint256 confirmationCount;\n        for (uint256 i = 0; i < friends.length; i++) {\n            if (isConfirmed[dataHash][friends[i]])\n                confirmationCount++;\n            if (confirmationCount == threshold)\n                return true;\n        }\n        return false;\n    }\n\n    /// @dev Returns hash of data encoding owner replacement.\n    /// @param data Data payload.\n    /// @return Data hash.\n    function getDataHash(bytes memory data)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(data);\n    }\n}\n",
      "inFile": "SocialRecoveryModule.sol",
      "references": [
        "Module"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "StateChannelModule",
      "baseContracts": [
        "Module",
        "SignatureDecoder"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "isExecuted",
          "solidityType": {
            "name": "(bytes32 => uint256)",
            "mapping": {
              "key": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "isExecuted",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setup",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function setup()\n        public\n    {\n        setManager();\n    }",
          "start": {
            "line": 20,
            "column": 4
          },
          "end": {
            "line": 24,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Setup function sets manager",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "execTransaction",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address of Safe transaction."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value of Safe transaction."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload of Safe transaction."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type of Safe transaction."
            },
            {
              "name": "nonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Nonce used for this Safe transaction."
            },
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce,\n        bytes memory signatures\n    )\n        public\n    {\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\n        require(isExecuted[transactionHash] == 0, \"Transaction already executed\");\n        checkHash(transactionHash, signatures);\n        // Mark as executed and execute transaction.\n        isExecuted[transactionHash] = 1;\n        require(manager.execTransactionFromModule(to, value, data, operation), \"Could not execute transaction\");\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 49,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
              "subAnnotation": {
                "name": "signatures",
                "value": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "nonce Nonce used for this Safe transaction.",
              "subAnnotation": {
                "name": "nonce",
                "value": "Nonce used for this Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "operation Operation type of Safe transaction.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload of Safe transaction.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value of Safe transaction.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address of Safe transaction.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address of Safe transaction.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to execute a Safe transaction confirmed by required number of owners.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "checkHash",
          "params": [
            {
              "name": "transactionHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            "view"
          ],
          "source": "function checkHash(bytes32 transactionHash, bytes memory signatures)\n        internal\n        view\n    {\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 i;\n        uint256 threshold = OwnerManager(address(manager)).getThreshold();\n        // Validate threshold is reached.\n        for (i = 0; i < threshold; i++) {\n            currentOwner = recoverKey(transactionHash, signatures, i);\n            require(OwnerManager(address(manager)).isOwner(currentOwner), \"Signature not provided by owner\");\n            require(currentOwner > lastOwner, \"Signatures are not ordered by owner address\");\n            lastOwner = currentOwner;\n        }\n    }",
          "start": {
            "line": 51,
            "column": 4
          },
          "end": {
            "line": 67,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "getTransactionHash",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Ether value."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data payload."
            },
            {
              "name": "operation",
              "solidityType": {
                "name": "Enum.Operation",
                "userDefined": true,
                "references": [
                  "Enum.Operation"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Operation type."
            },
            {
              "name": "nonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Transaction nonce."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\n    }",
          "start": {
            "line": 76,
            "column": 4
          },
          "end": {
            "line": 88,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Transaction hash.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "nonce Transaction nonce.",
              "subAnnotation": {
                "name": "nonce",
                "value": "Transaction nonce.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "operation Operation type.",
              "subAnnotation": {
                "name": "operation",
                "value": "Operation type.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "data Data payload.",
              "subAnnotation": {
                "name": "data",
                "value": "Data payload.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Ether value.",
              "subAnnotation": {
                "name": "value",
                "value": "Ether value.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Destination address.",
              "subAnnotation": {
                "name": "to",
                "value": "Destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns hash to be signed by owners.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Gnosis Safe State Module - A module that allows interaction with statechannels.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "manager",
          "solidityType": {
            "name": "ModuleManager",
            "userDefined": true,
            "references": [
              "ModuleManager"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "manager",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "ModuleManager",
                  "userDefined": true,
                  "references": [
                    "ModuleManager"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "setManager",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "recoverKey",
          "params": [
            {
              "name": "messageHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "operation ethereum signed message hash"
            },
            {
              "name": "messageSignature",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "message `txHash` signature"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
          "start": {
            "line": 13,
            "column": 4
          },
          "end": {
            "line": 27,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "pos which signature to read",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageSignature message `txHash` signature",
              "subAnnotation": {
                "name": "messageSignature",
                "value": "message `txHash` signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "messageHash operation ethereum signed message hash",
              "subAnnotation": {
                "name": "messageHash",
                "value": "operation ethereum signed message hash",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Recovers address who signed the message",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "signatureSplit",
          "params": [
            {
              "name": "signatures",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "concatenated rsv signatures"
            },
            {
              "name": "pos",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
            }
          ],
          "returnParams": [
            {
              "name": "v",
              "solidityType": {
                "name": "uint8",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "r",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "s",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 53,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "signatures concatenated rsv signatures",
              "subAnnotation": {
                "name": "signatures",
                "value": "concatenated rsv signatures",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
              "subAnnotation": {
                "name": "pos",
                "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\nimport \"../common/SignatureDecoder.sol\";\n\n\n/// @title Gnosis Safe State Module - A module that allows interaction with statechannels.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract StateChannelModule is Module, SignatureDecoder {\n\n    string public constant NAME = \"State Channel Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // isExecuted mapping allows to check if a transaction (by hash) was already executed.\n    mapping (bytes32 => uint256) public isExecuted;\n\n    /// @dev Setup function sets manager\n    function setup()\n        public\n    {\n        setManager();\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param nonce Nonce used for this Safe transaction.\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce,\n        bytes memory signatures\n    )\n        public\n    {\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\n        require(isExecuted[transactionHash] == 0, \"Transaction already executed\");\n        checkHash(transactionHash, signatures);\n        // Mark as executed and execute transaction.\n        isExecuted[transactionHash] = 1;\n        require(manager.execTransactionFromModule(to, value, data, operation), \"Could not execute transaction\");\n    }\n\n    function checkHash(bytes32 transactionHash, bytes memory signatures)\n        internal\n        view\n    {\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 i;\n        uint256 threshold = OwnerManager(address(manager)).getThreshold();\n        // Validate threshold is reached.\n        for (i = 0; i < threshold; i++) {\n            currentOwner = recoverKey(transactionHash, signatures, i);\n            require(OwnerManager(address(manager)).isOwner(currentOwner), \"Signature not provided by owner\");\n            require(currentOwner > lastOwner, \"Signatures are not ordered by owner address\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\n    }\n}\n",
      "inFile": "StateChannelModule.sol",
      "references": [
        "Module",
        "SignatureDecoder",
        "Enum.Operation"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "WhitelistModule",
      "baseContracts": [
        "Module"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "NAME",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "NAME",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "string",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "string",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "isWhitelisted",
          "solidityType": {
            "name": "(address => bool)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "isWhitelisted",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bool",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "setup",
          "params": [
            {
              "name": "accounts",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "List of whitelisted accounts."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function setup(address[] memory accounts)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Invalid account provided\");\n            isWhitelisted[account] = true;\n        }\n    }",
          "start": {
            "line": 20,
            "column": 4
          },
          "end": {
            "line": 29,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "accounts List of whitelisted accounts.",
              "subAnnotation": {
                "name": "accounts",
                "value": "List of whitelisted accounts.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Setup function sets initial storage of contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "addToWhitelist",
          "params": [
            {
              "name": "account",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function addToWhitelist(address account)\n        public\n        authorized\n    {\n        require(account != address(0), \"Invalid account provided\");\n        require(!isWhitelisted[account], \"Account is already whitelisted\");\n        isWhitelisted[account] = true;\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 40,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "account Destination address.",
              "subAnnotation": {
                "name": "account",
                "value": "Destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to add destination to whitelist. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "removeFromWhitelist",
          "params": [
            {
              "name": "account",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Destination address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function removeFromWhitelist(address account)\n        public\n        authorized\n    {\n        require(isWhitelisted[account], \"Account is not whitelisted\");\n        isWhitelisted[account] = false;\n    }",
          "start": {
            "line": 44,
            "column": 4
          },
          "end": {
            "line": 50,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "account Destination address.",
              "subAnnotation": {
                "name": "account",
                "value": "Destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to remove destination from whitelist. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "executeWhitelisted",
          "params": [
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Whitelisted destination address."
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Not checked."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Not checked."
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function executeWhitelisted(address to, uint256 value, bytes memory data)\n        public\n        returns (bool)\n    {\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(isWhitelisted[to], \"Target account is not whitelisted\");\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \"Could not execute transaction\");\n    }",
          "start": {
            "line": 57,
            "column": 4
          },
          "end": {
            "line": 65,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "Returns if transaction can be executed.",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "data Not checked.",
              "subAnnotation": {
                "name": "data",
                "value": "Not checked.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "value Not checked.",
              "subAnnotation": {
                "name": "value",
                "value": "Not checked.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "to Whitelisted destination address.",
              "subAnnotation": {
                "name": "to",
                "value": "Whitelisted destination address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Returns if Safe transaction is to a whitelisted destination.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Whitelist Module - Allows to execute transactions to whitelisted addresses without confirmations.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "manager",
          "solidityType": {
            "name": "ModuleManager",
            "userDefined": true,
            "references": [
              "ModuleManager"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "manager",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "ModuleManager",
                  "userDefined": true,
                  "references": [
                    "ModuleManager"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "private",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "setManager",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": []
        },
        {
          "name": "changeMasterCopy",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "New contract address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "authorized",
            "public",
            null
          ],
          "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
          "start": {
            "line": 18,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy New contract address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "New contract address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [
        {
          "name": "ChangedMasterCopy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "inheritedModifiers": [
        {
          "name": "authorized",
          "params": []
        }
      ],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Whitelist Module - Allows to execute transactions to whitelisted addresses without confirmations.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract WhitelistModule is Module {\n\n    string public constant NAME = \"Whitelist Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // isWhitelisted mapping maps destination address to boolean.\n    mapping (address => bool) public isWhitelisted;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param accounts List of whitelisted accounts.\n    function setup(address[] memory accounts)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Invalid account provided\");\n            isWhitelisted[account] = true;\n        }\n    }\n\n    /// @dev Allows to add destination to whitelist. This can only be done via a Safe transaction.\n    /// @param account Destination address.\n    function addToWhitelist(address account)\n        public\n        authorized\n    {\n        require(account != address(0), \"Invalid account provided\");\n        require(!isWhitelisted[account], \"Account is already whitelisted\");\n        isWhitelisted[account] = true;\n    }\n\n    /// @dev Allows to remove destination from whitelist. This can only be done via a Safe transaction.\n    /// @param account Destination address.\n    function removeFromWhitelist(address account)\n        public\n        authorized\n    {\n        require(isWhitelisted[account], \"Account is not whitelisted\");\n        isWhitelisted[account] = false;\n    }\n\n    /// @dev Returns if Safe transaction is to a whitelisted destination.\n    /// @param to Whitelisted destination address.\n    /// @param value Not checked.\n    /// @param data Not checked.\n    /// @return Returns if transaction can be executed.\n    function executeWhitelisted(address to, uint256 value, bytes memory data)\n        public\n        returns (bool)\n    {\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(isWhitelisted[to], \"Target account is not whitelisted\");\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \"Could not execute transaction\");\n    }\n}\n",
      "inFile": "WhitelistModule.sol",
      "references": [
        "Module"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "DelegateConstructorProxy",
      "baseContracts": [
        "Proxy"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "constructor",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Master copy address."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data used for a delegate call to initialize the contract."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "Proxy",
            "public",
            null
          ],
          "source": "constructor(address _masterCopy, bytes memory initializer) Proxy(_masterCopy)\n        public\n    {\n        if (initializer.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n                let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0)\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if eq(success, 0) { revert(ptr, returndatasize()) }\n            }\n        }\n    }",
          "start": {
            "line": 13,
            "column": 4
          },
          "end": {
            "line": 26,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "initializer Data used for a delegate call to initialize the contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Data used for a delegate call to initialize the contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_masterCopy Master copy address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "Master copy address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Constructor function sets address of master copy contract.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Delegate Constructor Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
          "start": {
            "line": 28,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Fallback function forwards all transactions and returns all received return data.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./Proxy.sol\";\n\n\n/// @title Delegate Constructor Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract DelegateConstructorProxy is Proxy {\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    /// @param initializer Data used for a delegate call to initialize the contract.\n    constructor(address _masterCopy, bytes memory initializer) Proxy(_masterCopy)\n        public\n    {\n        if (initializer.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n                let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0)\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if eq(success, 0) { revert(ptr, returndatasize()) }\n            }\n        }\n    }\n}\n",
      "inFile": "DelegateConstructorProxy.sol",
      "references": [
        "Proxy"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "IProxyCreationCallback",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "proxyCreated",
          "params": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "_mastercopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "saltNonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function proxyCreated(Proxy proxy, address _mastercopy, bytes calldata initializer, uint256 saltNonce) external;",
          "start": {
            "line": 5,
            "column": 4
          },
          "end": {
            "line": 5,
            "column": 115
          },
          "annotations": []
        }
      ],
      "annotations": [],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity ^0.5.3;\nimport \"./Proxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(Proxy proxy, address _mastercopy, bytes calldata initializer, uint256 saltNonce) external;\n}\n",
      "inFile": "IProxyCreationCallback.sol",
      "references": [
        "Proxy"
      ],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "PayingProxy",
      "baseContracts": [
        "DelegateConstructorProxy",
        "SecuredTokenTransfer"
      ],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "constructor",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Master copy address."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Data used for a delegate call to initialize the contract."
            },
            {
              "name": "funder",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address that should be paid for the execution of this call"
            },
            {
              "name": "paymentToken",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token that should be used for the payment (0 is ETH)"
            },
            {
              "name": "payment",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Value that should be paid"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "DelegateConstructorProxy",
            "public",
            null
          ],
          "source": "constructor(address _masterCopy, bytes memory initializer, address payable funder, address paymentToken, uint256 payment)\n        DelegateConstructorProxy(_masterCopy, initializer)\n        public\n    {\n        if (payment > 0) {\n            if (paymentToken == address(0)) {\n                 // solium-disable-next-line security/no-send\n                require(funder.send(payment), \"Could not pay safe creation with ether\");\n            } else {\n                require(transferToken(paymentToken, funder, payment), \"Could not pay safe creation with token\");\n            }\n        }\n    }",
          "start": {
            "line": 16,
            "column": 4
          },
          "end": {
            "line": 28,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "payment Value that should be paid",
              "subAnnotation": {
                "name": "payment",
                "value": "Value that should be paid",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "paymentToken Token that should be used for the payment (0 is ETH)",
              "subAnnotation": {
                "name": "paymentToken",
                "value": "Token that should be used for the payment (0 is ETH)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "funder Address that should be paid for the execution of this call",
              "subAnnotation": {
                "name": "funder",
                "value": "Address that should be paid for the execution of this call",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "initializer Data used for a delegate call to initialize the contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Data used for a delegate call to initialize the contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_masterCopy Master copy address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "Master copy address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Constructor function sets address of master copy contract.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Paying Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor. And sends funds after creation to a specified account.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": false,
      "inheritedStateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "inheritedFunctions": [
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
          "start": {
            "line": 28,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Fallback function forwards all transactions and returns all received return data.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transferToken",
          "params": [
            {
              "name": "token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Token that should be transferred"
            },
            {
              "name": "receiver",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Receiver to whom the token should be transferred"
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "The amount of tokens that should be transferred"
            }
          ],
          "returnParams": [
            {
              "name": "transferred",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
          "start": {
            "line": 12,
            "column": 4
          },
          "end": {
            "line": 32,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "amount The amount of tokens that should be transferred",
              "subAnnotation": {
                "name": "amount",
                "value": "The amount of tokens that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "receiver Receiver to whom the token should be transferred",
              "subAnnotation": {
                "name": "receiver",
                "value": "Receiver to whom the token should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "token Token that should be transferred",
              "subAnnotation": {
                "name": "token",
                "value": "Token that should be transferred",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Transfers a token and returns if it was a success",
              "subAnnotation": null
            }
          ]
        }
      ],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/SecuredTokenTransfer.sol\";\nimport \"./DelegateConstructorProxy.sol\";\n\n/// @title Paying Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor. And sends funds after creation to a specified account.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract PayingProxy is DelegateConstructorProxy, SecuredTokenTransfer {\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    /// @param initializer Data used for a delegate call to initialize the contract.\n    /// @param funder Address that should be paid for the execution of this call\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    constructor(address _masterCopy, bytes memory initializer, address payable funder, address paymentToken, uint256 payment)\n        DelegateConstructorProxy(_masterCopy, initializer)\n        public\n    {\n        if (payment > 0) {\n            if (paymentToken == address(0)) {\n                 // solium-disable-next-line security/no-send\n                require(funder.send(payment), \"Could not pay safe creation with ether\");\n            } else {\n                require(transferToken(paymentToken, funder, payment), \"Could not pay safe creation with token\");\n            }\n        }\n    }\n}\n",
      "inFile": "PayingProxy.sol",
      "references": [
        "DelegateConstructorProxy",
        "SecuredTokenTransfer"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "IProxy",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "masterCopy",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function masterCopy() external view returns (address);",
          "start": {
            "line": 6,
            "column": 4
          },
          "end": {
            "line": 6,
            "column": 57
          },
          "annotations": []
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "IProxy - Helper interface to access masterCopy of the Proxy on-chain",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Proxy {\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal masterCopy;\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n",
      "inFile": "Proxy.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "Proxy",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "masterCopy",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "masterCopy",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [
            {
              "name": "_masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Master copy address."
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }",
          "start": {
            "line": 20,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_masterCopy Master copy address.",
              "subAnnotation": {
                "name": "_masterCopy",
                "value": "Master copy address.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Constructor function sets address of master copy contract.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "external",
            "payable"
          ],
          "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
          "start": {
            "line": 28,
            "column": 4
          },
          "end": {
            "line": 46,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Fallback function forwards all transactions and returns all received return data.",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Richard Meissner - <richard@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.io>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.",
          "subAnnotation": null
        }
      ],
      "deployedAt": null,
      "meta": null,
      "modifiers": [],
      "events": [],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Proxy {\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal masterCopy;\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n",
      "inFile": "Proxy.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "ProxyFactory",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "createProxy",
          "params": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of master copy."
            },
            {
              "name": "data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Payload for message call sent to new proxy contract."
            }
          ],
          "returnParams": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }",
          "start": {
            "line": 14,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "data Payload for message call sent to new proxy contract.",
              "subAnnotation": {
                "name": "data",
                "value": "Payload for message call sent to new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "masterCopy Address of master copy.",
              "subAnnotation": {
                "name": "masterCopy",
                "value": "Address of master copy.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "proxyRuntimeCode",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "pure"
          ],
          "source": "function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(Proxy).runtimeCode;\n    }",
          "start": {
            "line": 28,
            "column": 4
          },
          "end": {
            "line": 30,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "proxyCreationCode",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "pure"
          ],
          "source": "function proxyCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }",
          "start": {
            "line": 33,
            "column": 4
          },
          "end": {
            "line": 35,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "deployProxyWithNonce",
          "params": [
            {
              "name": "_mastercopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of master copy."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Payload for message call sent to new proxy contract."
            },
            {
              "name": "saltNonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
            }
          ],
          "returnParams": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function deployProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        internal\n        returns (Proxy proxy)\n    {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }",
          "start": {
            "line": 42,
            "column": 4
          },
          "end": {
            "line": 54,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
              "subAnnotation": {
                "name": "saltNonce",
                "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "initializer Payload for message call sent to new proxy contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Payload for message call sent to new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_mastercopy Address of master copy.",
              "subAnnotation": {
                "name": "_mastercopy",
                "value": "Address of master copy.",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "createProxyWithNonce",
          "params": [
            {
              "name": "_mastercopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of master copy."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Payload for message call sent to new proxy contract."
            },
            {
              "name": "saltNonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
            }
          ],
          "returnParams": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\n            }\n        emit ProxyCreation(proxy);\n    }",
          "start": {
            "line": 60,
            "column": 4
          },
          "end": {
            "line": 71,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
              "subAnnotation": {
                "name": "saltNonce",
                "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "initializer Payload for message call sent to new proxy contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Payload for message call sent to new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_mastercopy Address of master copy.",
              "subAnnotation": {
                "name": "_mastercopy",
                "value": "Address of master copy.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "createProxyWithCallback",
          "params": [
            {
              "name": "_mastercopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of master copy."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Payload for message call sent to new proxy contract."
            },
            {
              "name": "saltNonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
            },
            {
              "name": "callback",
              "solidityType": {
                "name": "IProxyCreationCallback",
                "userDefined": true,
                "references": [
                  "IProxyCreationCallback"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Callback that will be invoced after the new proxy contract has been successfully deployed and initialized."
            }
          ],
          "returnParams": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "function createProxyWithCallback(address _mastercopy, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback)\n        public\n        returns (Proxy proxy)\n    {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_mastercopy, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0))\n            callback.proxyCreated(proxy, _mastercopy, initializer, saltNonce);\n    }",
          "start": {
            "line": 78,
            "column": 4
          },
          "end": {
            "line": 86,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.",
              "subAnnotation": {
                "name": "callback",
                "value": "Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
              "subAnnotation": {
                "name": "saltNonce",
                "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "initializer Payload for message call sent to new proxy contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Payload for message call sent to new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_mastercopy Address of master copy.",
              "subAnnotation": {
                "name": "_mastercopy",
                "value": "Address of master copy.",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "calculateCreateProxyWithNonceAddress",
          "params": [
            {
              "name": "_mastercopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Address of master copy."
            },
            {
              "name": "initializer",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "Payload for message call sent to new proxy contract."
            },
            {
              "name": "saltNonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
            }
          ],
          "returnParams": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function calculateCreateProxyWithNonceAddress(address _mastercopy, bytes calldata initializer, uint256 saltNonce)\n        external\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }",
          "start": {
            "line": 94,
            "column": 4
          },
          "end": {
            "line": 100,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
              "subAnnotation": {
                "name": "saltNonce",
                "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "initializer Payload for message call sent to new proxy contract.",
              "subAnnotation": {
                "name": "initializer",
                "value": "Payload for message call sent to new proxy contract.",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_mastercopy Address of master copy.",
              "subAnnotation": {
                "name": "_mastercopy",
                "value": "Address of master copy.",
                "subAnnotation": null
              }
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "author",
          "value": "Stefan George - <stefan@gnosis.pm>",
          "subAnnotation": null
        },
        {
          "name": "title",
          "value": "Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "ProxyCreation",
          "params": [
            {
              "name": "proxy",
              "solidityType": {
                "name": "Proxy",
                "userDefined": true,
                "references": [
                  "Proxy"
                ],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity ^0.5.3;\nimport \"./Proxy.sol\";\nimport \"./IProxyCreationCallback.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract ProxyFactory {\n\n    event ProxyCreation(Proxy proxy);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(Proxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        internal\n        returns (Proxy proxy)\n    {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(address _mastercopy, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback)\n        public\n        returns (Proxy proxy)\n    {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_mastercopy, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0))\n            callback.proxyCreated(proxy, _mastercopy, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(address _mastercopy, bytes calldata initializer, uint256 saltNonce)\n        external\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n\n}\n",
      "inFile": "ProxyFactory.sol",
      "references": [
        "Proxy",
        "IProxyCreationCallback"
      ],
      "isAbstract": false
    }
  ],
  "graph": {
    "graph": {
      "cells": [
        {
          "type": "link",
          "source": {
            "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8"
          },
          "target": {
            "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "ae9b3ce7-a282-40c4-8331-2378318c63d3",
          "z": -26,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "3ac76a25-5f35-487a-af20-75377038bc17"
          },
          "target": {
            "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "bc6bd04c-7e35-4a80-9c6f-f3af1d1732eb",
          "z": -25,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
          },
          "target": {
            "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "fe7c746a-a0ab-4efd-8f5d-621c22f11775",
          "z": -24,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
          },
          "target": {
            "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "861cba65-af9a-4f07-bec6-d833225df9d2",
          "z": -23,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
          },
          "target": {
            "id": "b080fa79-a897-4295-b81a-77dd3912cb39"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "fd18e748-8916-4f84-9bed-26a9c5a710b6",
          "z": -22,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "d107d7b8-6f11-462c-81e7-0af23fd91990"
          },
          "target": {
            "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "eafcf5d6-c602-4da7-be9e-41b0a2045342",
          "z": -21,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "45924732-643e-4d8f-b171-5a9bd610a158"
          },
          "target": {
            "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "9c321eca-d2d7-4a1d-aa11-4dd482e423d8",
          "z": -20,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "45924732-643e-4d8f-b171-5a9bd610a158"
          },
          "target": {
            "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "6ba5cc5c-4e42-408c-ba00-b9ecb2d347cd",
          "z": -19,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2"
          },
          "target": {
            "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "7b73ebee-0f22-4d89-9496-6cba1bf2180c",
          "z": -18,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
          },
          "target": {
            "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "07c09197-8e67-4613-a775-3e18482fcf8c",
          "z": -17,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "b11b442a-f51b-4262-809a-56bf96e8af47"
          },
          "target": {
            "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "15c7bb9d-a676-4d04-95cd-10a910c8a306",
          "z": -16,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
          },
          "target": {
            "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "0a099b89-c1ff-441d-8afd-5ed1061f8ea6",
          "z": -12,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "117f1591-71d5-4028-93b5-48758ae58048"
          },
          "target": {
            "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "222136af-c638-40ca-ab6a-35cbb3d8ef8c",
          "z": -11,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
          },
          "target": {
            "id": "709d61c1-c259-426e-a1d7-c12f8db82199"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "afdd6e5f-6302-453d-8ae5-79cb4d1cffd4",
          "z": -10,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
          },
          "target": {
            "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "a02e7e62-2b4d-435c-bbd9-df61c03b07b2",
          "z": -9,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
          },
          "target": {
            "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "00c06bd1-4ad9-4165-81ba-b7c45b89bafe",
          "z": -8,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
          },
          "target": {
            "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "066d9447-a510-40cf-88f4-fa856c3dc85e",
          "z": -7,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 560
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c",
          "z": 1,
          "attrs": {
            "text": {
              "text": "GnosisSafe",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node node-highlighted",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "626f4dfd-6815-4fb5-b617-9d05df8d2c5a",
          "z": 2,
          "attrs": {
            "text": {
              "text": "Migrations",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 685
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "709d61c1-c259-426e-a1d7-c12f8db82199",
          "z": 3,
          "attrs": {
            "text": {
              "text": "Executor",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 460
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb",
          "z": 4,
          "attrs": {
            "text": {
              "text": "FallbackManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 755
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3",
          "z": 5,
          "attrs": {
            "text": {
              "text": "Module",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 600
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "19fff30f-5550-4cf1-9560-58b803b54d80",
          "z": 6,
          "attrs": {
            "text": {
              "text": "ModuleManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 530
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "117f1591-71d5-4028-93b5-48758ae58048",
          "z": 7,
          "attrs": {
            "text": {
              "text": "OwnerManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 70
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113",
          "z": 8,
          "attrs": {
            "text": {
              "text": "Enum",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 70
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "3ac76a25-5f35-487a-af20-75377038bc17",
          "z": 9,
          "attrs": {
            "text": {
              "text": "Operation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/list-ol.svg"
            },
            "rect": {
              "class": "enum-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 140
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "78c8cdfd-6948-490a-b510-3a30ea488e76",
          "z": 10,
          "attrs": {
            "text": {
              "text": "EtherPaymentFal...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 685
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "93d7c70a-d422-479a-883b-4d1fed7536ca",
          "z": 11,
          "attrs": {
            "text": {
              "text": "MasterCopy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 820
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1",
          "z": 12,
          "attrs": {
            "text": {
              "text": "SecuredTokenTra...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 580
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a",
          "z": 13,
          "attrs": {
            "text": {
              "text": "SelfAuthorized",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 890
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3",
          "z": 14,
          "attrs": {
            "text": {
              "text": "SignatureDecoder",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 210
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "805cfa54-7420-4c69-bcef-65dbde7d123b",
          "z": 15,
          "attrs": {
            "text": {
              "text": "SafeMath",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/book-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 280
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d",
          "z": 16,
          "attrs": {
            "text": {
              "text": "DefaultCallback...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 175
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff",
          "z": 17,
          "attrs": {
            "text": {
              "text": "ERC1155TokenRec...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 245
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "1d905bf3-a613-40a2-87fb-db7451d05e45",
          "z": 18,
          "attrs": {
            "text": {
              "text": "ERC721TokenRece...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 455
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "abd7d93a-3017-4c52-8b24-15cb54254408",
          "z": 19,
          "attrs": {
            "text": {
              "text": "ERC777TokensRec...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 985
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "8ef96d38-e4b4-43b9-a523-d2276464c027",
          "z": 20,
          "attrs": {
            "text": {
              "text": "ISignatureValid...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 1065
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "b11b442a-f51b-4262-809a-56bf96e8af47",
          "z": 21,
          "attrs": {
            "text": {
              "text": "ISignatureValid...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 350
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "44fb2d7f-5a55-4177-b15b-d1b9b127d5e5",
          "z": 22,
          "attrs": {
            "text": {
              "text": "CreateAndAddMod...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 420
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2077831d-a074-4376-9a14-b78d7efa917f",
          "z": 23,
          "attrs": {
            "text": {
              "text": "CreateCall",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 490
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "82d34f9d-c1d8-478d-8c10-098e0c84b193",
          "z": 24,
          "attrs": {
            "text": {
              "text": "MultiSend",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 560
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "9cc498e3-3783-43eb-b942-d1a8ffd77593",
          "z": 25,
          "attrs": {
            "text": {
              "text": "ERC1155Token",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 630
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e760fddd-da71-4698-ae1c-25b756fcde84",
          "z": 26,
          "attrs": {
            "text": {
              "text": "Token",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 700
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8",
          "z": 27,
          "attrs": {
            "text": {
              "text": "DailyLimitModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 700
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8",
          "z": 28,
          "attrs": {
            "text": {
              "text": "DailyLimit",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 770
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2",
          "z": 29,
          "attrs": {
            "text": {
              "text": "SocialRecoveryM...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 840
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "45924732-643e-4d8f-b171-5a9bd610a158",
          "z": 30,
          "attrs": {
            "text": {
              "text": "StateChannelModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 910
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "d107d7b8-6f11-462c-81e7-0af23fd91990",
          "z": 31,
          "attrs": {
            "text": {
              "text": "WhitelistModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 1055
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e4aee160-ed8b-46d5-a867-51fb2046842f",
          "z": 32,
          "attrs": {
            "text": {
              "text": "DelegateConstru...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 770
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "d369ab14-2179-48e1-9fa2-1b553078108f",
          "z": 33,
          "attrs": {
            "text": {
              "text": "IProxyCreationC...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 995
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c85b0602-8bc2-469c-b28f-a6f82a184253",
          "z": 34,
          "attrs": {
            "text": {
              "text": "PayingProxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 840
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c08a9573-24c0-4444-9d51-f5404f8ffe54",
          "z": 35,
          "attrs": {
            "text": {
              "text": "IProxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 1055
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "b080fa79-a897-4295-b81a-77dd3912cb39",
          "z": 36,
          "attrs": {
            "text": {
              "text": "Proxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 910
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "75e839a8-b9c1-4f39-9c0b-66290fac8e5c",
          "z": 37,
          "attrs": {
            "text": {
              "text": "ProxyFactory",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
          },
          "target": {
            "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "76fb5e5f-8b69-4291-80a9-55341f985367",
          "z": 73,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
          },
          "target": {
            "id": "abd7d93a-3017-4c52-8b24-15cb54254408"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "06975f5b-4a31-49c1-a469-5314a86f036f",
          "z": 74,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
          },
          "target": {
            "id": "1d905bf3-a613-40a2-87fb-db7451d05e45"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "84e951c2-f179-479b-b0fe-73f25306a8c1",
          "z": 75,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "fbc3b877-252f-43cb-a0e7-8bd940dcb6c6",
          "z": 76,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "79c9bae3-fe36-4a0a-b3b4-63a2588840e2",
          "z": 77,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "117f1591-71d5-4028-93b5-48758ae58048"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "79232782-97e4-43cb-84ae-44e7c91ce66b",
          "z": 78,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "bfe87647-739c-4ec9-b5b0-bdbb4dfdbeca",
          "z": 79,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "467920bb-9e51-497a-9e83-89cef8c088d5",
          "z": 80,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "4c09f3db-ef1f-433a-b1be-d284636229e8",
          "z": 81,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
          },
          "target": {
            "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
          },
          "router": {
            "name": "manhattan"
          },
          "connector": {
            "name": "normal"
          },
          "id": "1acc689e-72a8-431e-acc2-cfa8aa249afc",
          "z": 82,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        }
      ]
    },
    "inheritanceLinks": [
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "fbc3b877-252f-43cb-a0e7-8bd940dcb6c6",
        "z": 76,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "79c9bae3-fe36-4a0a-b3b4-63a2588840e2",
        "z": 77,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "117f1591-71d5-4028-93b5-48758ae58048"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "79232782-97e4-43cb-84ae-44e7c91ce66b",
        "z": 78,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "bfe87647-739c-4ec9-b5b0-bdbb4dfdbeca",
        "z": 79,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "467920bb-9e51-497a-9e83-89cef8c088d5",
        "z": 80,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "4c09f3db-ef1f-433a-b1be-d284636229e8",
        "z": 81,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
        },
        "target": {
          "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "1acc689e-72a8-431e-acc2-cfa8aa249afc",
        "z": 82,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
        },
        "target": {
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "066d9447-a510-40cf-88f4-fa856c3dc85e",
        "z": -7,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
        },
        "target": {
          "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "00c06bd1-4ad9-4165-81ba-b7c45b89bafe",
        "z": -8,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
        },
        "target": {
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "a02e7e62-2b4d-435c-bbd9-df61c03b07b2",
        "z": -9,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
        },
        "target": {
          "id": "709d61c1-c259-426e-a1d7-c12f8db82199"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "afdd6e5f-6302-453d-8ae5-79cb4d1cffd4",
        "z": -10,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "117f1591-71d5-4028-93b5-48758ae58048"
        },
        "target": {
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "222136af-c638-40ca-ab6a-35cbb3d8ef8c",
        "z": -11,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
        },
        "target": {
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "0a099b89-c1ff-441d-8afd-5ed1061f8ea6",
        "z": -12,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
        },
        "target": {
          "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "76fb5e5f-8b69-4291-80a9-55341f985367",
        "z": 73,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
        },
        "target": {
          "id": "abd7d93a-3017-4c52-8b24-15cb54254408"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "06975f5b-4a31-49c1-a469-5314a86f036f",
        "z": 74,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
        },
        "target": {
          "id": "1d905bf3-a613-40a2-87fb-db7451d05e45"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "84e951c2-f179-479b-b0fe-73f25306a8c1",
        "z": 75,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "b11b442a-f51b-4262-809a-56bf96e8af47"
        },
        "target": {
          "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "15c7bb9d-a676-4d04-95cd-10a910c8a306",
        "z": -16,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
        },
        "target": {
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "07c09197-8e67-4613-a775-3e18482fcf8c",
        "z": -17,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2"
        },
        "target": {
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "7b73ebee-0f22-4d89-9496-6cba1bf2180c",
        "z": -18,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "45924732-643e-4d8f-b171-5a9bd610a158"
        },
        "target": {
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "6ba5cc5c-4e42-408c-ba00-b9ecb2d347cd",
        "z": -19,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "45924732-643e-4d8f-b171-5a9bd610a158"
        },
        "target": {
          "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "9c321eca-d2d7-4a1d-aa11-4dd482e423d8",
        "z": -20,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "d107d7b8-6f11-462c-81e7-0af23fd91990"
        },
        "target": {
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "eafcf5d6-c602-4da7-be9e-41b0a2045342",
        "z": -21,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
        },
        "target": {
          "id": "b080fa79-a897-4295-b81a-77dd3912cb39"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "fd18e748-8916-4f84-9bed-26a9c5a710b6",
        "z": -22,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
        },
        "target": {
          "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "861cba65-af9a-4f07-bec6-d833225df9d2",
        "z": -23,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
        },
        "target": {
          "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
        },
        "router": {
          "name": "manhattan"
        },
        "connector": {
          "name": "normal"
        },
        "id": "fe7c746a-a0ab-4efd-8f5d-621c22f11775",
        "z": -24,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      }
    ],
    "otherLinks": [
      {
        "type": "link",
        "source": {
          "id": "3ac76a25-5f35-487a-af20-75377038bc17"
        },
        "target": {
          "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "bc6bd04c-7e35-4a80-9c6f-f3af1d1732eb",
        "z": -25,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8"
        },
        "target": {
          "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "ae9b3ce7-a282-40c4-8331-2378318c63d3",
        "z": -26,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      }
    ],
    "nodeIdNamePairs": [
      {
        "nodeElement": {
          "elementType": 0,
          "name": "GnosisSafe",
          "baseContracts": [
            "MasterCopy",
            "ModuleManager",
            "OwnerManager",
            "SignatureDecoder",
            "SecuredTokenTransfer",
            "ISignatureValidatorConstants",
            "FallbackManager"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "DOMAIN_SEPARATOR_TYPEHASH",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "DOMAIN_SEPARATOR_TYPEHASH",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "SAFE_TX_TYPEHASH",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SAFE_TX_TYPEHASH",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "SAFE_MSG_TYPEHASH",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SAFE_MSG_TYPEHASH",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "nonce",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "nonce",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "domainSeparator",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "domainSeparator",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "signedMessages",
              "solidityType": {
                "name": "(bytes32 => uint256)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "signedMessages",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "approvedHashes",
              "solidityType": {
                "name": "(address => (bytes32 => uint256))",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "(bytes32 => uint256)",
                    "mapping": {
                      "key": {
                        "name": "bytes32",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      },
                      "value": {
                        "name": "uint256",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      }
                    },
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "approvedHashes",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "(bytes32 => uint256)",
                      "mapping": {
                        "key": {
                          "name": "bytes32",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        },
                        "value": {
                          "name": "uint256",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        }
                      },
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }",
              "start": {
                "line": 60,
                "column": 4
              },
              "end": {
                "line": 65,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "setup",
              "params": [
                {
                  "name": "_owners",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of Safe owners."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Number of required confirmations for a Safe transaction."
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Contract address for optional delegate call."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload for optional delegate call."
                },
                {
                  "name": "fallbackHandler",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Handler for fallback calls to this contract"
                },
                {
                  "name": "paymentToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token that should be used for the payment (0 is ETH)"
                },
                {
                  "name": "payment",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Value that should be paid"
                },
                {
                  "name": "paymentReceiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Adddress that should receive the payment (or 0 if tx.origin)"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }",
              "start": {
                "line": 76,
                "column": 4
              },
              "end": {
                "line": 100,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)",
                  "subAnnotation": {
                    "name": "paymentReceiver",
                    "value": "Adddress that should receive the payment (or 0 if tx.origin)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "payment Value that should be paid",
                  "subAnnotation": {
                    "name": "payment",
                    "value": "Value that should be paid",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "paymentToken Token that should be used for the payment (0 is ETH)",
                  "subAnnotation": {
                    "name": "paymentToken",
                    "value": "Token that should be used for the payment (0 is ETH)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "fallbackHandler Handler for fallback calls to this contract",
                  "subAnnotation": {
                    "name": "fallbackHandler",
                    "value": "Handler for fallback calls to this contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload for optional delegate call.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload for optional delegate call.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Contract address for optional delegate call.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Contract address for optional delegate call.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_threshold Number of required confirmations for a Safe transaction.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "Number of required confirmations for a Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_owners List of Safe owners.",
                  "subAnnotation": {
                    "name": "_owners",
                    "value": "List of Safe owners.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "execTransaction",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of Safe transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of Safe transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of Safe transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of Safe transaction."
                },
                {
                  "name": "safeTxGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Gas that should be used for the Safe transaction."
                },
                {
                  "name": "baseGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)"
                },
                {
                  "name": "gasPrice",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Gas price that should be used for the payment calculation."
                },
                {
                  "name": "gasToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token address (or 0 if ETH) that is used for the payment."
                },
                {
                  "name": "refundReceiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of receiver of gas payment (or 0 if tx.origin)."
                },
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})"
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }",
              "start": {
                "line": 114,
                "column": 4
              },
              "end": {
                "line": 157,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
                  "subAnnotation": {
                    "name": "refundReceiver",
                    "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
                  "subAnnotation": {
                    "name": "gasToken",
                    "value": "Token address (or 0 if ETH) that is used for the payment.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasPrice Gas price that should be used for the payment calculation.",
                  "subAnnotation": {
                    "name": "gasPrice",
                    "value": "Gas price that should be used for the payment calculation.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
                  "subAnnotation": {
                    "name": "baseGas",
                    "value": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "safeTxGas Gas that should be used for the Safe transaction.",
                  "subAnnotation": {
                    "name": "safeTxGas",
                    "value": "Gas that should be used for the Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "operation Operation type of Safe transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of Safe transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of Safe transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of Safe transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of Safe transaction.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "handlePayment",
              "params": [
                {
                  "name": "gasUsed",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "baseGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "gasPrice",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "gasToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "refundReceiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "payment",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "private",
                null
              ],
              "source": "function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }",
              "start": {
                "line": 159,
                "column": 4
              },
              "end": {
                "line": 180,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "checkSignatures",
              "params": [
                {
                  "name": "dataHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Hash of the data (could be either a message hash or transaction hash)"
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "That should be signed (this is passed to an external validator contract)"
                },
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash."
                },
                {
                  "name": "consumeHash",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Indicates that in case of an approved hash the storage can be freed to save gas"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }",
              "start": {
                "line": 189,
                "column": 4
              },
              "end": {
                "line": 259,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "consumeHash Indicates that in case of an approved hash the storage can be freed to save gas",
                  "subAnnotation": {
                    "name": "consumeHash",
                    "value": "Indicates that in case of an approved hash the storage can be freed to save gas",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data That should be signed (this is passed to an external validator contract)",
                  "subAnnotation": {
                    "name": "data",
                    "value": "That should be signed (this is passed to an external validator contract)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "dataHash Hash of the data (could be either a message hash or transaction hash)",
                  "subAnnotation": {
                    "name": "dataHash",
                    "value": "Hash of the data (could be either a message hash or transaction hash)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "requiredTxGas",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of Safe transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of Safe transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of Safe transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of Safe transaction."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "authorized",
                "external",
                null
              ],
              "source": "function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }",
              "start": {
                "line": 272,
                "column": 4
              },
              "end": {
                "line": 284,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Estimate without refunds and overhead fees (base transaction and payload data gas costs).",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "operation Operation type of Safe transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of Safe transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of Safe transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of Safe transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of Safe transaction.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "approveHash",
              "params": [
                {
                  "name": "hashToApprove",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "The hash that should be marked as approved for signatures that are verified by this contract."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }",
              "start": {
                "line": 290,
                "column": 4
              },
              "end": {
                "line": 296,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.",
                  "subAnnotation": {
                    "name": "hashToApprove",
                    "value": "The hash that should be marked as approved for signatures that are verified by this contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Marks a hash as approved. This can be used to validate a hash that is used by a signature.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "signMessage",
              "params": [
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Arbitrary length data that should be marked as signed on the behalf of address(this)"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "external",
                null
              ],
              "source": "function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }",
              "start": {
                "line": 302,
                "column": 4
              },
              "end": {
                "line": 309,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_data Arbitrary length data that should be marked as signed on the behalf of address(this)",
                  "subAnnotation": {
                    "name": "_data",
                    "value": "Arbitrary length data that should be marked as signed on the behalf of address(this)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Marks a message as signed",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "isValidSignature",
              "params": [
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Arbitrary length data signed on the behalf of address(this)"
                },
                {
                  "name": "_signature",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Signature byte array associated with _data"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }",
              "start": {
                "line": 320,
                "column": 4
              },
              "end": {
                "line": 332,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "return",
                  "value": "a bool upon valid or invalid signature with corresponding _data",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signature Signature byte array associated with _data",
                  "subAnnotation": {
                    "name": "_signature",
                    "value": "Signature byte array associated with _data",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_data Arbitrary length data signed on the behalf of address(this)",
                  "subAnnotation": {
                    "name": "_data",
                    "value": "Arbitrary length data signed on the behalf of address(this)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "*",
                  "value": "      The method will not perform any state changes (see parameters of `checkSignatures`)",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "      The save does not implement the interface since `checkSignatures` is not a view method.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Should return whether the signature provided is valid for the provided data.",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getMessageHash",
              "params": [
                {
                  "name": "message",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Message that should be hashed"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }",
              "start": {
                "line": 337,
                "column": 4
              },
              "end": {
                "line": 350,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Message hash.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "message Message that should be hashed",
                  "subAnnotation": {
                    "name": "message",
                    "value": "Message that should be hashed",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns hash of a message that can be signed by owners.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "encodeTransactionData",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type."
                },
                {
                  "name": "safeTxGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Fas that should be used for the safe transaction."
                },
                {
                  "name": "baseGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Gas costs for data used to trigger the safe transaction."
                },
                {
                  "name": "gasPrice",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Maximum gas price that should be used for this transaction."
                },
                {
                  "name": "gasToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token address (or 0 if ETH) that is used for the payment."
                },
                {
                  "name": "refundReceiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of receiver of gas payment (or 0 if tx.origin)."
                },
                {
                  "name": "_nonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Transaction nonce."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }",
              "start": {
                "line": 364,
                "column": 4
              },
              "end": {
                "line": 384,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Transaction hash bytes.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_nonce Transaction nonce.",
                  "subAnnotation": {
                    "name": "_nonce",
                    "value": "Transaction nonce.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
                  "subAnnotation": {
                    "name": "refundReceiver",
                    "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
                  "subAnnotation": {
                    "name": "gasToken",
                    "value": "Token address (or 0 if ETH) that is used for the payment.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasPrice Maximum gas price that should be used for this transaction.",
                  "subAnnotation": {
                    "name": "gasPrice",
                    "value": "Maximum gas price that should be used for this transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "baseGas Gas costs for data used to trigger the safe transaction.",
                  "subAnnotation": {
                    "name": "baseGas",
                    "value": "Gas costs for data used to trigger the safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "safeTxGas Fas that should be used for the safe transaction.",
                  "subAnnotation": {
                    "name": "safeTxGas",
                    "value": "Fas that should be used for the safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "operation Operation type.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns the bytes that are hashed to be signed by owners.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getTransactionHash",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type."
                },
                {
                  "name": "safeTxGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Fas that should be used for the safe transaction."
                },
                {
                  "name": "baseGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Gas costs for data used to trigger the safe transaction."
                },
                {
                  "name": "gasPrice",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Maximum gas price that should be used for this transaction."
                },
                {
                  "name": "gasToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token address (or 0 if ETH) that is used for the payment."
                },
                {
                  "name": "refundReceiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of receiver of gas payment (or 0 if tx.origin)."
                },
                {
                  "name": "_nonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Transaction nonce."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }",
              "start": {
                "line": 398,
                "column": 4
              },
              "end": {
                "line": 415,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Transaction hash.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_nonce Transaction nonce.",
                  "subAnnotation": {
                    "name": "_nonce",
                    "value": "Transaction nonce.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
                  "subAnnotation": {
                    "name": "refundReceiver",
                    "value": "Address of receiver of gas payment (or 0 if tx.origin).",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
                  "subAnnotation": {
                    "name": "gasToken",
                    "value": "Token address (or 0 if ETH) that is used for the payment.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "gasPrice Maximum gas price that should be used for this transaction.",
                  "subAnnotation": {
                    "name": "gasPrice",
                    "value": "Maximum gas price that should be used for this transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "baseGas Gas costs for data used to trigger the safe transaction.",
                  "subAnnotation": {
                    "name": "baseGas",
                    "value": "Gas costs for data used to trigger the safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "safeTxGas Fas that should be used for the safe transaction.",
                  "subAnnotation": {
                    "name": "safeTxGas",
                    "value": "Fas that should be used for the safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "operation Operation type.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns hash to be signed by owners.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "ApproveHash",
              "params": [
                {
                  "name": "approvedHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            },
            {
              "name": "SignMsg",
              "params": [
                {
                  "name": "msgHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionFailure",
              "params": [
                {
                  "name": "txHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "payment",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionSuccess",
              "params": [
                {
                  "name": "txHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "payment",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "SENTINEL_MODULES",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SENTINEL_MODULES",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "modules",
              "solidityType": {
                "name": "(address => address)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "modules",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "SENTINEL_OWNERS",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SENTINEL_OWNERS",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "owners",
              "solidityType": {
                "name": "(address => address)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "owners",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "ownerCount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "default",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "ownerCount",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "threshold",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "EIP1271_MAGIC_VALUE",
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "EIP1271_MAGIC_VALUE",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes4",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "FALLBACK_HANDLER_STORAGE_SLOT",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "FALLBACK_HANDLER_STORAGE_SLOT",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "setupModules",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }",
              "start": {
                "line": 22,
                "column": 4
              },
              "end": {
                "line": 30,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "enableModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module to be whitelisted."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }",
              "start": {
                "line": 35,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "module Module to be whitelisted.",
                  "subAnnotation": {
                    "name": "module",
                    "value": "Module to be whitelisted.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "disableModule",
              "params": [
                {
                  "name": "prevModule",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module that pointed to the module to be removed in the linked list"
                },
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module to be removed."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }",
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 62,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "module Module to be removed.",
                  "subAnnotation": {
                    "name": "module",
                    "value": "Module to be removed.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevModule Module that pointed to the module to be removed in the linked list",
                  "subAnnotation": {
                    "name": "prevModule",
                    "value": "Module that pointed to the module to be removed in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "execTransactionFromModule",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of module transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of module transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of module transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of module transaction."
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }",
              "start": {
                "line": 69,
                "column": 4
              },
              "end": {
                "line": 79,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "operation Operation type of module transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of module transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of module transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of module transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows a Module to execute a Safe transaction without any further confirmations.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "execTransactionFromModuleReturnData",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of module transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of module transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of module transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of module transaction."
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "returnData",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }",
              "start": {
                "line": 86,
                "column": 4
              },
              "end": {
                "line": 105,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "operation Operation type of module transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of module transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of module transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of module transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows a Module to execute a Safe transaction without any further confirmations and return data",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getModules",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }",
              "start": {
                "line": 109,
                "column": 4
              },
              "end": {
                "line": 116,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of modules.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns array of first 10 modules.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getModulesPaginated",
              "params": [
                {
                  "name": "start",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Start of the page."
                },
                {
                  "name": "pageSize",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Maximum number of modules that should be returned."
                }
              ],
              "returnParams": [
                {
                  "name": "array",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "next",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }",
              "start": {
                "line": 122,
                "column": 4
              },
              "end": {
                "line": 144,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of modules.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "pageSize Maximum number of modules that should be returned.",
                  "subAnnotation": {
                    "name": "pageSize",
                    "value": "Maximum number of modules that should be returned.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "start Start of the page.",
                  "subAnnotation": {
                    "name": "start",
                    "value": "Start of the page.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns array of modules.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "execute",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
              "start": {
                "line": 9,
                "column": 4
              },
              "end": {
                "line": 19,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeDelegateCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 31,
                "column": 4
              },
              "end": {
                "line": 39,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "setupOwners",
              "params": [
                {
                  "name": "_owners",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of Safe owners."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Number of required confirmations for a Safe transaction."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }",
              "start": {
                "line": 22,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold Number of required confirmations for a Safe transaction.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "Number of required confirmations for a Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_owners List of Safe owners.",
                  "subAnnotation": {
                    "name": "_owners",
                    "value": "List of Safe owners.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "addOwnerWithThreshold",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New owner address."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 67,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "owner New owner address.",
                  "subAnnotation": {
                    "name": "owner",
                    "value": "New owner address.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "removeOwner",
              "params": [
                {
                  "name": "prevOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner that pointed to the owner to be removed in the linked list"
                },
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner address to be removed."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
              "start": {
                "line": 74,
                "column": 4
              },
              "end": {
                "line": 90,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "owner Owner address to be removed.",
                  "subAnnotation": {
                    "name": "owner",
                    "value": "Owner address to be removed.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevOwner Owner that pointed to the owner to be removed in the linked list",
                  "subAnnotation": {
                    "name": "prevOwner",
                    "value": "Owner that pointed to the owner to be removed in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "swapOwner",
              "params": [
                {
                  "name": "prevOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner that pointed to the owner to be replaced in the linked list"
                },
                {
                  "name": "oldOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner address to be replaced."
                },
                {
                  "name": "newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New owner address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }",
              "start": {
                "line": 97,
                "column": 4
              },
              "end": {
                "line": 113,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "newOwner New owner address.",
                  "subAnnotation": {
                    "name": "newOwner",
                    "value": "New owner address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "oldOwner Owner address to be replaced.",
                  "subAnnotation": {
                    "name": "oldOwner",
                    "value": "Owner address to be replaced.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
                  "subAnnotation": {
                    "name": "prevOwner",
                    "value": "Owner that pointed to the owner to be replaced in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "changeThreshold",
              "params": [
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }",
              "start": {
                "line": 118,
                "column": 4
              },
              "end": {
                "line": 128,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "getThreshold",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }",
              "start": {
                "line": 130,
                "column": 4
              },
              "end": {
                "line": 136,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "isOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }",
              "start": {
                "line": 138,
                "column": 4
              },
              "end": {
                "line": 144,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "getOwners",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }",
              "start": {
                "line": 148,
                "column": 4
              },
              "end": {
                "line": 164,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of Safe owners.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns array of owners.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "recoverKey",
              "params": [
                {
                  "name": "messageHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "operation ethereum signed message hash"
                },
                {
                  "name": "messageSignature",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "message `txHash` signature"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
              "start": {
                "line": 13,
                "column": 4
              },
              "end": {
                "line": 27,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "pos which signature to read",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageSignature message `txHash` signature",
                  "subAnnotation": {
                    "name": "messageSignature",
                    "value": "message `txHash` signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageHash operation ethereum signed message hash",
                  "subAnnotation": {
                    "name": "messageHash",
                    "value": "operation ethereum signed message hash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Recovers address who signed the message",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "signatureSplit",
              "params": [
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "concatenated rsv signatures"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
                }
              ],
              "returnParams": [
                {
                  "name": "v",
                  "solidityType": {
                    "name": "uint8",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "r",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "s",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 53,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "signatures concatenated rsv signatures",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "concatenated rsv signatures",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transferToken",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token that should be transferred"
                },
                {
                  "name": "receiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Receiver to whom the token should be transferred"
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "The amount of tokens that should be transferred"
                }
              ],
              "returnParams": [
                {
                  "name": "transferred",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 32,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "amount The amount of tokens that should be transferred",
                  "subAnnotation": {
                    "name": "amount",
                    "value": "The amount of tokens that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "receiver Receiver to whom the token should be transferred",
                  "subAnnotation": {
                    "name": "receiver",
                    "value": "Receiver to whom the token should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "token Token that should be transferred",
                  "subAnnotation": {
                    "name": "token",
                    "value": "Token that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Transfers a token and returns if it was a success",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "internalSetFallbackHandler",
              "params": [
                {
                  "name": "handler",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 18,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "setFallbackHandler",
              "params": [
                {
                  "name": "handler",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "contract to handle fallbacks calls."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }",
              "start": {
                "line": 24,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "handler contract to handle fallbacks calls.",
                  "subAnnotation": {
                    "name": "handler",
                    "value": "contract to handle fallbacks calls.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }",
              "start": {
                "line": 31,
                "column": 4
              },
              "end": {
                "line": 56,
                "column": 4
              },
              "annotations": []
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "EnabledModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "DisabledModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionFromModuleSuccess",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionFromModuleFailure",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            },
            {
              "name": "AddedOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "RemovedOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ChangedThreshold",
              "params": [
                {
                  "name": "threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/MasterCopy.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/SafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\n/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\ncontract GnosisSafe\n    is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {\n\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Gnosis Safe\";\n    string public constant VERSION = \"1.1.1\";\n\n    //keccak256(\n    //    \"EIP712Domain(address verifyingContract)\"\n    //);\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    //keccak256(\n    //    \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    //);\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    //keccak256(\n    //    \"SafeMessage(bytes message)\"\n    //);\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n\n    event ApproveHash(\n        bytes32 indexed approvedHash,\n        address indexed owner\n    );\n    event SignMsg(\n        bytes32 indexed msgHash\n    );\n    event ExecutionFailure(\n        bytes32 txHash, uint256 payment\n    );\n    event ExecutionSuccess(\n        bytes32 txHash, uint256 payment\n    );\n\n    uint256 public nonce;\n    bytes32 public domainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transfered, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }\n\n    /**\n    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n    * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n    * @param data That should be signed (this is passed to an external validator contract)\n    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\n    */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:\n    ///      1.) The method can only be called from the safe itself\n    ///      2.) The response is returned with a revert\n    ///      When estimating set `from` to the address of the safe.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n    */\n    function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n    * @dev Marks a message as signed\n    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\n    */\n    function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }\n\n    /**\n    * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n    * @dev Should return whether the signature provided is valid for the provided data.\n    *       The save does not implement the interface since `checkSignatures` is not a view method.\n    *       The method will not perform any state changes (see parameters of `checkSignatures`)\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    * @return a bool upon valid or invalid signature with corresponding _data\n    */\n    function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /// @dev Returns hash of a message that can be signed by owners.\n    /// @param message Message that should be hashed\n    /// @return Message hash.\n    function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n",
          "inFile": "GnosisSafe.sol",
          "references": [
            "MasterCopy",
            "ModuleManager",
            "OwnerManager",
            "SignatureDecoder",
            "SecuredTokenTransfer",
            "ISignatureValidatorConstants",
            "FallbackManager",
            "Enum.Operation"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 560
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c",
          "z": 1,
          "attrs": {
            "text": {
              "text": "GnosisSafe",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node node-highlighted",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fbc3b877-252f-43cb-a0e7-8bd940dcb6c6",
            "z": 76,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "79c9bae3-fe36-4a0a-b3b4-63a2588840e2",
            "z": 77,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "117f1591-71d5-4028-93b5-48758ae58048"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "79232782-97e4-43cb-84ae-44e7c91ce66b",
            "z": 78,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "bfe87647-739c-4ec9-b5b0-bdbb4dfdbeca",
            "z": 79,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "467920bb-9e51-497a-9e83-89cef8c088d5",
            "z": 80,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "4c09f3db-ef1f-433a-b1be-d284636229e8",
            "z": 81,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "1acc689e-72a8-431e-acc2-cfa8aa249afc",
            "z": 82,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Migrations",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "owner",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "last_completed_migration",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "last_completed_migration",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor()\n        public\n    {\n        owner = msg.sender;\n    }",
              "start": {
                "line": 11,
                "column": 4
              },
              "end": {
                "line": 15,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "setCompleted",
              "params": [
                {
                  "name": "completed",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "restricted",
                "public",
                null
              ],
              "source": "function setCompleted(uint completed)\n        public\n        restricted\n    {\n        last_completed_migration = completed;\n    }",
              "start": {
                "line": 17,
                "column": 4
              },
              "end": {
                "line": 22,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "upgrade",
              "params": [
                {
                  "name": "new_address",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "restricted",
                "public",
                null
              ],
              "source": "function upgrade(address new_address)\n        public\n        restricted\n    {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }",
              "start": {
                "line": 24,
                "column": 4
              },
              "end": {
                "line": 30,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [
            {
              "name": "restricted",
              "params": []
            }
          ],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed)\n        public\n        restricted\n    {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address)\n        public\n        restricted\n    {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
          "inFile": "Migrations.sol",
          "references": [
            "Migrations"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "626f4dfd-6815-4fb5-b617-9d05df8d2c5a",
          "z": 2,
          "attrs": {
            "text": {
              "text": "Migrations",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Executor",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "execute",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
              "start": {
                "line": 9,
                "column": 4
              },
              "end": {
                "line": 19,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeDelegateCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 31,
                "column": 4
              },
              "end": {
                "line": 39,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Executor - A contract that can execute transactions",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/Enum.sol\";\n\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }\n\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n}\n",
          "inFile": "Executor.sol",
          "references": [
            "Enum.Operation"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 685
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "709d61c1-c259-426e-a1d7-c12f8db82199",
          "z": 3,
          "attrs": {
            "text": {
              "text": "Executor",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "target": {
              "id": "709d61c1-c259-426e-a1d7-c12f8db82199"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "afdd6e5f-6302-453d-8ae5-79cb4d1cffd4",
            "z": -10,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "FallbackManager",
          "baseContracts": [
            "SelfAuthorized"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "FALLBACK_HANDLER_STORAGE_SLOT",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "FALLBACK_HANDLER_STORAGE_SLOT",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "internalSetFallbackHandler",
              "params": [
                {
                  "name": "handler",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 18,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "setFallbackHandler",
              "params": [
                {
                  "name": "handler",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "contract to handle fallbacks calls."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }",
              "start": {
                "line": 24,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "handler contract to handle fallbacks calls.",
                  "subAnnotation": {
                    "name": "handler",
                    "value": "contract to handle fallbacks calls.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }",
              "start": {
                "line": 31,
                "column": 4
              },
              "end": {
                "line": 56,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Fallback Manager - A contract that manages fallback calls made to this contract",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallbacks calls.\n    function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }\n\n    function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }\n}",
          "inFile": "FallbackManager.sol",
          "references": [
            "SelfAuthorized"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 460
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb",
          "z": 4,
          "attrs": {
            "text": {
              "text": "FallbackManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "1acc689e-72a8-431e-acc2-cfa8aa249afc",
            "z": 82,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "066d9447-a510-40cf-88f4-fa856c3dc85e",
            "z": -7,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Module",
          "baseContracts": [
            "MasterCopy"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "manager",
              "solidityType": {
                "name": "ModuleManager",
                "userDefined": true,
                "references": [
                  "ModuleManager"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "manager",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "ModuleManager",
                      "userDefined": true,
                      "references": [
                        "ModuleManager"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setManager",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Module - Base class for modules.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/MasterCopy.sol\";\nimport \"./ModuleManager.sol\";\n\n\n/// @title Module - Base class for modules.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Module is MasterCopy {\n\n    ModuleManager public manager;\n\n    modifier authorized() {\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\n        _;\n    }\n\n    function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }\n}\n",
          "inFile": "Module.sol",
          "references": [
            "MasterCopy",
            "ModuleManager"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 755
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "015b9a94-7f26-414a-9771-86532deeb9c3",
          "z": 5,
          "attrs": {
            "text": {
              "text": "Module",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "target": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "00c06bd1-4ad9-4165-81ba-b7c45b89bafe",
            "z": -8,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "07c09197-8e67-4613-a775-3e18482fcf8c",
            "z": -17,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "7b73ebee-0f22-4d89-9496-6cba1bf2180c",
            "z": -18,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "45924732-643e-4d8f-b171-5a9bd610a158"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "6ba5cc5c-4e42-408c-ba00-b9ecb2d347cd",
            "z": -19,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "d107d7b8-6f11-462c-81e7-0af23fd91990"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "eafcf5d6-c602-4da7-be9e-41b0a2045342",
            "z": -21,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ModuleManager",
          "baseContracts": [
            "SelfAuthorized",
            "Executor"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "SENTINEL_MODULES",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SENTINEL_MODULES",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "modules",
              "solidityType": {
                "name": "(address => address)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "modules",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setupModules",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }",
              "start": {
                "line": 22,
                "column": 4
              },
              "end": {
                "line": 30,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "enableModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module to be whitelisted."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }",
              "start": {
                "line": 35,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "module Module to be whitelisted.",
                  "subAnnotation": {
                    "name": "module",
                    "value": "Module to be whitelisted.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "disableModule",
              "params": [
                {
                  "name": "prevModule",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module that pointed to the module to be removed in the linked list"
                },
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module to be removed."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }",
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 62,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "module Module to be removed.",
                  "subAnnotation": {
                    "name": "module",
                    "value": "Module to be removed.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevModule Module that pointed to the module to be removed in the linked list",
                  "subAnnotation": {
                    "name": "prevModule",
                    "value": "Module that pointed to the module to be removed in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "execTransactionFromModule",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of module transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of module transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of module transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of module transaction."
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }",
              "start": {
                "line": 69,
                "column": 4
              },
              "end": {
                "line": 79,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "operation Operation type of module transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of module transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of module transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of module transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows a Module to execute a Safe transaction without any further confirmations.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "execTransactionFromModuleReturnData",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of module transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of module transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of module transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of module transaction."
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "returnData",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }",
              "start": {
                "line": 86,
                "column": 4
              },
              "end": {
                "line": 105,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "operation Operation type of module transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of module transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of module transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of module transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of module transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows a Module to execute a Safe transaction without any further confirmations and return data",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getModules",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }",
              "start": {
                "line": 109,
                "column": 4
              },
              "end": {
                "line": 116,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of modules.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns array of first 10 modules.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getModulesPaginated",
              "params": [
                {
                  "name": "start",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Start of the page."
                },
                {
                  "name": "pageSize",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Maximum number of modules that should be returned."
                }
              ],
              "returnParams": [
                {
                  "name": "array",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "next",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }",
              "start": {
                "line": 122,
                "column": 4
              },
              "end": {
                "line": 144,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of modules.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "pageSize Maximum number of modules that should be returned.",
                  "subAnnotation": {
                    "name": "pageSize",
                    "value": "Maximum number of modules that should be returned.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "start Start of the page.",
                  "subAnnotation": {
                    "name": "start",
                    "value": "Start of the page.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns array of modules.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Module Manager - A contract that manages modules that can execute transactions via this contract",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "EnabledModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "DisabledModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionFromModuleSuccess",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ExecutionFromModuleFailure",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [],
          "inheritedFunctions": [
            {
              "name": "execute",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
              "start": {
                "line": 9,
                "column": 4
              },
              "end": {
                "line": 19,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "executeDelegateCall",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "txGas",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "success",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
              "start": {
                "line": 31,
                "column": 4
              },
              "end": {
                "line": 39,
                "column": 4
              },
              "annotations": []
            }
          ],
          "inheritedEvents": [],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\nimport \"./Module.sol\";\n\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n\n    event EnabledModule(Module module);\n    event DisabledModule(Module module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping (address => address) internal modules;\n\n    function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @param module Module to be whitelisted.\n    function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns array of first 10 modules.\n    /// @return Array of modules.\n    function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return Array of modules.\n    function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n",
          "inFile": "ModuleManager.sol",
          "references": [
            "SelfAuthorized",
            "Executor",
            "Module",
            "Enum.Operation"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 600
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "19fff30f-5550-4cf1-9560-58b803b54d80",
          "z": 6,
          "attrs": {
            "text": {
              "text": "ModuleManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "79c9bae3-fe36-4a0a-b3b4-63a2588840e2",
            "z": 77,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "a02e7e62-2b4d-435c-bbd9-df61c03b07b2",
            "z": -9,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "target": {
              "id": "709d61c1-c259-426e-a1d7-c12f8db82199"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "afdd6e5f-6302-453d-8ae5-79cb4d1cffd4",
            "z": -10,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "OwnerManager",
          "baseContracts": [
            "SelfAuthorized"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "SENTINEL_OWNERS",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "SENTINEL_OWNERS",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "owners",
              "solidityType": {
                "name": "(address => address)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "owners",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "ownerCount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "default",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "ownerCount",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "threshold",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setupOwners",
              "params": [
                {
                  "name": "_owners",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of Safe owners."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Number of required confirmations for a Safe transaction."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }",
              "start": {
                "line": 22,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold Number of required confirmations for a Safe transaction.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "Number of required confirmations for a Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_owners List of Safe owners.",
                  "subAnnotation": {
                    "name": "_owners",
                    "value": "List of Safe owners.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "addOwnerWithThreshold",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New owner address."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 67,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "owner New owner address.",
                  "subAnnotation": {
                    "name": "owner",
                    "value": "New owner address.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "removeOwner",
              "params": [
                {
                  "name": "prevOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner that pointed to the owner to be removed in the linked list"
                },
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner address to be removed."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
              "start": {
                "line": 74,
                "column": 4
              },
              "end": {
                "line": 90,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "owner Owner address to be removed.",
                  "subAnnotation": {
                    "name": "owner",
                    "value": "Owner address to be removed.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevOwner Owner that pointed to the owner to be removed in the linked list",
                  "subAnnotation": {
                    "name": "prevOwner",
                    "value": "Owner that pointed to the owner to be removed in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "swapOwner",
              "params": [
                {
                  "name": "prevOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner that pointed to the owner to be replaced in the linked list"
                },
                {
                  "name": "oldOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner address to be replaced."
                },
                {
                  "name": "newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New owner address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }",
              "start": {
                "line": 97,
                "column": 4
              },
              "end": {
                "line": 113,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "newOwner New owner address.",
                  "subAnnotation": {
                    "name": "newOwner",
                    "value": "New owner address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "oldOwner Owner address to be replaced.",
                  "subAnnotation": {
                    "name": "oldOwner",
                    "value": "Owner address to be replaced.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
                  "subAnnotation": {
                    "name": "prevOwner",
                    "value": "Owner that pointed to the owner to be replaced in the linked list",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "changeThreshold",
              "params": [
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New threshold."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }",
              "start": {
                "line": 118,
                "column": 4
              },
              "end": {
                "line": 128,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold New threshold.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "New threshold.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "getThreshold",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }",
              "start": {
                "line": 130,
                "column": 4
              },
              "end": {
                "line": 136,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "isOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }",
              "start": {
                "line": 138,
                "column": 4
              },
              "end": {
                "line": 144,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "getOwners",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }",
              "start": {
                "line": 148,
                "column": 4
              },
              "end": {
                "line": 164,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Array of Safe owners.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns array of owners.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "OwnerManager - Manages a set of owners and a threshold to perform actions.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "AddedOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "RemovedOwner",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "ChangedThreshold",
              "params": [
                {
                  "name": "threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}\n",
          "inFile": "OwnerManager.sol",
          "references": [
            "SelfAuthorized"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 530
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "117f1591-71d5-4028-93b5-48758ae58048",
          "z": 7,
          "attrs": {
            "text": {
              "text": "OwnerManager",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "117f1591-71d5-4028-93b5-48758ae58048"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "79232782-97e4-43cb-84ae-44e7c91ce66b",
            "z": 78,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "117f1591-71d5-4028-93b5-48758ae58048"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "222136af-c638-40ca-ab6a-35cbb3d8ef8c",
            "z": -11,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Enum",
          "baseContracts": [],
          "enumerations": [
            {
              "name": "Enum.Operation",
              "shortName": "Operation",
              "parentName": "Enum",
              "elementType": 2,
              "entries": [
                {
                  "name": "Call",
                  "index": 0
                },
                {
                  "name": "DelegateCall",
                  "index": 1
                }
              ]
            }
          ],
          "structs": [],
          "stateVariables": [],
          "functions": [],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Enum - Collection of enums",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n",
          "inFile": "Enum.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 70
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113",
          "z": 8,
          "attrs": {
            "text": {
              "text": "Enum",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "3ac76a25-5f35-487a-af20-75377038bc17"
            },
            "target": {
              "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "bc6bd04c-7e35-4a80-9c6f-f3af1d1732eb",
            "z": -25,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 70
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "3ac76a25-5f35-487a-af20-75377038bc17",
          "z": 9,
          "attrs": {
            "text": {
              "text": "Operation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/list-ol.svg"
            },
            "rect": {
              "class": "enum-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "nodeElement": {
          "name": "Enum.Operation",
          "shortName": "Operation",
          "parentName": "Enum",
          "elementType": 2,
          "entries": [
            {
              "name": "Call",
              "index": 0
            },
            {
              "name": "DelegateCall",
              "index": 1
            }
          ]
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "3ac76a25-5f35-487a-af20-75377038bc17"
            },
            "target": {
              "id": "1c41da7f-a7ba-43f8-b3a1-3ccb58c11113"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "bc6bd04c-7e35-4a80-9c6f-f3af1d1732eb",
            "z": -25,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "EtherPaymentFallback",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n\n    }",
              "start": {
                "line": 9,
                "column": 4
              },
              "end": {
                "line": 14,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Fallback function accepts Ether transactions.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "EtherPaymentFallback - A contract that has a fallback to accept ether payments",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n\n    /// @dev Fallback function accepts Ether transactions.\n    function ()\n        external\n        payable\n    {\n\n    }\n}\n",
          "inFile": "EtherPaymentFallback.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 140
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "78c8cdfd-6948-490a-b510-3a30ea488e76",
          "z": 10,
          "attrs": {
            "text": {
              "text": "EtherPaymentFal...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "MasterCopy",
          "baseContracts": [
            "SelfAuthorized"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./SelfAuthorized.sol\";\n\n\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/Proxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MasterCopy is SelfAuthorized {\n\n    event ChangedMasterCopy(address masterCopy);\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private masterCopy;\n\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\n    /// @param _masterCopy New contract address.\n    function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }\n}\n",
          "inFile": "MasterCopy.sol",
          "references": [
            "SelfAuthorized"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 685
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "93d7c70a-d422-479a-883b-4d1fed7536ca",
          "z": 11,
          "attrs": {
            "text": {
              "text": "MasterCopy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fbc3b877-252f-43cb-a0e7-8bd940dcb6c6",
            "z": 76,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "target": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "00c06bd1-4ad9-4165-81ba-b7c45b89bafe",
            "z": -8,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "0a099b89-c1ff-441d-8afd-5ed1061f8ea6",
            "z": -12,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "SecuredTokenTransfer",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "transferToken",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token that should be transferred"
                },
                {
                  "name": "receiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Receiver to whom the token should be transferred"
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "The amount of tokens that should be transferred"
                }
              ],
              "returnParams": [
                {
                  "name": "transferred",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 32,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "amount The amount of tokens that should be transferred",
                  "subAnnotation": {
                    "name": "amount",
                    "value": "The amount of tokens that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "receiver Receiver to whom the token should be transferred",
                  "subAnnotation": {
                    "name": "receiver",
                    "value": "Receiver to whom the token should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "token Token that should be transferred",
                  "subAnnotation": {
                    "name": "token",
                    "value": "Token that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Transfers a token and returns if it was a success",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "SecuredTokenTransfer - Secure token transfer",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }\n}\n",
          "inFile": "SecuredTokenTransfer.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 820
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1",
          "z": 12,
          "attrs": {
            "text": {
              "text": "SecuredTokenTra...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "467920bb-9e51-497a-9e83-89cef8c088d5",
            "z": 80,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
            },
            "target": {
              "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fe7c746a-a0ab-4efd-8f5d-621c22f11775",
            "z": -24,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "SelfAuthorized",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "SelfAuthorized - authorizes current contract to perform actions",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    modifier authorized() {\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\n        _;\n    }\n}\n",
          "inFile": "SelfAuthorized.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 580
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a",
          "z": 13,
          "attrs": {
            "text": {
              "text": "SelfAuthorized",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "525ce569-e31f-4601-9b6e-a3b4f274bfdb"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "066d9447-a510-40cf-88f4-fa856c3dc85e",
            "z": -7,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "19fff30f-5550-4cf1-9560-58b803b54d80"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "a02e7e62-2b4d-435c-bbd9-df61c03b07b2",
            "z": -9,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "117f1591-71d5-4028-93b5-48758ae58048"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "222136af-c638-40ca-ab6a-35cbb3d8ef8c",
            "z": -11,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "93d7c70a-d422-479a-883b-4d1fed7536ca"
            },
            "target": {
              "id": "f9b4a76d-41c7-4d3c-8aa8-ce502f0b6b8a"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "0a099b89-c1ff-441d-8afd-5ed1061f8ea6",
            "z": -12,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "SignatureDecoder",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "recoverKey",
              "params": [
                {
                  "name": "messageHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "operation ethereum signed message hash"
                },
                {
                  "name": "messageSignature",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "message `txHash` signature"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
              "start": {
                "line": 13,
                "column": 4
              },
              "end": {
                "line": 27,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "pos which signature to read",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageSignature message `txHash` signature",
                  "subAnnotation": {
                    "name": "messageSignature",
                    "value": "message `txHash` signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageHash operation ethereum signed message hash",
                  "subAnnotation": {
                    "name": "messageHash",
                    "value": "operation ethereum signed message hash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Recovers address who signed the message",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "signatureSplit",
              "params": [
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "concatenated rsv signatures"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
                }
              ],
              "returnParams": [
                {
                  "name": "v",
                  "solidityType": {
                    "name": "uint8",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "r",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "s",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 53,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "signatures concatenated rsv signatures",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "concatenated rsv signatures",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Ricardo Guilherme Schmidt (Status Research & Development GmbH)",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "SignatureDecoder - Decodes signatures that a encoded as bytes",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    \n    /// @dev Recovers address who signed the message\n    /// @param messageHash operation ethereum signed message hash\n    /// @param messageSignature message `txHash` signature\n    /// @param pos which signature to read\n    function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }\n\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n",
          "inFile": "SignatureDecoder.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 890
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3",
          "z": 14,
          "attrs": {
            "text": {
              "text": "SignatureDecoder",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "bfe87647-739c-4ec9-b5b0-bdbb4dfdbeca",
            "z": 79,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "45924732-643e-4d8f-b171-5a9bd610a158"
            },
            "target": {
              "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "9c321eca-d2d7-4a1d-aa11-4dd482e423d8",
            "z": -20,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "SafeMath",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "mul",
              "params": [
                {
                  "name": "a",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "b",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }",
              "start": {
                "line": 13,
                "column": 2
              },
              "end": {
                "line": 25,
                "column": 2
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Multiplies two numbers, reverts on overflow.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "div",
              "params": [
                {
                  "name": "a",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "b",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }",
              "start": {
                "line": 30,
                "column": 2
              },
              "end": {
                "line": 36,
                "column": 2
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Integer division of two numbers truncating the quotient, reverts on division by zero.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "sub",
              "params": [
                {
                  "name": "a",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "b",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }",
              "start": {
                "line": 41,
                "column": 2
              },
              "end": {
                "line": 46,
                "column": 2
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "add",
              "params": [
                {
                  "name": "a",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "b",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }",
              "start": {
                "line": 51,
                "column": 2
              },
              "end": {
                "line": 56,
                "column": 2
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Adds two numbers, reverts on overflow.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "mod",
              "params": [
                {
                  "name": "a",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "b",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }",
              "start": {
                "line": 62,
                "column": 2
              },
              "end": {
                "line": 65,
                "column": 2
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "reverts when dividing by zero.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Divides two numbers and returns the remainder (unsigned integer modulo),",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "TODO: remove once open zeppelin update to solc 0.5.0",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Math operations with safety checks that revert on error",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "SafeMath",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "library",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}",
          "inFile": "SafeMath.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 210
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "805cfa54-7420-4c69-bcef-65dbde7d123b",
          "z": 15,
          "attrs": {
            "text": {
              "text": "SafeMath",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/book-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "DefaultCallbackHandler",
          "baseContracts": [
            "ERC1155TokenReceiver",
            "ERC777TokensRecipient",
            "ERC721TokenReceiver"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "onERC1155Received",
              "params": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xf23a6e61;\n    }",
              "start": {
                "line": 14,
                "column": 4
              },
              "end": {
                "line": 19,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "onERC1155BatchReceived",
              "params": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256[]",
                    "pureName": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256[]",
                    "pureName": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xbc197c81;\n    }",
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "onERC721Received",
              "params": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0x150b7a02;\n    }",
              "start": {
                "line": 28,
                "column": 4
              },
              "end": {
                "line": 33,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "tokensReceived",
              "params": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external {\n        // We implement this for completeness, doesn't really have any value\n    }",
              "start": {
                "line": 36,
                "column": 4
              },
              "end": {
                "line": 38,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Default Callback Handler - returns true for known token callbacks",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../interfaces/ERC1155TokenReceiver.sol\";\nimport \"../interfaces/ERC721TokenReceiver.sol\";\nimport \"../interfaces/ERC777TokensRecipient.sol\";\n\n/// @title Default Callback Handler - returns true for known token callbacks\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract DefaultCallbackHandler is ERC1155TokenReceiver, ERC777TokensRecipient, ERC721TokenReceiver {\n\n    string public constant NAME = \"Default Callback Handler\";\n    string public constant VERSION = \"1.0.0\";\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0xbc197c81;\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        returns(bytes4)\n    {\n        return 0x150b7a02;\n    }\n\n    // solium-disable-next-line no-empty-blocks\n    function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external {\n        // We implement this for completeness, doesn't really have any value\n    }\n\n}",
          "inFile": "DefaultCallbackHandler.sol",
          "references": [
            "ERC1155TokenReceiver",
            "ERC777TokensRecipient",
            "ERC721TokenReceiver"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 280
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d",
          "z": 16,
          "attrs": {
            "text": {
              "text": "DefaultCallback...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "76fb5e5f-8b69-4291-80a9-55341f985367",
            "z": 73,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "abd7d93a-3017-4c52-8b24-15cb54254408"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "06975f5b-4a31-49c1-a469-5314a86f036f",
            "z": 74,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "1d905bf3-a613-40a2-87fb-db7451d05e45"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "84e951c2-f179-479b-b0fe-73f25306a8c1",
            "z": 75,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ERC1155TokenReceiver",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "onERC1155Received",
              "params": [
                {
                  "name": "_operator",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_id",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);",
              "start": {
                "line": 20,
                "column": 4
              },
              "end": {
                "line": 20,
                "column": 140
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "onERC1155BatchReceived",
              "params": [
                {
                  "name": "_operator",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_ids",
                  "solidityType": {
                    "name": "uint256[]",
                    "pureName": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_values",
                  "solidityType": {
                    "name": "uint256[]",
                    "pureName": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);",
              "start": {
                "line": 35,
                "column": 4
              },
              "end": {
                "line": 35,
                "column": 169
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface ERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        \n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _id        The ID of the token being transferred\n        @param _value     The amount of tokens being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.        \n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);       \n}",
          "inFile": "ERC1155TokenReceiver.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 175
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff",
          "z": 17,
          "attrs": {
            "text": {
              "text": "ERC1155TokenRec...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "c0e707a0-06a4-498b-9e41-4795697ea1ff"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "76fb5e5f-8b69-4291-80a9-55341f985367",
            "z": 73,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ERC721TokenReceiver",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "onERC721Received",
              "params": [
                {
                  "name": "_operator",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_tokenId",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);",
              "start": {
                "line": 17,
                "column": 4
              },
              "end": {
                "line": 17,
                "column": 128
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "dev",
              "value": "Note: the ERC-165 identifier for this interface is 0x150b7a02.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}",
          "inFile": "ERC721TokenReceiver.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 245
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "1d905bf3-a613-40a2-87fb-db7451d05e45",
          "z": 18,
          "attrs": {
            "text": {
              "text": "ERC721TokenRece...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "1d905bf3-a613-40a2-87fb-db7451d05e45"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "84e951c2-f179-479b-b0fe-73f25306a8c1",
            "z": 75,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ERC777TokensRecipient",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "tokensReceived",
              "params": [
                {
                  "name": "operator",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "operatorData",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;",
              "start": {
                "line": 4,
                "column": 4
              },
              "end": {
                "line": 11,
                "column": 14
              },
              "annotations": []
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\ninterface ERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}",
          "inFile": "ERC777TokensRecipient.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 455
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "abd7d93a-3017-4c52-8b24-15cb54254408",
          "z": 19,
          "attrs": {
            "text": {
              "text": "ERC777TokensRec...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "ebd1f9a6-420e-436a-8fa8-b1f1311dbe5d"
            },
            "target": {
              "id": "abd7d93a-3017-4c52-8b24-15cb54254408"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "06975f5b-4a31-49c1-a469-5314a86f036f",
            "z": 74,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ISignatureValidatorConstants",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "EIP1271_MAGIC_VALUE",
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "EIP1271_MAGIC_VALUE",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes4",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\ncontract ISignatureValidator is ISignatureValidatorConstants {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);\n}",
          "inFile": "ISignatureValidator.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 985
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "8ef96d38-e4b4-43b9-a523-d2276464c027",
          "z": 20,
          "attrs": {
            "text": {
              "text": "ISignatureValid...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "06d4e95f-b065-4ade-a0fe-a5808fdc830c"
            },
            "target": {
              "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "4c09f3db-ef1f-433a-b1be-d284636229e8",
            "z": 81,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "b11b442a-f51b-4262-809a-56bf96e8af47"
            },
            "target": {
              "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "15c7bb9d-a676-4d04-95cd-10a910c8a306",
            "z": -16,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ISignatureValidator",
          "baseContracts": [
            "ISignatureValidatorConstants"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "isValidSignature",
              "params": [
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_signature",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes4",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);",
              "start": {
                "line": 19,
                "column": 4
              },
              "end": {
                "line": 24,
                "column": 24
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "MUST allow external calls",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "MUST return the bytes4 magic value 0x20c13b0b when function passes.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "EIP1271_MAGIC_VALUE",
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "EIP1271_MAGIC_VALUE",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes4",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\ncontract ISignatureValidator is ISignatureValidatorConstants {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature)\n        public\n        view\n        returns (bytes4);\n}",
          "inFile": "ISignatureValidator.sol",
          "references": [
            "ISignatureValidatorConstants"
          ],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 1065
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "b11b442a-f51b-4262-809a-56bf96e8af47",
          "z": 21,
          "attrs": {
            "text": {
              "text": "ISignatureValid...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "b11b442a-f51b-4262-809a-56bf96e8af47"
            },
            "target": {
              "id": "8ef96d38-e4b4-43b9-a523-d2276464c027"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "15c7bb9d-a676-4d04-95cd-10a910c8a306",
            "z": -16,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "CreateAndAddModules",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "enableModule",
              "params": [
                {
                  "name": "module",
                  "solidityType": {
                    "name": "Module",
                    "userDefined": true,
                    "references": [
                      "Module"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Not used."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function enableModule(Module module)\n        public\n    {\n        revert();\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 16,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "module Not used.",
                  "subAnnotation": {
                    "name": "module",
                    "value": "Not used.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Function required to compile contract. Gnosis Safe function is called instead.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "createAndAddModules",
              "params": [
                {
                  "name": "proxyFactory",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Module proxy factory contract."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function createAndAddModules(address proxyFactory, bytes memory data)\n        public\n    {\n        uint256 length = data.length;\n        Module module;\n        uint256 i = 0;\n        while (i < length) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let createBytesLength := mload(add(0x20, add(data, i)))\n                let createBytes := add(0x40, add(data, i))\n\n                let output := mload(0x40)\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\n\n                // Data is always padded to 32 bytes\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\n            }\n            this.enableModule(module);\n        }\n    }",
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 42,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "proxyFactory Module proxy factory contract.",
                  "subAnnotation": {
                    "name": "proxyFactory",
                    "value": "Module proxy factory contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to create and add multiple module in one transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Create and Add Modules - Allows to create and add multiple module in one transaction.",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0xF61A721642B0c0C8b334bA3763BA1326F53798C0",
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\n\n\n/// @title Create and Add Modules - Allows to create and add multiple module in one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract CreateAndAddModules {\n\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\n    /// @param module Not used.\n    function enableModule(Module module)\n        public\n    {\n        revert();\n    }\n\n    /// @dev Allows to create and add multiple module in one transaction.\n    /// @param proxyFactory Module proxy factory contract.\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)\n    function createAndAddModules(address proxyFactory, bytes memory data)\n        public\n    {\n        uint256 length = data.length;\n        Module module;\n        uint256 i = 0;\n        while (i < length) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let createBytesLength := mload(add(0x20, add(data, i)))\n                let createBytes := add(0x40, add(data, i))\n\n                let output := mload(0x40)\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\n\n                // Data is always padded to 32 bytes\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\n            }\n            this.enableModule(module);\n        }\n    }\n}\n",
          "inFile": "CreateAndAddModules.sol",
          "references": [
            "Module"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 350
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "44fb2d7f-5a55-4177-b15b-d1b9b127d5e5",
          "z": 22,
          "attrs": {
            "text": {
              "text": "CreateAndAddMod...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "CreateCall",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "performCreate2",
              "params": [
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "deploymentData",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "salt",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "newContract",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function performCreate2(uint256 value, bytes memory deploymentData, bytes32 salt) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }",
              "start": {
                "line": 9,
                "column": 4
              },
              "end": {
                "line": 16,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "performCreate",
              "params": [
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "deploymentData",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": "newContract",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function performCreate(uint256 value, bytes memory deploymentData) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Create Call - Allows to use the different create opcodes to deploy a contract",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x8538FcBccba7f5303d2C679Fa5d7A629A8c9bf4A",
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "ContractCreation",
              "params": [
                {
                  "name": "newContract",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Create Call - Allows to use the different create opcodes to deploy a contract\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract CreateCall {\n    event ContractCreation(address newContract);\n\n    function performCreate2(uint256 value, bytes memory deploymentData, bytes32 salt) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }\n\n    function performCreate(uint256 value, bytes memory deploymentData) public returns(address newContract) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\n        }\n        require(newContract != address(0), \"Could not deploy contract\");\n        emit ContractCreation(newContract);\n    }\n}",
          "inFile": "CreateCall.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 420
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2077831d-a074-4376-9a14-b78d7efa917f",
          "z": 23,
          "attrs": {
            "text": {
              "text": "CreateCall",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "MultiSend",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "GUARD_VALUE",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "GUARD_VALUE",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "guard",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "default",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "guard",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor() public {\n        guard = GUARD_VALUE;\n    }",
              "start": {
                "line": 15,
                "column": 4
              },
              "end": {
                "line": 17,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "multiSend",
              "params": [
                {
                  "name": "transactions",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function multiSend(bytes memory transactions)\n        public\n    {\n        require(guard != GUARD_VALUE, \"MultiSend should only be called via delegatecall\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\n                if eq(success, 0) { revert(0, 0) }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }",
              "start": {
                "line": 27,
                "column": 4
              },
              "end": {
                "line": 58,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "GonÃ§alo SÃ¡ - <goncalo.sa@consensys.net>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Nick Dodson - <nick.dodson@consensys.net>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Multi Send - Allows to batch multiple transactions into one.",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n\n/// @title Multi Send - Allows to batch multiple transactions into one.\n/// @author Nick Dodson - <nick.dodson@consensys.net>\n/// @author GonÃ§alo SÃ¡ - <goncalo.sa@consensys.net>\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MultiSend {\n\n    bytes32 constant private GUARD_VALUE = keccak256(\"multisend.guard.bytes32\");\n\n    bytes32 guard;\n\n    constructor() public {\n        guard = GUARD_VALUE;\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    function multiSend(bytes memory transactions)\n        public\n    {\n        require(guard != GUARD_VALUE, \"MultiSend should only be called via delegatecall\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\n                if eq(success, 0) { revert(0, 0) }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}\n",
          "inFile": "MultiSend.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 490
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "82d34f9d-c1d8-478d-8c10-098e0c84b193",
          "z": 24,
          "attrs": {
            "text": {
              "text": "MultiSend",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ERC1155Token",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "_balances",
              "solidityType": {
                "name": "(uint256 => (address => uint256))",
                "mapping": {
                  "key": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "(address => uint256)",
                    "mapping": {
                      "key": {
                        "name": "address",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      },
                      "value": {
                        "name": "uint256",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      }
                    },
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "_balances",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "(address => uint256)",
                      "mapping": {
                        "key": {
                          "name": "address",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        },
                        "value": {
                          "name": "uint256",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        }
                      },
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "_operatorApprovals",
              "solidityType": {
                "name": "(address => (address => bool))",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "(address => bool)",
                    "mapping": {
                      "key": {
                        "name": "address",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      },
                      "value": {
                        "name": "bool",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      }
                    },
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "_operatorApprovals",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "(address => bool)",
                      "mapping": {
                        "key": {
                          "name": "address",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        },
                        "value": {
                          "name": "bool",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        }
                      },
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "balanceOf",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "id",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function balanceOf(address owner, uint256 id) public view returns (uint256) {\n        require(owner != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][owner];\n    }",
              "start": {
                "line": 22,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "safeTransferFrom",
              "params": [
                {
                  "name": "from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "id",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }",
              "start": {
                "line": 37,
                "column": 4
              },
              "end": {
                "line": 56,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "mint",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "The address that will own the minted token"
                },
                {
                  "name": "id",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "ID of the token to be minted"
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Amount of the token to be minted"
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data forwarded to `onERC1155Received` if `to` is a contract receiver"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function mint(address to, uint256 id, uint256 value, bytes calldata data) external {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n    }",
              "start": {
                "line": 65,
                "column": 4
              },
              "end": {
                "line": 71,
                "column": 4
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "data Data forwarded to `onERC1155Received` if `to` is a contract receiver",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data forwarded to `onERC1155Received` if `to` is a contract receiver",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Amount of the token to be minted",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Amount of the token to be minted",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "id ID of the token to be minted",
                  "subAnnotation": {
                    "name": "id",
                    "value": "ID of the token to be minted",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to The address that will own the minted token",
                  "subAnnotation": {
                    "name": "to",
                    "value": "The address that will own the minted token",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Test function to mint an amount of a token with the given ID",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "isContract",
              "params": [
                {
                  "name": "account",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "view"
              ],
              "source": "function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }",
              "start": {
                "line": 73,
                "column": 4
              },
              "end": {
                "line": 82,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "_doSafeTransferAcceptanceCheck",
              "params": [
                {
                  "name": "operator",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "id",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n    {\n        if(isContract(to)) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    ERC1155TokenReceiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }",
              "start": {
                "line": 84,
                "column": 4
              },
              "end": {
                "line": 101,
                "column": 4
              },
              "annotations": []
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\nimport \"../interfaces/ERC1155TokenReceiver.sol\";\nimport \"../external/SafeMath.sol\";\n\ncontract ERC1155Token {\n\n    using SafeMath for uint256;\n\n    // Mapping from token ID to owner balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n        @dev Get the specified address' balance for token with specified ID.\n        @param owner The address of the token holder\n        @param id ID of the token\n        @return The owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id) public view returns (uint256) {\n        require(owner != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][owner];\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }\n\n    /**\n     * @dev Test function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function mint(address to, uint256 id, uint256 value, bytes calldata data) external {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n    {\n        if(isContract(to)) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    ERC1155TokenReceiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }\n}",
          "inFile": "ERC1155Token.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 560
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "9cc498e3-3783-43eb-b942-d1a8ffd77593",
          "z": 25,
          "attrs": {
            "text": {
              "text": "ERC1155Token",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Token",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "transfer",
              "params": [
                {
                  "name": "_to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function transfer(address _to, uint value) public returns (bool);",
              "start": {
                "line": 4,
                "column": 1
              },
              "end": {
                "line": 4,
                "column": 65
              },
              "annotations": []
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"@gnosis.pm/mock-contract/contracts/MockContract.sol\";\ncontract Token {\n\tfunction transfer(address _to, uint value) public returns (bool);\n}\n",
          "inFile": "Token.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 630
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e760fddd-da71-4698-ae1c-25b756fcde84",
          "z": 26,
          "attrs": {
            "text": {
              "text": "Token",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "DailyLimitModule",
          "baseContracts": [
            "Module"
          ],
          "enumerations": [],
          "structs": [
            {
              "name": "DailyLimitModule.DailyLimit",
              "shortName": "DailyLimit",
              "parentName": "DailyLimitModule",
              "elementType": 1,
              "fields": [
                {
                  "name": "dailyLimit",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "spentToday",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "lastDay",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                }
              ]
            }
          ],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "dailyLimits",
              "solidityType": {
                "name": "(address => DailyLimit)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "DailyLimit",
                    "userDefined": true,
                    "references": [
                      "DailyLimit"
                    ],
                    "isArray": false
                  }
                },
                "userDefined": true,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "dailyLimits",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "DailyLimit",
                      "userDefined": true,
                      "references": [
                        "DailyLimit"
                      ],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "DailyLimit",
                      "userDefined": true,
                      "references": [
                        "DailyLimit"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setup",
              "params": [
                {
                  "name": "tokens",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of token addresses. Ether is represented with address 0x0."
                },
                {
                  "name": "_dailyLimits",
                  "solidityType": {
                    "name": "uint256[]",
                    "pureName": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of daily limits in smalles units (e.g. Wei for Ether)."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function setup(address[] memory tokens, uint256[] memory _dailyLimits)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < tokens.length; i++)\n            dailyLimits[tokens[i]].dailyLimit = _dailyLimits[i];\n    }",
              "start": {
                "line": 27,
                "column": 4
              },
              "end": {
                "line": 33,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_dailyLimits List of daily limits in smalles units (e.g. Wei for Ether).",
                  "subAnnotation": {
                    "name": "_dailyLimits",
                    "value": "List of daily limits in smalles units (e.g. Wei for Ether).",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "tokens List of token addresses. Ether is represented with address 0x0.",
                  "subAnnotation": {
                    "name": "tokens",
                    "value": "List of token addresses. Ether is represented with address 0x0.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "changeDailyLimit",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token contract address."
                },
                {
                  "name": "dailyLimit",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Daily limit in smallest token unit."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeDailyLimit(address token, uint256 dailyLimit)\n        public\n        authorized\n    {\n        dailyLimits[token].dailyLimit = dailyLimit;\n    }",
              "start": {
                "line": 38,
                "column": 4
              },
              "end": {
                "line": 43,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "dailyLimit Daily limit in smallest token unit.",
                  "subAnnotation": {
                    "name": "dailyLimit",
                    "value": "Daily limit in smallest token unit.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "token Token contract address.",
                  "subAnnotation": {
                    "name": "token",
                    "value": "Token contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to update the daily limit for a specified token. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "executeDailyLimit",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of the token that should be transfered (0 for Ether)"
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address to which the tokens should be transfered"
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Amount of tokens (or Ether) that should be transfered"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function executeDailyLimit(address token, address to, uint256 amount)\n        public\n    {\n        // Only Safe owners are allowed to execute daily limit transactions.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(to != address(0), \"Invalid to address provided\");\n        require(amount > 0, \"Invalid amount provided\");\n        // Validate that transfer is not exceeding daily limit.\n        require(isUnderLimit(token, amount), \"Daily limit has been reached\");\n        dailyLimits[token].spentToday += amount;\n        if (token == address(0)) {\n            require(manager.execTransactionFromModule(to, amount, \"\", Enum.Operation.Call), \"Could not execute ether transfer\");\n        } else {\n            bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n            require(manager.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \"Could not execute token transfer\");\n        }\n    }",
              "start": {
                "line": 50,
                "column": 4
              },
              "end": {
                "line": 66,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Returns if transaction can be executed.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "amount Amount of tokens (or Ether) that should be transfered",
                  "subAnnotation": {
                    "name": "amount",
                    "value": "Amount of tokens (or Ether) that should be transfered",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Address to which the tokens should be transfered",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Address to which the tokens should be transfered",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "token Address of the token that should be transfered (0 for Ether)",
                  "subAnnotation": {
                    "name": "token",
                    "value": "Address of the token that should be transfered (0 for Ether)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns if Safe transaction is a valid daily limit transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "isUnderLimit",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function isUnderLimit(address token, uint256 amount)\n        internal\n        returns (bool)\n    {\n        DailyLimit storage dailyLimit = dailyLimits[token];\n        if (today() > dailyLimit.lastDay) {\n            dailyLimit.lastDay = today();\n            dailyLimit.spentToday = 0;\n        }\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit && \n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\n            return true;\n        return false;\n    }",
              "start": {
                "line": 68,
                "column": 4
              },
              "end": {
                "line": 81,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "today",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function today()\n        public\n        view\n        returns (uint)\n    {\n        return now - (now % 1 days);\n    }",
              "start": {
                "line": 85,
                "column": 4
              },
              "end": {
                "line": 91,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Unix timestamp.",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns last midnight as Unix timestamp.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Daily Limit Module - Allows to transfer limited amounts of ERC20 tokens and Ether without confirmations.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "manager",
              "solidityType": {
                "name": "ModuleManager",
                "userDefined": true,
                "references": [
                  "ModuleManager"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "manager",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "ModuleManager",
                      "userDefined": true,
                      "references": [
                        "ModuleManager"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "setManager",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Daily Limit Module - Allows to transfer limited amounts of ERC20 tokens and Ether without confirmations.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract DailyLimitModule is Module {\n\n    string public constant NAME = \"Daily Limit Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // dailyLimits mapping maps token address to daily limit settings.\n    mapping (address => DailyLimit) public dailyLimits;\n\n    struct DailyLimit {\n        uint256 dailyLimit;\n        uint256 spentToday;\n        uint256 lastDay;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param tokens List of token addresses. Ether is represented with address 0x0.\n    /// @param _dailyLimits List of daily limits in smalles units (e.g. Wei for Ether).\n    function setup(address[] memory tokens, uint256[] memory _dailyLimits)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < tokens.length; i++)\n            dailyLimits[tokens[i]].dailyLimit = _dailyLimits[i];\n    }\n\n    /// @dev Allows to update the daily limit for a specified token. This can only be done via a Safe transaction.\n    /// @param token Token contract address.\n    /// @param dailyLimit Daily limit in smallest token unit.\n    function changeDailyLimit(address token, uint256 dailyLimit)\n        public\n        authorized\n    {\n        dailyLimits[token].dailyLimit = dailyLimit;\n    }\n\n    /// @dev Returns if Safe transaction is a valid daily limit transaction.\n    /// @param token Address of the token that should be transfered (0 for Ether)\n    /// @param to Address to which the tokens should be transfered\n    /// @param amount Amount of tokens (or Ether) that should be transfered\n    /// @return Returns if transaction can be executed.\n    function executeDailyLimit(address token, address to, uint256 amount)\n        public\n    {\n        // Only Safe owners are allowed to execute daily limit transactions.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(to != address(0), \"Invalid to address provided\");\n        require(amount > 0, \"Invalid amount provided\");\n        // Validate that transfer is not exceeding daily limit.\n        require(isUnderLimit(token, amount), \"Daily limit has been reached\");\n        dailyLimits[token].spentToday += amount;\n        if (token == address(0)) {\n            require(manager.execTransactionFromModule(to, amount, \"\", Enum.Operation.Call), \"Could not execute ether transfer\");\n        } else {\n            bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n            require(manager.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \"Could not execute token transfer\");\n        }\n    }\n\n    function isUnderLimit(address token, uint256 amount)\n        internal\n        returns (bool)\n    {\n        DailyLimit storage dailyLimit = dailyLimits[token];\n        if (today() > dailyLimit.lastDay) {\n            dailyLimit.lastDay = today();\n            dailyLimit.spentToday = 0;\n        }\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit && \n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\n            return true;\n        return false;\n    }\n\n    /// @dev Returns last midnight as Unix timestamp.\n    /// @return Unix timestamp.\n    function today()\n        public\n        view\n        returns (uint)\n    {\n        return now - (now % 1 days);\n    }\n}\n",
          "inFile": "DailyLimitModule.sol",
          "references": [
            "Module",
            "DailyLimit"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 700
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8",
          "z": 27,
          "attrs": {
            "text": {
              "text": "DailyLimitModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "07c09197-8e67-4613-a775-3e18482fcf8c",
            "z": -17,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8"
            },
            "target": {
              "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "ae9b3ce7-a282-40c4-8331-2378318c63d3",
            "z": -26,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "name": "DailyLimitModule.DailyLimit",
          "shortName": "DailyLimit",
          "parentName": "DailyLimitModule",
          "elementType": 1,
          "fields": [
            {
              "name": "dailyLimit",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "spentToday",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "lastDay",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 700
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8",
          "z": 28,
          "attrs": {
            "text": {
              "text": "DailyLimit",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "cdca05bd-485b-4b65-8ddf-bc5ed19c51e8"
            },
            "target": {
              "id": "71cad925-d4d5-49c2-8478-11d4aa101fe8"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "ae9b3ce7-a282-40c4-8331-2378318c63d3",
            "z": -26,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "SocialRecoveryModule",
          "baseContracts": [
            "Module"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "threshold",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "threshold",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "friends",
              "solidityType": {
                "name": "address[]",
                "pureName": "address",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "friends",
                "params": [
                  {
                    "solidityType": {
                      "isArray": false,
                      "name": "uint256",
                      "references": [],
                      "userDefined": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "isFriend",
              "solidityType": {
                "name": "(address => bool)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "isFriend",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "isExecuted",
              "solidityType": {
                "name": "(bytes32 => bool)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "isExecuted",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "isConfirmed",
              "solidityType": {
                "name": "(bytes32 => (address => bool))",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "(address => bool)",
                    "mapping": {
                      "key": {
                        "name": "address",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      },
                      "value": {
                        "name": "bool",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      }
                    },
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "isConfirmed",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "(address => bool)",
                      "mapping": {
                        "key": {
                          "name": "address",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        },
                        "value": {
                          "name": "bool",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        }
                      },
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setup",
              "params": [
                {
                  "name": "_friends",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of friends' addresses."
                },
                {
                  "name": "_threshold",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Required number of friends to confirm replacement."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function setup(address[] memory _friends, uint256 _threshold)\n        public\n    {\n        require(_threshold <= _friends.length, \"Threshold cannot exceed friends count\");\n        require(_threshold >= 2, \"At least 2 friends required\");\n        setManager();\n        // Set allowed friends.\n        for (uint256 i = 0; i < _friends.length; i++) {\n            address friend = _friends[i];\n            require(friend != address(0), \"Invalid friend address provided\");\n            require(!isFriend[friend], \"Duplicate friend address provided\");\n            isFriend[friend] = true;\n        }\n        friends = _friends;\n        threshold = _threshold;\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 48,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_threshold Required number of friends to confirm replacement.",
                  "subAnnotation": {
                    "name": "_threshold",
                    "value": "Required number of friends to confirm replacement.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_friends List of friends' addresses.",
                  "subAnnotation": {
                    "name": "_friends",
                    "value": "List of friends' addresses.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "confirmTransaction",
              "params": [
                {
                  "name": "dataHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Safe transaction hash."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "onlyFriend",
                "public",
                null
              ],
              "source": "function confirmTransaction(bytes32 dataHash)\n        public\n        onlyFriend\n    {\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        isConfirmed[dataHash][msg.sender] = true;\n    }",
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 58,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "dataHash Safe transaction hash.",
                  "subAnnotation": {
                    "name": "dataHash",
                    "value": "Safe transaction hash.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows a friend to confirm a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "recoverAccess",
              "params": [
                {
                  "name": "prevOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner that pointed to the owner to be replaced in the linked list"
                },
                {
                  "name": "oldOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Owner address to be replaced."
                },
                {
                  "name": "newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New owner address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "onlyFriend",
                "public",
                null
              ],
              "source": "function recoverAccess(address prevOwner, address oldOwner, address newOwner)\n        public\n        onlyFriend\n    {\n        bytes memory data = abi.encodeWithSignature(\"swapOwner(address,address,address)\", prevOwner, oldOwner, newOwner);\n        bytes32 dataHash = getDataHash(data);\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        require(isConfirmedByRequiredFriends(dataHash), \"Recovery has not enough confirmations\");\n        isExecuted[dataHash] = true;\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \"Could not execute recovery\");\n    }",
              "start": {
                "line": 65,
                "column": 4
              },
              "end": {
                "line": 75,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Returns if transaction can be executed.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "newOwner New owner address.",
                  "subAnnotation": {
                    "name": "newOwner",
                    "value": "New owner address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "oldOwner Owner address to be replaced.",
                  "subAnnotation": {
                    "name": "oldOwner",
                    "value": "Owner address to be replaced.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
                  "subAnnotation": {
                    "name": "prevOwner",
                    "value": "Owner that pointed to the owner to be replaced in the linked list",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns if Safe transaction is a valid owner replacement transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "isConfirmedByRequiredFriends",
              "params": [
                {
                  "name": "dataHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Data hash."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function isConfirmedByRequiredFriends(bytes32 dataHash)\n        public\n        view\n        returns (bool)\n    {\n        uint256 confirmationCount;\n        for (uint256 i = 0; i < friends.length; i++) {\n            if (isConfirmed[dataHash][friends[i]])\n                confirmationCount++;\n            if (confirmationCount == threshold)\n                return true;\n        }\n        return false;\n    }",
              "start": {
                "line": 80,
                "column": 4
              },
              "end": {
                "line": 93,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Confirmation status.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "dataHash Data hash.",
                  "subAnnotation": {
                    "name": "dataHash",
                    "value": "Data hash.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns if Safe transaction is a valid owner replacement transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getDataHash",
              "params": [
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "pure"
              ],
              "source": "function getDataHash(bytes memory data)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(data);\n    }",
              "start": {
                "line": 98,
                "column": 4
              },
              "end": {
                "line": 104,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Data hash.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "data Data payload.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns hash of data encoding owner replacement.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Social Recovery Module - Allows to replace an owner without Safe confirmations if friends approve the replacement.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [
            {
              "name": "onlyFriend",
              "params": []
            }
          ],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "manager",
              "solidityType": {
                "name": "ModuleManager",
                "userDefined": true,
                "references": [
                  "ModuleManager"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "manager",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "ModuleManager",
                      "userDefined": true,
                      "references": [
                        "ModuleManager"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "setManager",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Social Recovery Module - Allows to replace an owner without Safe confirmations if friends approve the replacement.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract SocialRecoveryModule is Module {\n\n    string public constant NAME = \"Social Recovery Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    uint256 public threshold;\n    address[] public friends;\n\n    // isFriend mapping maps friend's address to friend status.\n    mapping (address => bool) public isFriend;\n    // isExecuted mapping maps data hash to execution status.\n    mapping (bytes32 => bool) public isExecuted;\n    // isConfirmed mapping maps data hash to friend's address to confirmation status.\n    mapping (bytes32 => mapping (address => bool)) public isConfirmed;\n\n    modifier onlyFriend() {\n        require(isFriend[msg.sender], \"Method can only be called by a friend\");\n        _;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _friends List of friends' addresses.\n    /// @param _threshold Required number of friends to confirm replacement.\n    function setup(address[] memory _friends, uint256 _threshold)\n        public\n    {\n        require(_threshold <= _friends.length, \"Threshold cannot exceed friends count\");\n        require(_threshold >= 2, \"At least 2 friends required\");\n        setManager();\n        // Set allowed friends.\n        for (uint256 i = 0; i < _friends.length; i++) {\n            address friend = _friends[i];\n            require(friend != address(0), \"Invalid friend address provided\");\n            require(!isFriend[friend], \"Duplicate friend address provided\");\n            isFriend[friend] = true;\n        }\n        friends = _friends;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows a friend to confirm a Safe transaction.\n    /// @param dataHash Safe transaction hash.\n    function confirmTransaction(bytes32 dataHash)\n        public\n        onlyFriend\n    {\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        isConfirmed[dataHash][msg.sender] = true;\n    }\n\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    /// @return Returns if transaction can be executed.\n    function recoverAccess(address prevOwner, address oldOwner, address newOwner)\n        public\n        onlyFriend\n    {\n        bytes memory data = abi.encodeWithSignature(\"swapOwner(address,address,address)\", prevOwner, oldOwner, newOwner);\n        bytes32 dataHash = getDataHash(data);\n        require(!isExecuted[dataHash], \"Recovery already executed\");\n        require(isConfirmedByRequiredFriends(dataHash), \"Recovery has not enough confirmations\");\n        isExecuted[dataHash] = true;\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \"Could not execute recovery\");\n    }\n\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\n    /// @param dataHash Data hash.\n    /// @return Confirmation status.\n    function isConfirmedByRequiredFriends(bytes32 dataHash)\n        public\n        view\n        returns (bool)\n    {\n        uint256 confirmationCount;\n        for (uint256 i = 0; i < friends.length; i++) {\n            if (isConfirmed[dataHash][friends[i]])\n                confirmationCount++;\n            if (confirmationCount == threshold)\n                return true;\n        }\n        return false;\n    }\n\n    /// @dev Returns hash of data encoding owner replacement.\n    /// @param data Data payload.\n    /// @return Data hash.\n    function getDataHash(bytes memory data)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(data);\n    }\n}\n",
          "inFile": "SocialRecoveryModule.sol",
          "references": [
            "Module"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 770
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2",
          "z": 29,
          "attrs": {
            "text": {
              "text": "SocialRecoveryM...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "933bc83b-84a7-4804-90a1-a92c0eedc3f2"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "7b73ebee-0f22-4d89-9496-6cba1bf2180c",
            "z": -18,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "StateChannelModule",
          "baseContracts": [
            "Module",
            "SignatureDecoder"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "isExecuted",
              "solidityType": {
                "name": "(bytes32 => uint256)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "isExecuted",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "uint256",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setup",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function setup()\n        public\n    {\n        setManager();\n    }",
              "start": {
                "line": 20,
                "column": 4
              },
              "end": {
                "line": 24,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Setup function sets manager",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "execTransaction",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address of Safe transaction."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value of Safe transaction."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload of Safe transaction."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type of Safe transaction."
                },
                {
                  "name": "nonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Nonce used for this Safe transaction."
                },
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce,\n        bytes memory signatures\n    )\n        public\n    {\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\n        require(isExecuted[transactionHash] == 0, \"Transaction already executed\");\n        checkHash(transactionHash, signatures);\n        // Mark as executed and execute transaction.\n        isExecuted[transactionHash] = 1;\n        require(manager.execTransactionFromModule(to, value, data, operation), \"Could not execute transaction\");\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 49,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "nonce Nonce used for this Safe transaction.",
                  "subAnnotation": {
                    "name": "nonce",
                    "value": "Nonce used for this Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "operation Operation type of Safe transaction.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload of Safe transaction.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value of Safe transaction.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address of Safe transaction.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address of Safe transaction.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to execute a Safe transaction confirmed by required number of owners.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "checkHash",
              "params": [
                {
                  "name": "transactionHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                "view"
              ],
              "source": "function checkHash(bytes32 transactionHash, bytes memory signatures)\n        internal\n        view\n    {\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 i;\n        uint256 threshold = OwnerManager(address(manager)).getThreshold();\n        // Validate threshold is reached.\n        for (i = 0; i < threshold; i++) {\n            currentOwner = recoverKey(transactionHash, signatures, i);\n            require(OwnerManager(address(manager)).isOwner(currentOwner), \"Signature not provided by owner\");\n            require(currentOwner > lastOwner, \"Signatures are not ordered by owner address\");\n            lastOwner = currentOwner;\n        }\n    }",
              "start": {
                "line": 51,
                "column": 4
              },
              "end": {
                "line": 67,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "getTransactionHash",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Ether value."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data payload."
                },
                {
                  "name": "operation",
                  "solidityType": {
                    "name": "Enum.Operation",
                    "userDefined": true,
                    "references": [
                      "Enum.Operation"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Operation type."
                },
                {
                  "name": "nonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Transaction nonce."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\n    }",
              "start": {
                "line": 76,
                "column": 4
              },
              "end": {
                "line": 88,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Transaction hash.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "nonce Transaction nonce.",
                  "subAnnotation": {
                    "name": "nonce",
                    "value": "Transaction nonce.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "operation Operation type.",
                  "subAnnotation": {
                    "name": "operation",
                    "value": "Operation type.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "data Data payload.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Data payload.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Ether value.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Ether value.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Destination address.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns hash to be signed by owners.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Gnosis Safe State Module - A module that allows interaction with statechannels.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "manager",
              "solidityType": {
                "name": "ModuleManager",
                "userDefined": true,
                "references": [
                  "ModuleManager"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "manager",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "ModuleManager",
                      "userDefined": true,
                      "references": [
                        "ModuleManager"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "setManager",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "recoverKey",
              "params": [
                {
                  "name": "messageHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "operation ethereum signed message hash"
                },
                {
                  "name": "messageSignature",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "message `txHash` signature"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
              "start": {
                "line": 13,
                "column": 4
              },
              "end": {
                "line": 27,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "pos which signature to read",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageSignature message `txHash` signature",
                  "subAnnotation": {
                    "name": "messageSignature",
                    "value": "message `txHash` signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "messageHash operation ethereum signed message hash",
                  "subAnnotation": {
                    "name": "messageHash",
                    "value": "operation ethereum signed message hash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Recovers address who signed the message",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "signatureSplit",
              "params": [
                {
                  "name": "signatures",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "concatenated rsv signatures"
                },
                {
                  "name": "pos",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
                }
              ],
              "returnParams": [
                {
                  "name": "v",
                  "solidityType": {
                    "name": "uint8",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "r",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "s",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 53,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "signatures concatenated rsv signatures",
                  "subAnnotation": {
                    "name": "signatures",
                    "value": "concatenated rsv signatures",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                  "subAnnotation": {
                    "name": "pos",
                    "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\nimport \"../common/SignatureDecoder.sol\";\n\n\n/// @title Gnosis Safe State Module - A module that allows interaction with statechannels.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract StateChannelModule is Module, SignatureDecoder {\n\n    string public constant NAME = \"State Channel Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // isExecuted mapping allows to check if a transaction (by hash) was already executed.\n    mapping (bytes32 => uint256) public isExecuted;\n\n    /// @dev Setup function sets manager\n    function setup()\n        public\n    {\n        setManager();\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param nonce Nonce used for this Safe transaction.\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce,\n        bytes memory signatures\n    )\n        public\n    {\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\n        require(isExecuted[transactionHash] == 0, \"Transaction already executed\");\n        checkHash(transactionHash, signatures);\n        // Mark as executed and execute transaction.\n        isExecuted[transactionHash] = 1;\n        require(manager.execTransactionFromModule(to, value, data, operation), \"Could not execute transaction\");\n    }\n\n    function checkHash(bytes32 transactionHash, bytes memory signatures)\n        internal\n        view\n    {\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 i;\n        uint256 threshold = OwnerManager(address(manager)).getThreshold();\n        // Validate threshold is reached.\n        for (i = 0; i < threshold; i++) {\n            currentOwner = recoverKey(transactionHash, signatures, i);\n            require(OwnerManager(address(manager)).isOwner(currentOwner), \"Signature not provided by owner\");\n            require(currentOwner > lastOwner, \"Signatures are not ordered by owner address\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\n    }\n}\n",
          "inFile": "StateChannelModule.sol",
          "references": [
            "Module",
            "SignatureDecoder",
            "Enum.Operation"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 840
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "45924732-643e-4d8f-b171-5a9bd610a158",
          "z": 30,
          "attrs": {
            "text": {
              "text": "StateChannelModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "45924732-643e-4d8f-b171-5a9bd610a158"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "6ba5cc5c-4e42-408c-ba00-b9ecb2d347cd",
            "z": -19,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "45924732-643e-4d8f-b171-5a9bd610a158"
            },
            "target": {
              "id": "7bb2c0fb-a037-473a-ac6a-ce8029d1e7b3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "9c321eca-d2d7-4a1d-aa11-4dd482e423d8",
            "z": -20,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "WhitelistModule",
          "baseContracts": [
            "Module"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "NAME",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "NAME",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "string",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "isWhitelisted",
              "solidityType": {
                "name": "(address => bool)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "isWhitelisted",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bool",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "setup",
              "params": [
                {
                  "name": "accounts",
                  "solidityType": {
                    "name": "address[]",
                    "pureName": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "List of whitelisted accounts."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function setup(address[] memory accounts)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Invalid account provided\");\n            isWhitelisted[account] = true;\n        }\n    }",
              "start": {
                "line": 20,
                "column": 4
              },
              "end": {
                "line": 29,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "accounts List of whitelisted accounts.",
                  "subAnnotation": {
                    "name": "accounts",
                    "value": "List of whitelisted accounts.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Setup function sets initial storage of contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "addToWhitelist",
              "params": [
                {
                  "name": "account",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function addToWhitelist(address account)\n        public\n        authorized\n    {\n        require(account != address(0), \"Invalid account provided\");\n        require(!isWhitelisted[account], \"Account is already whitelisted\");\n        isWhitelisted[account] = true;\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 40,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "account Destination address.",
                  "subAnnotation": {
                    "name": "account",
                    "value": "Destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to add destination to whitelist. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "removeFromWhitelist",
              "params": [
                {
                  "name": "account",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Destination address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function removeFromWhitelist(address account)\n        public\n        authorized\n    {\n        require(isWhitelisted[account], \"Account is not whitelisted\");\n        isWhitelisted[account] = false;\n    }",
              "start": {
                "line": 44,
                "column": 4
              },
              "end": {
                "line": 50,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "account Destination address.",
                  "subAnnotation": {
                    "name": "account",
                    "value": "Destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to remove destination from whitelist. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "executeWhitelisted",
              "params": [
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Whitelisted destination address."
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Not checked."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Not checked."
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function executeWhitelisted(address to, uint256 value, bytes memory data)\n        public\n        returns (bool)\n    {\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(isWhitelisted[to], \"Target account is not whitelisted\");\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \"Could not execute transaction\");\n    }",
              "start": {
                "line": 57,
                "column": 4
              },
              "end": {
                "line": 65,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "Returns if transaction can be executed.",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "data Not checked.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Not checked.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "value Not checked.",
                  "subAnnotation": {
                    "name": "value",
                    "value": "Not checked.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "to Whitelisted destination address.",
                  "subAnnotation": {
                    "name": "to",
                    "value": "Whitelisted destination address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Returns if Safe transaction is to a whitelisted destination.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Whitelist Module - Allows to execute transactions to whitelisted addresses without confirmations.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "manager",
              "solidityType": {
                "name": "ModuleManager",
                "userDefined": true,
                "references": [
                  "ModuleManager"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "manager",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "ModuleManager",
                      "userDefined": true,
                      "references": [
                        "ModuleManager"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "private",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "setManager",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function setManager()\n        internal\n    {\n        // manager can only be 0 at initalization of contract.\n        // Check ensures that setup function can only be called once.\n        require(address(manager) == address(0), \"Manager has already been set\");\n        manager = ModuleManager(msg.sender);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": []
            },
            {
              "name": "changeMasterCopy",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "New contract address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "authorized",
                "public",
                null
              ],
              "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
              "start": {
                "line": 18,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy New contract address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "New contract address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [
            {
              "name": "ChangedMasterCopy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "inheritedModifiers": [
            {
              "name": "authorized",
              "params": []
            }
          ],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../base/Module.sol\";\nimport \"../base/ModuleManager.sol\";\nimport \"../base/OwnerManager.sol\";\nimport \"../common/Enum.sol\";\n\n\n/// @title Whitelist Module - Allows to execute transactions to whitelisted addresses without confirmations.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract WhitelistModule is Module {\n\n    string public constant NAME = \"Whitelist Module\";\n    string public constant VERSION = \"0.1.0\";\n\n    // isWhitelisted mapping maps destination address to boolean.\n    mapping (address => bool) public isWhitelisted;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param accounts List of whitelisted accounts.\n    function setup(address[] memory accounts)\n        public\n    {\n        setManager();\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Invalid account provided\");\n            isWhitelisted[account] = true;\n        }\n    }\n\n    /// @dev Allows to add destination to whitelist. This can only be done via a Safe transaction.\n    /// @param account Destination address.\n    function addToWhitelist(address account)\n        public\n        authorized\n    {\n        require(account != address(0), \"Invalid account provided\");\n        require(!isWhitelisted[account], \"Account is already whitelisted\");\n        isWhitelisted[account] = true;\n    }\n\n    /// @dev Allows to remove destination from whitelist. This can only be done via a Safe transaction.\n    /// @param account Destination address.\n    function removeFromWhitelist(address account)\n        public\n        authorized\n    {\n        require(isWhitelisted[account], \"Account is not whitelisted\");\n        isWhitelisted[account] = false;\n    }\n\n    /// @dev Returns if Safe transaction is to a whitelisted destination.\n    /// @param to Whitelisted destination address.\n    /// @param value Not checked.\n    /// @param data Not checked.\n    /// @return Returns if transaction can be executed.\n    function executeWhitelisted(address to, uint256 value, bytes memory data)\n        public\n        returns (bool)\n    {\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\n        require(isWhitelisted[to], \"Target account is not whitelisted\");\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \"Could not execute transaction\");\n    }\n}\n",
          "inFile": "WhitelistModule.sol",
          "references": [
            "Module"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 910
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "d107d7b8-6f11-462c-81e7-0af23fd91990",
          "z": 31,
          "attrs": {
            "text": {
              "text": "WhitelistModule",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "d107d7b8-6f11-462c-81e7-0af23fd91990"
            },
            "target": {
              "id": "015b9a94-7f26-414a-9771-86532deeb9c3"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "eafcf5d6-c602-4da7-be9e-41b0a2045342",
            "z": -21,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "DelegateConstructorProxy",
          "baseContracts": [
            "Proxy"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "constructor",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Master copy address."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data used for a delegate call to initialize the contract."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "Proxy",
                "public",
                null
              ],
              "source": "constructor(address _masterCopy, bytes memory initializer) Proxy(_masterCopy)\n        public\n    {\n        if (initializer.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n                let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0)\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if eq(success, 0) { revert(ptr, returndatasize()) }\n            }\n        }\n    }",
              "start": {
                "line": 13,
                "column": 4
              },
              "end": {
                "line": 26,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "initializer Data used for a delegate call to initialize the contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Data used for a delegate call to initialize the contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_masterCopy Master copy address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "Master copy address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Constructor function sets address of master copy contract.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Delegate Constructor Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
              "start": {
                "line": 28,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Fallback function forwards all transactions and returns all received return data.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./Proxy.sol\";\n\n\n/// @title Delegate Constructor Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract DelegateConstructorProxy is Proxy {\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    /// @param initializer Data used for a delegate call to initialize the contract.\n    constructor(address _masterCopy, bytes memory initializer) Proxy(_masterCopy)\n        public\n    {\n        if (initializer.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n                let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0)\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if eq(success, 0) { revert(ptr, returndatasize()) }\n            }\n        }\n    }\n}\n",
          "inFile": "DelegateConstructorProxy.sol",
          "references": [
            "Proxy"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 600,
            "y": 1055
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e4aee160-ed8b-46d5-a867-51fb2046842f",
          "z": 32,
          "attrs": {
            "text": {
              "text": "DelegateConstru...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
            },
            "target": {
              "id": "b080fa79-a897-4295-b81a-77dd3912cb39"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fd18e748-8916-4f84-9bed-26a9c5a710b6",
            "z": -22,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
            },
            "target": {
              "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "861cba65-af9a-4f07-bec6-d833225df9d2",
            "z": -23,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "IProxyCreationCallback",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "proxyCreated",
              "params": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "_mastercopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "saltNonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function proxyCreated(Proxy proxy, address _mastercopy, bytes calldata initializer, uint256 saltNonce) external;",
              "start": {
                "line": 5,
                "column": 4
              },
              "end": {
                "line": 5,
                "column": 115
              },
              "annotations": []
            }
          ],
          "annotations": [],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity ^0.5.3;\nimport \"./Proxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(Proxy proxy, address _mastercopy, bytes calldata initializer, uint256 saltNonce) external;\n}\n",
          "inFile": "IProxyCreationCallback.sol",
          "references": [
            "Proxy"
          ],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 770
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "d369ab14-2179-48e1-9fa2-1b553078108f",
          "z": 33,
          "attrs": {
            "text": {
              "text": "IProxyCreationC...",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "PayingProxy",
          "baseContracts": [
            "DelegateConstructorProxy",
            "SecuredTokenTransfer"
          ],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "constructor",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Master copy address."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Data used for a delegate call to initialize the contract."
                },
                {
                  "name": "funder",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address that should be paid for the execution of this call"
                },
                {
                  "name": "paymentToken",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token that should be used for the payment (0 is ETH)"
                },
                {
                  "name": "payment",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Value that should be paid"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "DelegateConstructorProxy",
                "public",
                null
              ],
              "source": "constructor(address _masterCopy, bytes memory initializer, address payable funder, address paymentToken, uint256 payment)\n        DelegateConstructorProxy(_masterCopy, initializer)\n        public\n    {\n        if (payment > 0) {\n            if (paymentToken == address(0)) {\n                 // solium-disable-next-line security/no-send\n                require(funder.send(payment), \"Could not pay safe creation with ether\");\n            } else {\n                require(transferToken(paymentToken, funder, payment), \"Could not pay safe creation with token\");\n            }\n        }\n    }",
              "start": {
                "line": 16,
                "column": 4
              },
              "end": {
                "line": 28,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "payment Value that should be paid",
                  "subAnnotation": {
                    "name": "payment",
                    "value": "Value that should be paid",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "paymentToken Token that should be used for the payment (0 is ETH)",
                  "subAnnotation": {
                    "name": "paymentToken",
                    "value": "Token that should be used for the payment (0 is ETH)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "funder Address that should be paid for the execution of this call",
                  "subAnnotation": {
                    "name": "funder",
                    "value": "Address that should be paid for the execution of this call",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "initializer Data used for a delegate call to initialize the contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Data used for a delegate call to initialize the contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_masterCopy Master copy address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "Master copy address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Constructor function sets address of master copy contract.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Paying Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor. And sends funds after creation to a specified account.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": false,
          "inheritedStateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "inheritedFunctions": [
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
              "start": {
                "line": 28,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Fallback function forwards all transactions and returns all received return data.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transferToken",
              "params": [
                {
                  "name": "token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Token that should be transferred"
                },
                {
                  "name": "receiver",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Receiver to whom the token should be transferred"
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "The amount of tokens that should be transferred"
                }
              ],
              "returnParams": [
                {
                  "name": "transferred",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
              "start": {
                "line": 12,
                "column": 4
              },
              "end": {
                "line": 32,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "amount The amount of tokens that should be transferred",
                  "subAnnotation": {
                    "name": "amount",
                    "value": "The amount of tokens that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "receiver Receiver to whom the token should be transferred",
                  "subAnnotation": {
                    "name": "receiver",
                    "value": "Receiver to whom the token should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "token Token that should be transferred",
                  "subAnnotation": {
                    "name": "token",
                    "value": "Token that should be transferred",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Transfers a token and returns if it was a success",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"../common/SecuredTokenTransfer.sol\";\nimport \"./DelegateConstructorProxy.sol\";\n\n/// @title Paying Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor. And sends funds after creation to a specified account.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract PayingProxy is DelegateConstructorProxy, SecuredTokenTransfer {\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    /// @param initializer Data used for a delegate call to initialize the contract.\n    /// @param funder Address that should be paid for the execution of this call\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    constructor(address _masterCopy, bytes memory initializer, address payable funder, address paymentToken, uint256 payment)\n        DelegateConstructorProxy(_masterCopy, initializer)\n        public\n    {\n        if (payment > 0) {\n            if (paymentToken == address(0)) {\n                 // solium-disable-next-line security/no-send\n                require(funder.send(payment), \"Could not pay safe creation with ether\");\n            } else {\n                require(transferToken(paymentToken, funder, payment), \"Could not pay safe creation with token\");\n            }\n        }\n    }\n}\n",
          "inFile": "PayingProxy.sol",
          "references": [
            "DelegateConstructorProxy",
            "SecuredTokenTransfer"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 400,
            "y": 995
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c85b0602-8bc2-469c-b28f-a6f82a184253",
          "z": 34,
          "attrs": {
            "text": {
              "text": "PayingProxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
            },
            "target": {
              "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "861cba65-af9a-4f07-bec6-d833225df9d2",
            "z": -23,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "c85b0602-8bc2-469c-b28f-a6f82a184253"
            },
            "target": {
              "id": "cf2c8b6b-b3cc-4be5-b2e0-75b587c6ade1"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fe7c746a-a0ab-4efd-8f5d-621c22f11775",
            "z": -24,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "IProxy",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "masterCopy",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function masterCopy() external view returns (address);",
              "start": {
                "line": 6,
                "column": 4
              },
              "end": {
                "line": 6,
                "column": 57
              },
              "annotations": []
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "IProxy - Helper interface to access masterCopy of the Proxy on-chain",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Proxy {\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal masterCopy;\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n",
          "inFile": "Proxy.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 840
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "c08a9573-24c0-4444-9d51-f5404f8ffe54",
          "z": 35,
          "attrs": {
            "text": {
              "text": "IProxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "Proxy",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "masterCopy",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "masterCopy",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [
                {
                  "name": "_masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Master copy address."
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }",
              "start": {
                "line": 20,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_masterCopy Master copy address.",
                  "subAnnotation": {
                    "name": "_masterCopy",
                    "value": "Master copy address.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Constructor function sets address of master copy contract.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "external",
                "payable"
              ],
              "source": "function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }",
              "start": {
                "line": 28,
                "column": 4
              },
              "end": {
                "line": 46,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Fallback function forwards all transactions and returns all received return data.",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Richard Meissner - <richard@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.io>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.",
              "subAnnotation": null
            }
          ],
          "deployedAt": null,
          "meta": null,
          "modifiers": [],
          "events": [],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity >=0.5.0 <0.7.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Proxy {\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal masterCopy;\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function ()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, masterCopy)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n",
          "inFile": "Proxy.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 800,
            "y": 1055
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "b080fa79-a897-4295-b81a-77dd3912cb39",
          "z": 36,
          "attrs": {
            "text": {
              "text": "Proxy",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [
          {
            "type": "link",
            "source": {
              "id": "e4aee160-ed8b-46d5-a867-51fb2046842f"
            },
            "target": {
              "id": "b080fa79-a897-4295-b81a-77dd3912cb39"
            },
            "router": {
              "name": "manhattan"
            },
            "connector": {
              "name": "normal"
            },
            "id": "fd18e748-8916-4f84-9bed-26a9c5a710b6",
            "z": -22,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "ProxyFactory",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "createProxy",
              "params": [
                {
                  "name": "masterCopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of master copy."
                },
                {
                  "name": "data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Payload for message call sent to new proxy contract."
                }
              ],
              "returnParams": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }",
              "start": {
                "line": 14,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "data Payload for message call sent to new proxy contract.",
                  "subAnnotation": {
                    "name": "data",
                    "value": "Payload for message call sent to new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "masterCopy Address of master copy.",
                  "subAnnotation": {
                    "name": "masterCopy",
                    "value": "Address of master copy.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "proxyRuntimeCode",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "pure"
              ],
              "source": "function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(Proxy).runtimeCode;\n    }",
              "start": {
                "line": 28,
                "column": 4
              },
              "end": {
                "line": 30,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "proxyCreationCode",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "pure"
              ],
              "source": "function proxyCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }",
              "start": {
                "line": 33,
                "column": 4
              },
              "end": {
                "line": 35,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "deployProxyWithNonce",
              "params": [
                {
                  "name": "_mastercopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of master copy."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Payload for message call sent to new proxy contract."
                },
                {
                  "name": "saltNonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
                }
              ],
              "returnParams": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function deployProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        internal\n        returns (Proxy proxy)\n    {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }",
              "start": {
                "line": 42,
                "column": 4
              },
              "end": {
                "line": 54,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                  "subAnnotation": {
                    "name": "saltNonce",
                    "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "initializer Payload for message call sent to new proxy contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Payload for message call sent to new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_mastercopy Address of master copy.",
                  "subAnnotation": {
                    "name": "_mastercopy",
                    "value": "Address of master copy.",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "createProxyWithNonce",
              "params": [
                {
                  "name": "_mastercopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of master copy."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Payload for message call sent to new proxy contract."
                },
                {
                  "name": "saltNonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
                }
              ],
              "returnParams": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\n            }\n        emit ProxyCreation(proxy);\n    }",
              "start": {
                "line": 60,
                "column": 4
              },
              "end": {
                "line": 71,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                  "subAnnotation": {
                    "name": "saltNonce",
                    "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "initializer Payload for message call sent to new proxy contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Payload for message call sent to new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_mastercopy Address of master copy.",
                  "subAnnotation": {
                    "name": "_mastercopy",
                    "value": "Address of master copy.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "createProxyWithCallback",
              "params": [
                {
                  "name": "_mastercopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of master copy."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Payload for message call sent to new proxy contract."
                },
                {
                  "name": "saltNonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
                },
                {
                  "name": "callback",
                  "solidityType": {
                    "name": "IProxyCreationCallback",
                    "userDefined": true,
                    "references": [
                      "IProxyCreationCallback"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Callback that will be invoced after the new proxy contract has been successfully deployed and initialized."
                }
              ],
              "returnParams": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "function createProxyWithCallback(address _mastercopy, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback)\n        public\n        returns (Proxy proxy)\n    {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_mastercopy, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0))\n            callback.proxyCreated(proxy, _mastercopy, initializer, saltNonce);\n    }",
              "start": {
                "line": 78,
                "column": 4
              },
              "end": {
                "line": 86,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.",
                  "subAnnotation": {
                    "name": "callback",
                    "value": "Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                  "subAnnotation": {
                    "name": "saltNonce",
                    "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "initializer Payload for message call sent to new proxy contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Payload for message call sent to new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_mastercopy Address of master copy.",
                  "subAnnotation": {
                    "name": "_mastercopy",
                    "value": "Address of master copy.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "calculateCreateProxyWithNonceAddress",
              "params": [
                {
                  "name": "_mastercopy",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Address of master copy."
                },
                {
                  "name": "initializer",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "Payload for message call sent to new proxy contract."
                },
                {
                  "name": "saltNonce",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract."
                }
              ],
              "returnParams": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function calculateCreateProxyWithNonceAddress(address _mastercopy, bytes calldata initializer, uint256 saltNonce)\n        external\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }",
              "start": {
                "line": 94,
                "column": 4
              },
              "end": {
                "line": 100,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                  "subAnnotation": {
                    "name": "saltNonce",
                    "value": "Nonce that will be used to generate the salt to calculate the address of the new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "initializer Payload for message call sent to new proxy contract.",
                  "subAnnotation": {
                    "name": "initializer",
                    "value": "Payload for message call sent to new proxy contract.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_mastercopy Address of master copy.",
                  "subAnnotation": {
                    "name": "_mastercopy",
                    "value": "Address of master copy.",
                    "subAnnotation": null
                  }
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "author",
              "value": "Stefan George - <stefan@gnosis.pm>",
              "subAnnotation": null
            },
            {
              "name": "title",
              "value": "Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "ProxyCreation",
              "params": [
                {
                  "name": "proxy",
                  "solidityType": {
                    "name": "Proxy",
                    "userDefined": true,
                    "references": [
                      "Proxy"
                    ],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity ^0.5.3;\nimport \"./Proxy.sol\";\nimport \"./IProxyCreationCallback.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract ProxyFactory {\n\n    event ProxyCreation(Proxy proxy);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(Proxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        internal\n        returns (Proxy proxy)\n    {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(address _mastercopy, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback)\n        public\n        returns (Proxy proxy)\n    {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_mastercopy, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0))\n            callback.proxyCreated(proxy, _mastercopy, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(address _mastercopy, bytes calldata initializer, uint256 saltNonce)\n        external\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n\n}\n",
          "inFile": "ProxyFactory.sol",
          "references": [
            "Proxy",
            "IProxyCreationCallback"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 910
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "75e839a8-b9c1-4f39-9c0b-66290fac8e5c",
          "z": 37,
          "attrs": {
            "text": {
              "text": "ProxyFactory",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      }
    ]
  },
  "selectedElement": {
    "elementType": 0,
    "name": "GnosisSafe",
    "baseContracts": [
      "MasterCopy",
      "ModuleManager",
      "OwnerManager",
      "SignatureDecoder",
      "SecuredTokenTransfer",
      "ISignatureValidatorConstants",
      "FallbackManager"
    ],
    "enumerations": [],
    "structs": [],
    "stateVariables": [
      {
        "name": "NAME",
        "solidityType": {
          "name": "string",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "NAME",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "VERSION",
        "solidityType": {
          "name": "string",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "VERSION",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "DOMAIN_SEPARATOR_TYPEHASH",
        "solidityType": {
          "name": "bytes32",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "private",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "DOMAIN_SEPARATOR_TYPEHASH",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "SAFE_TX_TYPEHASH",
        "solidityType": {
          "name": "bytes32",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "private",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "SAFE_TX_TYPEHASH",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "SAFE_MSG_TYPEHASH",
        "solidityType": {
          "name": "bytes32",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "private",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "SAFE_MSG_TYPEHASH",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "nonce",
        "solidityType": {
          "name": "uint256",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "nonce",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "domainSeparator",
        "solidityType": {
          "name": "bytes32",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "domainSeparator",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "signedMessages",
        "solidityType": {
          "name": "(bytes32 => uint256)",
          "mapping": {
            "key": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "value": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            }
          },
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "signedMessages",
          "params": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null,
              "lastType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            }
          ],
          "returnParams": [
            {
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "approvedHashes",
        "solidityType": {
          "name": "(address => (bytes32 => uint256))",
          "mapping": {
            "key": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "value": {
              "name": "(bytes32 => uint256)",
              "mapping": {
                "key": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "value": {
                  "name": "uint256",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              "userDefined": false,
              "references": [],
              "isArray": false
            }
          },
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "approvedHashes",
          "params": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null,
              "lastType": {
                "name": "(bytes32 => uint256)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null,
              "lastType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            }
          ],
          "returnParams": [
            {
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      }
    ],
    "functions": [
      {
        "name": "constructor",
        "params": [],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "public",
          null
        ],
        "source": "constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }",
        "start": {
          "line": 60,
          "column": 4
        },
        "end": {
          "line": 65,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "setup",
        "params": [
          {
            "name": "_owners",
            "solidityType": {
              "name": "address[]",
              "pureName": "address",
              "userDefined": false,
              "references": [],
              "isArray": true
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "List of Safe owners."
          },
          {
            "name": "_threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Number of required confirmations for a Safe transaction."
          },
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Contract address for optional delegate call."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload for optional delegate call."
          },
          {
            "name": "fallbackHandler",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Handler for fallback calls to this contract"
          },
          {
            "name": "paymentToken",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Token that should be used for the payment (0 is ETH)"
          },
          {
            "name": "payment",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Value that should be paid"
          },
          {
            "name": "paymentReceiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Adddress that should receive the payment (or 0 if tx.origin)"
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "external",
          null
        ],
        "source": "function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }",
        "start": {
          "line": 76,
          "column": 4
        },
        "end": {
          "line": 100,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)",
            "subAnnotation": {
              "name": "paymentReceiver",
              "value": "Adddress that should receive the payment (or 0 if tx.origin)",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "payment Value that should be paid",
            "subAnnotation": {
              "name": "payment",
              "value": "Value that should be paid",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "paymentToken Token that should be used for the payment (0 is ETH)",
            "subAnnotation": {
              "name": "paymentToken",
              "value": "Token that should be used for the payment (0 is ETH)",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "fallbackHandler Handler for fallback calls to this contract",
            "subAnnotation": {
              "name": "fallbackHandler",
              "value": "Handler for fallback calls to this contract",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload for optional delegate call.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload for optional delegate call.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Contract address for optional delegate call.",
            "subAnnotation": {
              "name": "to",
              "value": "Contract address for optional delegate call.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_threshold Number of required confirmations for a Safe transaction.",
            "subAnnotation": {
              "name": "_threshold",
              "value": "Number of required confirmations for a Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_owners List of Safe owners.",
            "subAnnotation": {
              "name": "_owners",
              "value": "List of Safe owners.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Setup function sets initial storage of contract.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "execTransaction",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address of Safe transaction."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value of Safe transaction."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload of Safe transaction."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type of Safe transaction."
          },
          {
            "name": "safeTxGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Gas that should be used for the Safe transaction."
          },
          {
            "name": "baseGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)"
          },
          {
            "name": "gasPrice",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Gas price that should be used for the payment calculation."
          },
          {
            "name": "gasToken",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Token address (or 0 if ETH) that is used for the payment."
          },
          {
            "name": "refundReceiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Address of receiver of gas payment (or 0 if tx.origin)."
          },
          {
            "name": "signatures",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})"
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "external",
          null
        ],
        "source": "function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }",
        "start": {
          "line": 114,
          "column": 4
        },
        "end": {
          "line": 157,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
            "subAnnotation": {
              "name": "signatures",
              "value": "Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
            "subAnnotation": {
              "name": "refundReceiver",
              "value": "Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
            "subAnnotation": {
              "name": "gasToken",
              "value": "Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasPrice Gas price that should be used for the payment calculation.",
            "subAnnotation": {
              "name": "gasPrice",
              "value": "Gas price that should be used for the payment calculation.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
            "subAnnotation": {
              "name": "baseGas",
              "value": "Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "safeTxGas Gas that should be used for the Safe transaction.",
            "subAnnotation": {
              "name": "safeTxGas",
              "value": "Gas that should be used for the Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "operation Operation type of Safe transaction.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload of Safe transaction.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value of Safe transaction.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address of Safe transaction.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address of Safe transaction.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "handlePayment",
        "params": [
          {
            "name": "gasUsed",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "baseGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "gasPrice",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "gasToken",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "refundReceiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [
          {
            "name": "payment",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "private",
          null
        ],
        "source": "function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }",
        "start": {
          "line": 159,
          "column": 4
        },
        "end": {
          "line": 180,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "checkSignatures",
        "params": [
          {
            "name": "dataHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Hash of the data (could be either a message hash or transaction hash)"
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "That should be signed (this is passed to an external validator contract)"
          },
          {
            "name": "signatures",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash."
          },
          {
            "name": "consumeHash",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Indicates that in case of an approved hash the storage can be freed to save gas"
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }",
        "start": {
          "line": 189,
          "column": 4
        },
        "end": {
          "line": 259,
          "column": 4
        },
        "annotations": [
          {
            "name": "*",
            "value": "*/",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "consumeHash Indicates that in case of an approved hash the storage can be freed to save gas",
            "subAnnotation": {
              "name": "consumeHash",
              "value": "Indicates that in case of an approved hash the storage can be freed to save gas",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
            "subAnnotation": {
              "name": "signatures",
              "value": "Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data That should be signed (this is passed to an external validator contract)",
            "subAnnotation": {
              "name": "data",
              "value": "That should be signed (this is passed to an external validator contract)",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "dataHash Hash of the data (could be either a message hash or transaction hash)",
            "subAnnotation": {
              "name": "dataHash",
              "value": "Hash of the data (could be either a message hash or transaction hash)",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.",
            "subAnnotation": null
          },
          {
            "name": "/*",
            "value": "/**",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "requiredTxGas",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address of Safe transaction."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value of Safe transaction."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload of Safe transaction."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type of Safe transaction."
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "authorized",
          "external",
          null
        ],
        "source": "function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }",
        "start": {
          "line": 272,
          "column": 4
        },
        "end": {
          "line": 284,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Estimate without refunds and overhead fees (base transaction and payload data gas costs).",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "operation Operation type of Safe transaction.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload of Safe transaction.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value of Safe transaction.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value of Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address of Safe transaction.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address of Safe transaction.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "approveHash",
        "params": [
          {
            "name": "hashToApprove",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "The hash that should be marked as approved for signatures that are verified by this contract."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "external",
          null
        ],
        "source": "function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }",
        "start": {
          "line": 290,
          "column": 4
        },
        "end": {
          "line": 296,
          "column": 4
        },
        "annotations": [
          {
            "name": "*",
            "value": "*/",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.",
            "subAnnotation": {
              "name": "hashToApprove",
              "value": "The hash that should be marked as approved for signatures that are verified by this contract.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Marks a hash as approved. This can be used to validate a hash that is used by a signature.",
            "subAnnotation": null
          },
          {
            "name": "/*",
            "value": "/**",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "signMessage",
        "params": [
          {
            "name": "_data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Arbitrary length data that should be marked as signed on the behalf of address(this)"
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "external",
          null
        ],
        "source": "function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }",
        "start": {
          "line": 302,
          "column": 4
        },
        "end": {
          "line": 309,
          "column": 4
        },
        "annotations": [
          {
            "name": "*",
            "value": "*/",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_data Arbitrary length data that should be marked as signed on the behalf of address(this)",
            "subAnnotation": {
              "name": "_data",
              "value": "Arbitrary length data that should be marked as signed on the behalf of address(this)",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Marks a message as signed",
            "subAnnotation": null
          },
          {
            "name": "/*",
            "value": "/**",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "isValidSignature",
        "params": [
          {
            "name": "_data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Arbitrary length data signed on the behalf of address(this)"
          },
          {
            "name": "_signature",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Signature byte array associated with _data"
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "bytes4",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "external",
          null
        ],
        "source": "function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }",
        "start": {
          "line": 320,
          "column": 4
        },
        "end": {
          "line": 332,
          "column": 4
        },
        "annotations": [
          {
            "name": "*",
            "value": "*/",
            "subAnnotation": null
          },
          {
            "name": "return",
            "value": "a bool upon valid or invalid signature with corresponding _data",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_signature Signature byte array associated with _data",
            "subAnnotation": {
              "name": "_signature",
              "value": "Signature byte array associated with _data",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_data Arbitrary length data signed on the behalf of address(this)",
            "subAnnotation": {
              "name": "_data",
              "value": "Arbitrary length data signed on the behalf of address(this)",
              "subAnnotation": null
            }
          },
          {
            "name": "*",
            "value": "      The method will not perform any state changes (see parameters of `checkSignatures`)",
            "subAnnotation": null
          },
          {
            "name": "*",
            "value": "      The save does not implement the interface since `checkSignatures` is not a view method.",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "Should return whether the signature provided is valid for the provided data.",
            "subAnnotation": null
          },
          {
            "name": "*",
            "value": "Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)",
            "subAnnotation": null
          },
          {
            "name": "/*",
            "value": "/**",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "getMessageHash",
        "params": [
          {
            "name": "message",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Message that should be hashed"
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }",
        "start": {
          "line": 337,
          "column": 4
        },
        "end": {
          "line": 350,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Message hash.",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "message Message that should be hashed",
            "subAnnotation": {
              "name": "message",
              "value": "Message that should be hashed",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Returns hash of a message that can be signed by owners.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "encodeTransactionData",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type."
          },
          {
            "name": "safeTxGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Fas that should be used for the safe transaction."
          },
          {
            "name": "baseGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Gas costs for data used to trigger the safe transaction."
          },
          {
            "name": "gasPrice",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Maximum gas price that should be used for this transaction."
          },
          {
            "name": "gasToken",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Token address (or 0 if ETH) that is used for the payment."
          },
          {
            "name": "refundReceiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Address of receiver of gas payment (or 0 if tx.origin)."
          },
          {
            "name": "_nonce",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Transaction nonce."
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }",
        "start": {
          "line": 364,
          "column": 4
        },
        "end": {
          "line": 384,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Transaction hash bytes.",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_nonce Transaction nonce.",
            "subAnnotation": {
              "name": "_nonce",
              "value": "Transaction nonce.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
            "subAnnotation": {
              "name": "refundReceiver",
              "value": "Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
            "subAnnotation": {
              "name": "gasToken",
              "value": "Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasPrice Maximum gas price that should be used for this transaction.",
            "subAnnotation": {
              "name": "gasPrice",
              "value": "Maximum gas price that should be used for this transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "baseGas Gas costs for data used to trigger the safe transaction.",
            "subAnnotation": {
              "name": "baseGas",
              "value": "Gas costs for data used to trigger the safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "safeTxGas Fas that should be used for the safe transaction.",
            "subAnnotation": {
              "name": "safeTxGas",
              "value": "Fas that should be used for the safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "operation Operation type.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Returns the bytes that are hashed to be signed by owners.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "getTransactionHash",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type."
          },
          {
            "name": "safeTxGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Fas that should be used for the safe transaction."
          },
          {
            "name": "baseGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Gas costs for data used to trigger the safe transaction."
          },
          {
            "name": "gasPrice",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Maximum gas price that should be used for this transaction."
          },
          {
            "name": "gasToken",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Token address (or 0 if ETH) that is used for the payment."
          },
          {
            "name": "refundReceiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Address of receiver of gas payment (or 0 if tx.origin)."
          },
          {
            "name": "_nonce",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Transaction nonce."
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }",
        "start": {
          "line": 398,
          "column": 4
        },
        "end": {
          "line": 415,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Transaction hash.",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_nonce Transaction nonce.",
            "subAnnotation": {
              "name": "_nonce",
              "value": "Transaction nonce.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "refundReceiver Address of receiver of gas payment (or 0 if tx.origin).",
            "subAnnotation": {
              "name": "refundReceiver",
              "value": "Address of receiver of gas payment (or 0 if tx.origin).",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasToken Token address (or 0 if ETH) that is used for the payment.",
            "subAnnotation": {
              "name": "gasToken",
              "value": "Token address (or 0 if ETH) that is used for the payment.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "gasPrice Maximum gas price that should be used for this transaction.",
            "subAnnotation": {
              "name": "gasPrice",
              "value": "Maximum gas price that should be used for this transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "baseGas Gas costs for data used to trigger the safe transaction.",
            "subAnnotation": {
              "name": "baseGas",
              "value": "Gas costs for data used to trigger the safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "safeTxGas Fas that should be used for the safe transaction.",
            "subAnnotation": {
              "name": "safeTxGas",
              "value": "Fas that should be used for the safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "operation Operation type.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Returns hash to be signed by owners.",
            "subAnnotation": null
          }
        ]
      }
    ],
    "annotations": [
      {
        "name": "author",
        "value": "Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment",
        "subAnnotation": null
      },
      {
        "name": "author",
        "value": "Richard Meissner - <richard@gnosis.io>",
        "subAnnotation": null
      },
      {
        "name": "author",
        "value": "Stefan George - <stefan@gnosis.io>",
        "subAnnotation": null
      },
      {
        "name": "title",
        "value": "Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.",
        "subAnnotation": null
      }
    ],
    "deployedAt": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
    "meta": null,
    "modifiers": [],
    "events": [
      {
        "name": "ApproveHash",
        "params": [
          {
            "name": "approvedHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": true,
            "visibility": null
          },
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": true,
            "visibility": null
          }
        ]
      },
      {
        "name": "SignMsg",
        "params": [
          {
            "name": "msgHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": true,
            "visibility": null
          }
        ]
      },
      {
        "name": "ExecutionFailure",
        "params": [
          {
            "name": "txHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "payment",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "ExecutionSuccess",
        "params": [
          {
            "name": "txHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "payment",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      }
    ],
    "kind": "contract",
    "heritageDissolved": false,
    "inheritedStateVariables": [
      {
        "name": "masterCopy",
        "solidityType": {
          "name": "address",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "private",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "masterCopy",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "SENTINEL_MODULES",
        "solidityType": {
          "name": "address",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "SENTINEL_MODULES",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "modules",
        "solidityType": {
          "name": "(address => address)",
          "mapping": {
            "key": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "value": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            }
          },
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "modules",
          "params": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null,
              "lastType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            }
          ],
          "returnParams": [
            {
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "SENTINEL_OWNERS",
        "solidityType": {
          "name": "address",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "SENTINEL_OWNERS",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "owners",
        "solidityType": {
          "name": "(address => address)",
          "mapping": {
            "key": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "value": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            }
          },
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "owners",
          "params": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null,
              "lastType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            }
          ],
          "returnParams": [
            {
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "ownerCount",
        "solidityType": {
          "name": "uint256",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "default",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "ownerCount",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "threshold",
        "solidityType": {
          "name": "uint256",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "threshold",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "EIP1271_MAGIC_VALUE",
        "solidityType": {
          "name": "bytes4",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "EIP1271_MAGIC_VALUE",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes4",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "FALLBACK_HANDLER_STORAGE_SLOT",
        "solidityType": {
          "name": "bytes32",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "FALLBACK_HANDLER_STORAGE_SLOT",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      }
    ],
    "inheritedFunctions": [
      {
        "name": "changeMasterCopy",
        "params": [
          {
            "name": "_masterCopy",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New contract address."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function changeMasterCopy(address _masterCopy)\n        public\n        authorized\n    {\n        // Master copy address cannot be null.\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n        emit ChangedMasterCopy(_masterCopy);\n    }",
        "start": {
          "line": 18,
          "column": 4
        },
        "end": {
          "line": 26,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_masterCopy New contract address.",
            "subAnnotation": {
              "name": "_masterCopy",
              "value": "New contract address.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Allows to upgrade the contract. This can only be done via a Safe transaction.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "setupModules",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function setupModules(address to, bytes memory data)\n        internal\n    {\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n    }",
        "start": {
          "line": 22,
          "column": 4
        },
        "end": {
          "line": 30,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "enableModule",
        "params": [
          {
            "name": "module",
            "solidityType": {
              "name": "Module",
              "userDefined": true,
              "references": [
                "Module"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Module to be whitelisted."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function enableModule(Module module)\n        public\n        authorized\n    {\n        // Module address cannot be null or sentinel.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        // Module cannot be added twice.\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n        modules[address(module)] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = address(module);\n        emit EnabledModule(module);\n    }",
        "start": {
          "line": 35,
          "column": 4
        },
        "end": {
          "line": 46,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "module Module to be whitelisted.",
            "subAnnotation": {
              "name": "module",
              "value": "Module to be whitelisted.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "disableModule",
        "params": [
          {
            "name": "prevModule",
            "solidityType": {
              "name": "Module",
              "userDefined": true,
              "references": [
                "Module"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Module that pointed to the module to be removed in the linked list"
          },
          {
            "name": "module",
            "solidityType": {
              "name": "Module",
              "userDefined": true,
              "references": [
                "Module"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Module to be removed."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function disableModule(Module prevModule, Module module)\n        public\n        authorized\n    {\n        // Validate module address and check that it corresponds to module index.\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n        modules[address(prevModule)] = modules[address(module)];\n        modules[address(module)] = address(0);\n        emit DisabledModule(module);\n    }",
        "start": {
          "line": 52,
          "column": 4
        },
        "end": {
          "line": 62,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "module Module to be removed.",
            "subAnnotation": {
              "name": "module",
              "value": "Module to be removed.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "prevModule Module that pointed to the module to be removed in the linked list",
            "subAnnotation": {
              "name": "prevModule",
              "value": "Module that pointed to the module to be removed in the linked list",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "execTransactionFromModule",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address of module transaction."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value of module transaction."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload of module transaction."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type of module transaction."
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          null
        ],
        "source": "function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success)\n    {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }",
        "start": {
          "line": 69,
          "column": 4
        },
        "end": {
          "line": 79,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "operation Operation type of module transaction.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload of module transaction.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value of module transaction.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address of module transaction.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Allows a Module to execute a Safe transaction without any further confirmations.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "execTransactionFromModuleReturnData",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Destination address of module transaction."
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Ether value of module transaction."
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "Data payload of module transaction."
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Operation type of module transaction."
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "returnData",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          null
        ],
        "source": "function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        public\n        returns (bool success, bytes memory returnData)\n    {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }",
        "start": {
          "line": 86,
          "column": 4
        },
        "end": {
          "line": 105,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "operation Operation type of module transaction.",
            "subAnnotation": {
              "name": "operation",
              "value": "Operation type of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "data Data payload of module transaction.",
            "subAnnotation": {
              "name": "data",
              "value": "Data payload of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "value Ether value of module transaction.",
            "subAnnotation": {
              "name": "value",
              "value": "Ether value of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "to Destination address of module transaction.",
            "subAnnotation": {
              "name": "to",
              "value": "Destination address of module transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Allows a Module to execute a Safe transaction without any further confirmations and return data",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "getModules",
        "params": [],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "address[]",
              "pureName": "address",
              "userDefined": false,
              "references": [],
              "isArray": true
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getModules()\n        public\n        view\n        returns (address[] memory)\n    {\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }",
        "start": {
          "line": 109,
          "column": 4
        },
        "end": {
          "line": 116,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Array of modules.",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "Returns array of first 10 modules.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "getModulesPaginated",
        "params": [
          {
            "name": "start",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Start of the page."
          },
          {
            "name": "pageSize",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Maximum number of modules that should be returned."
          }
        ],
        "returnParams": [
          {
            "name": "array",
            "solidityType": {
              "name": "address[]",
              "pureName": "address",
              "userDefined": false,
              "references": [],
              "isArray": true
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "next",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getModulesPaginated(address start, uint256 pageSize)\n        public\n        view\n        returns (address[] memory array, address next)\n    {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }",
        "start": {
          "line": 122,
          "column": 4
        },
        "end": {
          "line": 144,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Array of modules.",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "pageSize Maximum number of modules that should be returned.",
            "subAnnotation": {
              "name": "pageSize",
              "value": "Maximum number of modules that should be returned.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "start Start of the page.",
            "subAnnotation": {
              "name": "start",
              "value": "Start of the page.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Returns array of modules.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "execute",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "operation",
            "solidityType": {
              "name": "Enum.Operation",
              "userDefined": true,
              "references": [
                "Enum.Operation"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "txGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        if (operation == Enum.Operation.Call)\n            success = executeCall(to, value, data, txGas);\n        else if (operation == Enum.Operation.DelegateCall)\n            success = executeDelegateCall(to, data, txGas);\n        else\n            success = false;\n    }",
        "start": {
          "line": 9,
          "column": 4
        },
        "end": {
          "line": 19,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "executeCall",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "value",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "txGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
        "start": {
          "line": 21,
          "column": 4
        },
        "end": {
          "line": 29,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "executeDelegateCall",
        "params": [
          {
            "name": "to",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "data",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "txGas",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [
          {
            "name": "success",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n        internal\n        returns (bool success)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }",
        "start": {
          "line": 31,
          "column": 4
        },
        "end": {
          "line": 39,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "setupOwners",
        "params": [
          {
            "name": "_owners",
            "solidityType": {
              "name": "address[]",
              "pureName": "address",
              "userDefined": false,
              "references": [],
              "isArray": true
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "List of Safe owners."
          },
          {
            "name": "_threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Number of required confirmations for a Safe transaction."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }",
        "start": {
          "line": 22,
          "column": 4
        },
        "end": {
          "line": 46,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_threshold Number of required confirmations for a Safe transaction.",
            "subAnnotation": {
              "name": "_threshold",
              "value": "Number of required confirmations for a Safe transaction.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_owners List of Safe owners.",
            "subAnnotation": {
              "name": "_owners",
              "value": "List of Safe owners.",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Setup function sets initial storage of contract.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "addOwnerWithThreshold",
        "params": [
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New owner address."
          },
          {
            "name": "_threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New threshold."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
        "start": {
          "line": 52,
          "column": 4
        },
        "end": {
          "line": 67,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_threshold New threshold.",
            "subAnnotation": {
              "name": "_threshold",
              "value": "New threshold.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "owner New owner address.",
            "subAnnotation": {
              "name": "owner",
              "value": "New owner address.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "removeOwner",
        "params": [
          {
            "name": "prevOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Owner that pointed to the owner to be removed in the linked list"
          },
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Owner address to be removed."
          },
          {
            "name": "_threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New threshold."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }",
        "start": {
          "line": 74,
          "column": 4
        },
        "end": {
          "line": 90,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_threshold New threshold.",
            "subAnnotation": {
              "name": "_threshold",
              "value": "New threshold.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "owner Owner address to be removed.",
            "subAnnotation": {
              "name": "owner",
              "value": "Owner address to be removed.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "prevOwner Owner that pointed to the owner to be removed in the linked list",
            "subAnnotation": {
              "name": "prevOwner",
              "value": "Owner that pointed to the owner to be removed in the linked list",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "swapOwner",
        "params": [
          {
            "name": "prevOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Owner that pointed to the owner to be replaced in the linked list"
          },
          {
            "name": "oldOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Owner address to be replaced."
          },
          {
            "name": "newOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New owner address."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }",
        "start": {
          "line": 97,
          "column": 4
        },
        "end": {
          "line": 113,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "newOwner New owner address.",
            "subAnnotation": {
              "name": "newOwner",
              "value": "New owner address.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "oldOwner Owner address to be replaced.",
            "subAnnotation": {
              "name": "oldOwner",
              "value": "Owner address to be replaced.",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "prevOwner Owner that pointed to the owner to be replaced in the linked list",
            "subAnnotation": {
              "name": "prevOwner",
              "value": "Owner that pointed to the owner to be replaced in the linked list",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "changeThreshold",
        "params": [
          {
            "name": "_threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "New threshold."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }",
        "start": {
          "line": 118,
          "column": 4
        },
        "end": {
          "line": 128,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_threshold New threshold.",
            "subAnnotation": {
              "name": "_threshold",
              "value": "New threshold.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "getThreshold",
        "params": [],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }",
        "start": {
          "line": 130,
          "column": 4
        },
        "end": {
          "line": 136,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "isOwner",
        "params": [
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }",
        "start": {
          "line": 138,
          "column": 4
        },
        "end": {
          "line": 144,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "getOwners",
        "params": [],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "address[]",
              "pureName": "address",
              "userDefined": false,
              "references": [],
              "isArray": true
            },
            "isStorage": true,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "public",
          "view"
        ],
        "source": "function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }",
        "start": {
          "line": 148,
          "column": 4
        },
        "end": {
          "line": 164,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "Array of Safe owners.",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "Returns array of owners.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "recoverKey",
        "params": [
          {
            "name": "messageHash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "operation ethereum signed message hash"
          },
          {
            "name": "messageSignature",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "message `txHash` signature"
          },
          {
            "name": "pos",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "which signature to read"
          }
        ],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "internal",
          "pure"
        ],
        "source": "function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }",
        "start": {
          "line": 13,
          "column": 4
        },
        "end": {
          "line": 27,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "pos which signature to read",
            "subAnnotation": {
              "name": "pos",
              "value": "which signature to read",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "messageSignature message `txHash` signature",
            "subAnnotation": {
              "name": "messageSignature",
              "value": "message `txHash` signature",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "messageHash operation ethereum signed message hash",
            "subAnnotation": {
              "name": "messageHash",
              "value": "operation ethereum signed message hash",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Recovers address who signed the message",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "signatureSplit",
        "params": [
          {
            "name": "signatures",
            "solidityType": {
              "name": "bytes",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "concatenated rsv signatures"
          },
          {
            "name": "pos",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access"
          }
        ],
        "returnParams": [
          {
            "name": "v",
            "solidityType": {
              "name": "uint8",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "r",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          },
          {
            "name": "s",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
        "modifiers": [
          "internal",
          "pure"
        ],
        "source": "function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }",
        "start": {
          "line": 33,
          "column": 4
        },
        "end": {
          "line": 53,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "signatures concatenated rsv signatures",
            "subAnnotation": {
              "name": "signatures",
              "value": "concatenated rsv signatures",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
            "subAnnotation": {
              "name": "pos",
              "value": "which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "transferToken",
        "params": [
          {
            "name": "token",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Token that should be transferred"
          },
          {
            "name": "receiver",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "Receiver to whom the token should be transferred"
          },
          {
            "name": "amount",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "The amount of tokens that should be transferred"
          }
        ],
        "returnParams": [
          {
            "name": "transferred",
            "solidityType": {
              "name": "bool",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function transferToken (\n        address token,\n        address receiver,\n        uint256 amount\n    )\n        internal\n        returns (bool transferred)\n    {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, returndatasize()))\n            returndatacopy(ptr, 0, returndatasize())\n            switch returndatasize()\n            case 0 { transferred := success }\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n            default { transferred := 0 }\n        }\n    }",
        "start": {
          "line": 12,
          "column": 4
        },
        "end": {
          "line": 32,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "amount The amount of tokens that should be transferred",
            "subAnnotation": {
              "name": "amount",
              "value": "The amount of tokens that should be transferred",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "receiver Receiver to whom the token should be transferred",
            "subAnnotation": {
              "name": "receiver",
              "value": "Receiver to whom the token should be transferred",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "token Token that should be transferred",
            "subAnnotation": {
              "name": "token",
              "value": "Token that should be transferred",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "Transfers a token and returns if it was a success",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "internalSetFallbackHandler",
        "params": [
          {
            "name": "handler",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }",
        "start": {
          "line": 12,
          "column": 4
        },
        "end": {
          "line": 18,
          "column": 4
        },
        "annotations": []
      },
      {
        "name": "setFallbackHandler",
        "params": [
          {
            "name": "handler",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "contract to handle fallbacks calls."
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "authorized",
          "public",
          null
        ],
        "source": "function setFallbackHandler(address handler)\n        public\n        authorized\n    {\n        internalSetFallbackHandler(handler);\n    }",
        "start": {
          "line": 24,
          "column": 4
        },
        "end": {
          "line": 29,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "handler contract to handle fallbacks calls.",
            "subAnnotation": {
              "name": "handler",
              "value": "contract to handle fallbacks calls.",
              "subAnnotation": null
            }
          }
        ]
      },
      {
        "name": "",
        "params": [],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "external",
          "payable"
        ],
        "source": "function ()\n        external\n        payable\n    {\n        // Only calls without value and with data will be forwarded\n        if (msg.value > 0 || msg.data.length == 0) {\n            return;\n        }\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        address handler;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            handler := sload(slot)\n        }\n\n        if (handler != address(0)) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                if eq(success, 0) { revert(0, returndatasize()) }\n                return(0, returndatasize())\n            }\n        }\n    }",
        "start": {
          "line": 31,
          "column": 4
        },
        "end": {
          "line": 56,
          "column": 4
        },
        "annotations": []
      }
    ],
    "inheritedEvents": [
      {
        "name": "ChangedMasterCopy",
        "params": [
          {
            "name": "masterCopy",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "EnabledModule",
        "params": [
          {
            "name": "module",
            "solidityType": {
              "name": "Module",
              "userDefined": true,
              "references": [
                "Module"
              ],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "DisabledModule",
        "params": [
          {
            "name": "module",
            "solidityType": {
              "name": "Module",
              "userDefined": true,
              "references": [
                "Module"
              ],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "ExecutionFromModuleSuccess",
        "params": [
          {
            "name": "module",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": true,
            "visibility": null
          }
        ]
      },
      {
        "name": "ExecutionFromModuleFailure",
        "params": [
          {
            "name": "module",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": true,
            "visibility": null
          }
        ]
      },
      {
        "name": "AddedOwner",
        "params": [
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "RemovedOwner",
        "params": [
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "ChangedThreshold",
        "params": [
          {
            "name": "threshold",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      }
    ],
    "inheritedModifiers": [
      {
        "name": "authorized",
        "params": []
      }
    ],
    "source": "pragma solidity >=0.5.0 <0.7.0;\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/MasterCopy.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/SafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\n/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\ncontract GnosisSafe\n    is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {\n\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Gnosis Safe\";\n    string public constant VERSION = \"1.1.1\";\n\n    //keccak256(\n    //    \"EIP712Domain(address verifyingContract)\"\n    //);\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    //keccak256(\n    //    \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    //);\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    //keccak256(\n    //    \"SafeMessage(bytes message)\"\n    //);\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n\n    event ApproveHash(\n        bytes32 indexed approvedHash,\n        address indexed owner\n    );\n    event SignMsg(\n        bytes32 indexed msgHash\n    );\n    event ExecutionFailure(\n        bytes32 txHash, uint256 payment\n    );\n    event ExecutionSuccess(\n        bytes32 txHash, uint256 payment\n    );\n\n    uint256 public nonce;\n    bytes32 public domainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() public {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the mastercopy\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external\n    {\n        require(domainSeparator == 0, \"Domain Separator already set!\");\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transfered, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes calldata signatures\n    )\n        external\n        returns (bool success)\n    {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                to, value, data, operation, // Transaction info\n                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures, true);\n        }\n        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\n            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    )\n        private\n        returns (uint256 payment)\n    {\n        // solium-disable-next-line security/no-tx-origin\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            // solium-disable-next-line security/no-send\n            require(receiver.send(payment), \"Could not pay gas costs with ether\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\n        }\n    }\n\n    /**\n    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n    * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n    * @param data That should be signed (this is passed to an external validator contract)\n    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\n    */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n        internal\n    {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"Threshold needs to be defined!\");\n        // Check that the provided signature data is not too short\n        require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // If v is 0 then it is a contract signature\n            if (v == 0) {\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n            // If v is 1 then it is an approved hash\n            } else if (v == 1) {\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint256(r));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n                if (consumeHash && msg.sender != currentOwner) {\n                    approvedHashes[currentOwner][dataHash] = 0;\n                }\n            } else if (v > 30) {\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require (\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"Invalid owner provided\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:\n    ///      1.) The method can only be called from the safe itself\n    ///      2.) The response is returned with a revert\n    ///      When estimating set `from` to the address of the safe.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        authorized\n        returns (uint256)\n    {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        // solium-disable-next-line error-reason\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n    */\n    function approveHash(bytes32 hashToApprove)\n        external\n    {\n        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n    * @dev Marks a message as signed\n    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\n    */\n    function signMessage(bytes calldata _data)\n        external\n        authorized\n    {\n        bytes32 msgHash = getMessageHash(_data);\n        signedMessages[msgHash] = 1;\n        emit SignMsg(msgHash);\n    }\n\n    /**\n    * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n    * @dev Should return whether the signature provided is valid for the provided data.\n    *       The save does not implement the interface since `checkSignatures` is not a view method.\n    *       The method will not perform any state changes (see parameters of `checkSignatures`)\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    * @return a bool upon valid or invalid signature with corresponding _data\n    */\n    function isValidSignature(bytes calldata _data, bytes calldata _signature)\n        external\n        returns (bytes4)\n    {\n        bytes32 messageHash = getMessageHash(_data);\n        if (_signature.length == 0) {\n            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n        } else {\n            // consumeHash needs to be false, as the state should not be changed\n            checkSignatures(messageHash, _data, _signature, false);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /// @dev Returns hash of a message that can be signed by owners.\n    /// @param message Message that should be hashed\n    /// @return Message hash.\n    function getMessageHash(\n        bytes memory message\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\n        );\n        return keccak256(\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\n        );\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\n        );\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n",
    "inFile": "GnosisSafe.sol",
    "references": [
      "MasterCopy",
      "ModuleManager",
      "OwnerManager",
      "SignatureDecoder",
      "SecuredTokenTransfer",
      "ISignatureValidatorConstants",
      "FallbackManager",
      "Enum.Operation"
    ],
    "isAbstract": false
  }
}