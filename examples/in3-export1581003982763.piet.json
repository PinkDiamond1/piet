{
  "pietFileVersion": "0.0.1",
  "contracts": [
    {
      "elementType": 0,
      "name": "IERC20",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [],
      "functions": [
        {
          "name": "approve",
          "params": [
            {
              "name": "spender",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function approve(address spender, uint256 amount) external returns (bool);",
          "start": {
            "line": 25,
            "column": 4
          },
          "end": {
            "line": 25,
            "column": 77
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "Emits an `Approval` event.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transfer",
          "params": [
            {
              "name": "recipient",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function transfer(address recipient, uint256 amount) external returns (bool);",
          "start": {
            "line": 34,
            "column": 4
          },
          "end": {
            "line": 34,
            "column": 80
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "Emits a `Transfer` event.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transferFrom",
          "params": [
            {
              "name": "sender",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "recipient",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            null
          ],
          "source": "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);",
          "start": {
            "line": 45,
            "column": 4
          },
          "end": {
            "line": 45,
            "column": 100
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "Emits a `Transfer` event.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "allowance",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "spender",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function allowance(address owner, address spender) external view returns (uint256);",
          "start": {
            "line": 54,
            "column": 4
          },
          "end": {
            "line": 54,
            "column": 86
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "This value changes when `approve` or `transferFrom` are called.",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "totalSupply",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function totalSupply() external view returns (uint256);",
          "start": {
            "line": 59,
            "column": 4
          },
          "end": {
            "line": 59,
            "column": 58
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns the amount of tokens in existence.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "balanceOf",
          "params": [
            {
              "name": "account",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function balanceOf(address account) external view returns (uint256);",
          "start": {
            "line": 64,
            "column": 4
          },
          "end": {
            "line": 64,
            "column": 71
          },
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Returns the amount of tokens owned by `account`.",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "*",
          "value": "*/",
          "subAnnotation": null
        },
        {
          "name": "*",
          "value": "the optional functions; to access them see `ERC20Detailed`.",
          "subAnnotation": null
        },
        {
          "name": "dev",
          "value": "Interface of the ERC20 standard as defined in the EIP. Does not include",
          "subAnnotation": null
        },
        {
          "name": "/*",
          "value": "/**",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "Transfer",
          "params": [
            {
              "name": "from",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "Approval",
          "params": [
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "spender",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "value",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "interface",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "pragma solidity 0.5.10;\n\n// file taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value); // solhint-disable-line\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
      "inFile": "IERC20.sol",
      "references": [],
      "isAbstract": true
    },
    {
      "elementType": 0,
      "name": "BlockhashRegistry",
      "baseContracts": [],
      "enumerations": [],
      "structs": [],
      "stateVariables": [
        {
          "name": "blockhashMapping",
          "solidityType": {
            "name": "(uint => bytes32)",
            "mapping": {
              "key": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "blockhashMapping",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor() public {\n        snapshot();\n    }",
          "start": {
            "line": 35,
            "column": 4
          },
          "end": {
            "line": 37,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "cannot be deployed in a genesis block",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "searchForAvailableBlock",
          "params": [
            {
              "name": "_startNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the blocknumber to start searching"
            },
            {
              "name": "_numBlocks",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the number of blocks to search for"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "searches for an already existing snapshot",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n        uint target = _startNumber + _numBlocks;\n\n        require(target <= block.number || target < _startNumber, \"invalid search\");\n\n        for (uint i = _startNumber; i <= target; i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }",
          "start": {
            "line": 43,
            "column": 4
          },
          "end": {
            "line": 53,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the closes snapshot of found within the given range, 0 else",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_numBlocks the number of blocks to search for",
              "subAnnotation": {
                "name": "_numBlocks",
                "value": "the number of blocks to search for",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_startNumber the blocknumber to start searching",
              "subAnnotation": {
                "name": "_startNumber",
                "value": "the blocknumber to start searching",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "searches for an already existing snapshot",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "recreateBlockheaders",
          "params": [
            {
              "name": "_blockNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the block number to start recreation from"
            },
            {
              "name": "_blockheaders",
              "solidityType": {
                "name": "bytes[]",
                "pureName": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)"
            }
          ],
          "returnParams": [],
          "description": "if successfull the last blockhash of the header will be added to the smart contract\nit will be checked whether the provided chain is correct by using the reCalculateBlockheaders function\nonly usable when the given blocknumber is already in the smart contract\nstarts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks",
          "modifiers": [
            "public",
            null
          ],
          "source": "function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n        require(_blockNumber > _blockheaders.length, \"too many blockheaders provided\");\n        require(_blockNumber < block.number, \"cannot recreate a not yet existing block\");\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n\n        uint bnr = _blockNumber - _blockheaders.length;\n        require(blockhashMapping[bnr] == 0x0, \"block already stored\");\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        /// if the blocknumber we want to store is within the last 256 blocks, we use the evm hash\n        if (bnr > block.number-256) {\n            saveBlockNumber(bnr);\n            return;\n        }\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash, _blockNumber);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }",
          "start": {
            "line": 64,
            "column": 4
          },
          "end": {
            "line": 88,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "function is public due to the usage of a dynamic bytes array (not yet supported for external functions)",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when the chain of headers is incorrect",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when there is not parent block already stored in the contract",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_blockheaders array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)",
              "subAnnotation": {
                "name": "_blockheaders",
                "value": "array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_blockNumber the block number to start recreation from",
              "subAnnotation": {
                "name": "_blockNumber",
                "value": "the block number to start recreation from",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "if successfull the last blockhash of the header will be added to the smart contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "it will be checked whether the provided chain is correct by using the reCalculateBlockheaders function",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "only usable when the given blocknumber is already in the smart contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "starts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "saveBlockNumber",
          "params": [
            {
              "name": "_blockNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the blocknumber to be stored"
            }
          ],
          "returnParams": [],
          "description": "stores a certain blockhash to the state",
          "modifiers": [
            "public",
            null
          ],
          "source": "function saveBlockNumber(uint _blockNumber) public {\n\n        require(blockhashMapping[_blockNumber] == 0x0, \"block already stored\");\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }",
          "start": {
            "line": 93,
            "column": 4
          },
          "end": {
            "line": 103,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "reverts if the block can't be found inside the evm",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_blockNumber the blocknumber to be stored",
              "subAnnotation": {
                "name": "_blockNumber",
                "value": "the blocknumber to be stored",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "stores a certain blockhash to the state",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "snapshot",
          "params": [],
          "returnParams": [],
          "description": "stores the currentBlock-1 in the smart contract",
          "modifiers": [
            "public",
            null
          ],
          "source": "function snapshot() public {\n        /// blockhash cannot return the current block, so we use the previous block\n        saveBlockNumber(block.number-1);\n    }",
          "start": {
            "line": 106,
            "column": 4
          },
          "end": {
            "line": 109,
            "column": 4
          },
          "annotations": [
            {
              "name": "notice",
              "value": "stores the currentBlock-1 in the smart contract",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getRlpUint",
          "params": [
            {
              "name": "_data",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "rlp encoded data"
            },
            {
              "name": "_offset",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the offset"
            }
          ],
          "returnParams": [
            {
              "name": "value",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "",
          "modifiers": [
            "public",
            "pure"
          ],
          "source": "function getRlpUint(bytes memory _data, uint _offset) public pure returns (uint value) {\n        /// get the byte at offset to figure out the length of the value\n        uint8 c = uint8(_data[_offset]);\n\n        /// we will not accept values above 0xa0, since this would mean we either have a list\n        /// or we have a value with a length greater 32 bytes\n        /// for the use cases (getting the blockNumber or difficulty) we can accept these limits.\n        require(c < 0xa1, \"lists or long fields are not supported\");\n        if (c < 0x80)  // single byte-item\n            return uint(c); // value = byte\n\n        // length of the value\n        uint len = c - 0x80;\n        // we skip the first 32 bytes since they contain the legth and add 1 because this byte contains the length of the value.\n        uint dataOffset = _offset + 33;\n\n        /// check the range\n        require(_offset + len <= _data.length, \"invalid offset\");\n\n        /// we are using assembly because we need to get the value of the next `len` bytes\n        /// This is done by copying the bytes in the \"scratch space\" so we can take the first 32 bytes as value afterwards.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0x0, 0) // clean memory in the \"scratch space\"\n            mstore(\n                sub (0x20, len), // we move the position so the first bytes from rlp are the last bytes within the 32 bytes\n                mload(\n                    add ( _data, dataOffset ) // load the data from rlp-data\n                )\n            )\n            value:=mload(0x0)\n        }\n        return value;\n    }",
          "start": {
            "line": 116,
            "column": 4
          },
          "end": {
            "line": 149,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the value",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_offset the offset",
              "subAnnotation": {
                "name": "_offset",
                "value": "the offset",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_data rlp encoded data",
              "subAnnotation": {
                "name": "_data",
                "value": "rlp encoded data",
                "subAnnotation": null
              }
            }
          ]
        },
        {
          "name": "getParentAndBlockhash",
          "params": [
            {
              "name": "_blockheader",
              "solidityType": {
                "name": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "a serialized (rlp-encoded) blockheader"
            }
          ],
          "returnParams": [
            {
              "name": "parentHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "bhash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            },
            {
              "name": "blockNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "returns the blockhash and the parent blockhash from the provided blockheader",
          "modifiers": [
            "public",
            "pure"
          ],
          "source": "function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash, uint blockNumber) {\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n        uint8 first = uint8(_blockheader[0]);\n\n        /// calculates the offset\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n        require(first > 0xf7, \"invalid offset\");\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n        uint offset = first - 0xf7 + 2;\n        require(offset+32 < _blockheader.length, \"invalid length\");\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // we load the provided blockheader\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        _blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n        // verify parentHash\n        require(parentHash != 0x0, \"invalid parentHash\");\n        bhash = keccak256(_blockheader);\n\n        // get the blockNumber\n        // we set the offset to the difficulty field which is fixed since all fields between them have a fixed length.\n        offset += 444;\n\n        // we get the first byte for the difficulty field ( which is a field with a dynamic length)\n        // and calculate the length, because the next field is the blockNumber\n        uint8 c = uint8(_blockheader[offset]);\n        require(c < 0xa1, \"lists or long fields are not supported for difficulty\");\n        offset += c < 0x80 ? 1 : (c - 0x80 + 1);\n\n        // we fetch the blockNumber from the calculated offset\n        blockNumber = getRlpUint(_blockheader, offset);\n    }",
          "start": {
            "line": 154,
            "column": 4
          },
          "end": {
            "line": 198,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the parent blockhash and the keccak256 of the provided blockheader (= the corresponding blockhash)",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_blockheader a serialized (rlp-encoded) blockheader",
              "subAnnotation": {
                "name": "_blockheader",
                "value": "a serialized (rlp-encoded) blockheader",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "returns the blockhash and the parent blockhash from the provided blockheader",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "reCalculateBlockheaders",
          "params": [
            {
              "name": "_blockheaders",
              "solidityType": {
                "name": "bytes[]",
                "pureName": "bytes",
                "userDefined": false,
                "references": [],
                "isArray": true
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "array with serialized blockheaders in reverse order, i.e. from youngest to oldest"
            },
            {
              "name": "_bHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "blockhash of the 1st element of the _blockheaders-array"
            },
            {
              "name": "_blockNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader"
            }
          ],
          "returnParams": [
            {
              "name": "bhash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])\nstarts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks",
          "modifiers": [
            "public",
            "view"
          ],
          "source": "function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash, uint _blockNumber) public view returns (bytes32 bhash) {\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n        require(_bHash != 0x0, \"invalid blockhash provided\");\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n        uint calcBlockNumber = 0;\n        uint currentBlockNumber = _blockNumber;\n\n        /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n        for (uint i = 0; i < _blockheaders.length; i++) {\n            /// we alway need to verify the blockHash and parentHash\n            /// but in addition we also verify the blockNumber.\n            /// This is just safety-check in case of detected hash collision which makes it almost impossible\n            /// to add an invalid header which might create the correct hash.\n            (calcParent, calcBlockhash, calcBlockNumber) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash || calcParent == 0x0 || calcBlockNumber != currentBlockNumber) {\n                return 0x0;\n            }\n\n            uint currentBlock = block.number > 256 ? block.number : 256;\n\n            if (currentBlock - 256 < calcBlockNumber) {\n                if (calcBlockhash != blockhash(calcBlockNumber)) {\n                    return 0x0;\n                }\n            }\n            currentBlockhash = calcParent;\n            currentBlockNumber--;\n        }\n\n        return currentBlockhash;\n    }",
          "start": {
            "line": 206,
            "column": 4
          },
          "end": {
            "line": 239,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "0x0 if the functions detects a wrong chaining of blocks, blockhash of the last element of the array otherwhise",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_blockNumber blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader",
              "subAnnotation": {
                "name": "_blockNumber",
                "value": "blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_bHash blockhash of the 1st element of the _blockheaders-array",
              "subAnnotation": {
                "name": "_bHash",
                "value": "blockhash of the 1st element of the _blockheaders-array",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_blockheaders array with serialized blockheaders in reverse order, i.e. from youngest to oldest",
              "subAnnotation": {
                "name": "_blockheaders",
                "value": "array with serialized blockheaders in reverse order, i.e. from youngest to oldest",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "starts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "title",
          "value": "Registry for blockhashes",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x7fC74751ef749707B4968091d7ddB53ef7Aa322F",
      "meta": null,
      "modifiers": [],
      "events": [
        {
          "name": "LogBlockhashAdded",
          "params": [
            {
              "name": "blockNr",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            },
            {
              "name": "bhash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": true,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\n\n/// @title Registry for blockhashes\ncontract BlockhashRegistry {\n\n    /// a new blockhash and its number has been added to the contract\n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    /// maps the blocknumber to its blockhash\n    mapping(uint => bytes32) public blockhashMapping;\n\n    /// constructor, calls snapshot-function when contract get deployed as entry point\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        snapshot();\n    }\n\n    /// @notice searches for an already existing snapshot\n    /// @param _startNumber the blocknumber to start searching\n    /// @param _numBlocks the number of blocks to search for\n    /// @return the closes snapshot of found within the given range, 0 else\n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n        uint target = _startNumber + _numBlocks;\n\n        require(target <= block.number || target < _startNumber, \"invalid search\");\n\n        for (uint i = _startNumber; i <= target; i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    /// @notice starts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice only usable when the given blocknumber is already in the smart contract\n    /// @notice it will be checked whether the provided chain is correct by using the reCalculateBlockheaders function\n    /// @notice if successfull the last blockhash of the header will be added to the smart contract\n    /// @param _blockNumber the block number to start recreation from\n    /// @param _blockheaders array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)\n    /// @dev reverts when there is not parent block already stored in the contract\n    /// @dev reverts when the chain of headers is incorrect\n    /// @dev function is public due to the usage of a dynamic bytes array (not yet supported for external functions)\n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n        require(_blockNumber > _blockheaders.length, \"too many blockheaders provided\");\n        require(_blockNumber < block.number, \"cannot recreate a not yet existing block\");\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n\n        uint bnr = _blockNumber - _blockheaders.length;\n        require(blockhashMapping[bnr] == 0x0, \"block already stored\");\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        /// if the blocknumber we want to store is within the last 256 blocks, we use the evm hash\n        if (bnr > block.number-256) {\n            saveBlockNumber(bnr);\n            return;\n        }\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash, _blockNumber);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    /// @notice stores a certain blockhash to the state\n    /// @param _blockNumber the blocknumber to be stored\n    /// @dev reverts if the block can't be found inside the evm\n    function saveBlockNumber(uint _blockNumber) public {\n\n        require(blockhashMapping[_blockNumber] == 0x0, \"block already stored\");\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    /// @notice stores the currentBlock-1 in the smart contract\n    function snapshot() public {\n        /// blockhash cannot return the current block, so we use the previous block\n        saveBlockNumber(block.number-1);\n    }\n\n    /// @notice returns the value from rlp encoded data.\n    ///         This function is limited to only value up to 32 bytes length!\n    /// @param _data rlp encoded data\n    /// @param _offset the offset\n    /// @return the value\n    function getRlpUint(bytes memory _data, uint _offset) public pure returns (uint value) {\n        /// get the byte at offset to figure out the length of the value\n        uint8 c = uint8(_data[_offset]);\n\n        /// we will not accept values above 0xa0, since this would mean we either have a list\n        /// or we have a value with a length greater 32 bytes\n        /// for the use cases (getting the blockNumber or difficulty) we can accept these limits.\n        require(c < 0xa1, \"lists or long fields are not supported\");\n        if (c < 0x80)  // single byte-item\n            return uint(c); // value = byte\n\n        // length of the value\n        uint len = c - 0x80;\n        // we skip the first 32 bytes since they contain the legth and add 1 because this byte contains the length of the value.\n        uint dataOffset = _offset + 33;\n\n        /// check the range\n        require(_offset + len <= _data.length, \"invalid offset\");\n\n        /// we are using assembly because we need to get the value of the next `len` bytes\n        /// This is done by copying the bytes in the \"scratch space\" so we can take the first 32 bytes as value afterwards.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0x0, 0) // clean memory in the \"scratch space\"\n            mstore(\n                sub (0x20, len), // we move the position so the first bytes from rlp are the last bytes within the 32 bytes\n                mload(\n                    add ( _data, dataOffset ) // load the data from rlp-data\n                )\n            )\n            value:=mload(0x0)\n        }\n        return value;\n    }\n\n    /// @notice returns the blockhash and the parent blockhash from the provided blockheader\n    /// @param _blockheader a serialized (rlp-encoded) blockheader\n    /// @return the parent blockhash and the keccak256 of the provided blockheader (= the corresponding blockhash)\n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash, uint blockNumber) {\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n        uint8 first = uint8(_blockheader[0]);\n\n        /// calculates the offset\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n        require(first > 0xf7, \"invalid offset\");\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n        uint offset = first - 0xf7 + 2;\n        require(offset+32 < _blockheader.length, \"invalid length\");\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // we load the provided blockheader\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        _blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n        // verify parentHash\n        require(parentHash != 0x0, \"invalid parentHash\");\n        bhash = keccak256(_blockheader);\n\n        // get the blockNumber\n        // we set the offset to the difficulty field which is fixed since all fields between them have a fixed length.\n        offset += 444;\n\n        // we get the first byte for the difficulty field ( which is a field with a dynamic length)\n        // and calculate the length, because the next field is the blockNumber\n        uint8 c = uint8(_blockheader[offset]);\n        require(c < 0xa1, \"lists or long fields are not supported for difficulty\");\n        offset += c < 0x80 ? 1 : (c - 0x80 + 1);\n\n        // we fetch the blockNumber from the calculated offset\n        blockNumber = getRlpUint(_blockheader, offset);\n    }\n\n    /// @notice starts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])\n    /// @param _blockheaders array with serialized blockheaders in reverse order, i.e. from youngest to oldest\n    /// @param _bHash blockhash of the 1st element of the _blockheaders-array\n    /// @param _blockNumber blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader\n    /// @return 0x0 if the functions detects a wrong chaining of blocks, blockhash of the last element of the array otherwhise\n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash, uint _blockNumber) public view returns (bytes32 bhash) {\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n        require(_bHash != 0x0, \"invalid blockhash provided\");\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n        uint calcBlockNumber = 0;\n        uint currentBlockNumber = _blockNumber;\n\n        /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n        for (uint i = 0; i < _blockheaders.length; i++) {\n            /// we alway need to verify the blockHash and parentHash\n            /// but in addition we also verify the blockNumber.\n            /// This is just safety-check in case of detected hash collision which makes it almost impossible\n            /// to add an invalid header which might create the correct hash.\n            (calcParent, calcBlockhash, calcBlockNumber) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash || calcParent == 0x0 || calcBlockNumber != currentBlockNumber) {\n                return 0x0;\n            }\n\n            uint currentBlock = block.number > 256 ? block.number : 256;\n\n            if (currentBlock - 256 < calcBlockNumber) {\n                if (calcBlockhash != blockhash(calcBlockNumber)) {\n                    return 0x0;\n                }\n            }\n            currentBlockhash = calcParent;\n            currentBlockNumber--;\n        }\n\n        return currentBlockhash;\n    }\n}\n",
      "inFile": "BlockhashRegistry.sol",
      "references": [],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "NodeRegistryData",
      "baseContracts": [],
      "enumerations": [],
      "structs": [
        {
          "name": "NodeRegistryData.In3Node",
          "shortName": "In3Node",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "registerTime",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "proofHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        {
          "name": "NodeRegistryData.SignerInformation",
          "shortName": "SignerInformation",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "lockedTime",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "stage",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "depositAmount",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "index",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        {
          "name": "NodeRegistryData.UrlInformation",
          "shortName": "UrlInformation",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "used",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        }
      ],
      "stateVariables": [
        {
          "name": "nodes",
          "solidityType": {
            "name": "In3Node[]",
            "pureName": "In3Node",
            "userDefined": true,
            "references": [],
            "isArray": true
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "nodes",
            "params": [
              {
                "solidityType": {
                  "isArray": false,
                  "name": "uint256",
                  "references": [],
                  "userDefined": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "In3Node",
                  "userDefined": true,
                  "references": [
                    "In3Node"
                  ],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "In3Node",
                  "userDefined": true,
                  "references": [
                    "In3Node"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "registryId",
          "solidityType": {
            "name": "bytes32",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "registryId",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "timeout",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "timeout",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "supportedToken",
          "solidityType": {
            "name": "IERC20",
            "userDefined": true,
            "references": [
              "IERC20"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "supportedToken",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "IERC20",
                  "userDefined": true,
                  "references": [
                    "IERC20"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "ownerContract",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "ownerContract",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "signerIndex",
          "solidityType": {
            "name": "(address => SignerInformation)",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "SignerInformation",
                "userDefined": true,
                "references": [
                  "SignerInformation"
                ],
                "isArray": false
              }
            },
            "userDefined": true,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "signerIndex",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "SignerInformation",
                  "userDefined": true,
                  "references": [
                    "SignerInformation"
                  ],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "SignerInformation",
                  "userDefined": true,
                  "references": [
                    "SignerInformation"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "urlIndex",
          "solidityType": {
            "name": "(bytes32 => UrlInformation)",
            "mapping": {
              "key": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "UrlInformation",
                "userDefined": true,
                "references": [
                  "UrlInformation"
                ],
                "isArray": false
              }
            },
            "userDefined": true,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "urlIndex",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "UrlInformation",
                  "userDefined": true,
                  "references": [
                    "UrlInformation"
                  ],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "UrlInformation",
                  "userDefined": true,
                  "references": [
                    "UrlInformation"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "convictMapping",
          "solidityType": {
            "name": "(address => (bytes32 => uint))",
            "mapping": {
              "key": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "value": {
                "name": "(bytes32 => uint)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              }
            },
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "convictMapping",
            "params": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "(bytes32 => uint)",
                  "mapping": {
                    "key": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "value": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              },
              {
                "name": "",
                "solidityType": {
                  "name": "bytes32",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null,
                "lastType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                }
              }
            ],
            "returnParams": [
              {
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [],
          "returnParams": [],
          "description": "constructor",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor() public {\n        // solium-disable-next-line security/no-block-members\n        registryId = keccak256(abi.encodePacked(address(this), blockhash(block.number-1)));\n        timeout = 40 days;\n        ownerContract = msg.sender;\n    }",
          "start": {
            "line": 118,
            "column": 4
          },
          "end": {
            "line": 123,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "cannot be deployed in a genesis block",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "constructor",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminRemoveNodeFromRegistry",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node"
            }
          ],
          "returnParams": [],
          "description": "removes an in3-node from the nodeList",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyLogicContract\n    {\n        SignerInformation memory si = signerIndex[_signer];\n        _removeNodeInternal(si.index);\n\n    }",
          "start": {
            "line": 127,
            "column": 4
          },
          "end": {
            "line": 134,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "removes an in3-node from the nodeList",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetLogic",
          "params": [
            {
              "name": "_newLogic",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new logic-contract / owner"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "sets the logic-address / owner of the contract",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminSetLogic(address _newLogic) external onlyLogicContract returns (bool) {\n        require(address(_newLogic) != address(0x0), \"no address provided\");\n        ownerContract = _newLogic;\n        return true;\n    }",
          "start": {
            "line": 141,
            "column": 4
          },
          "end": {
            "line": 145,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newLogic the new logic-contract / owner",
              "subAnnotation": {
                "name": "_newLogic",
                "value": "the new logic-contract / owner",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the current logic contract",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "used to update the corresponding logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "sets the logic-address / owner of the contract",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetNodeDeposit",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer for the node"
            },
            {
              "name": "_newDeposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new deposit"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "sets the deposit of the node",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminSetNodeDeposit(address _signer, uint _newDeposit) external onlyLogicContract returns (bool) {\n        SignerInformation memory si = signerIndex[_signer];\n        In3Node storage node = nodes[si.index];\n        require(node.signer == _signer, \"not the correct signer of the in3-node\");\n        node.deposit = _newDeposit;\n        return true;\n    }",
          "start": {
            "line": 153,
            "column": 4
          },
          "end": {
            "line": 159,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newDeposit the new deposit",
              "subAnnotation": {
                "name": "_newDeposit",
                "value": "the new deposit",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer for the node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer for the node",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "used to delete the deposit after being being convicted",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "sets the deposit of the node",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetStage",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-account for the stage to be set"
            },
            {
              "name": "_stage",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new stage"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "sets the stage of a certain signer",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminSetStage(address _signer, uint _stage) external onlyLogicContract returns (bool) {\n        SignerInformation storage si = signerIndex[_signer];\n        si.stage = _stage;\n        return true;\n    }",
          "start": {
            "line": 166,
            "column": 4
          },
          "end": {
            "line": 170,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_stage the new stage",
              "subAnnotation": {
                "name": "_stage",
                "value": "the new stage",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer-account for the stage to be set",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-account for the stage to be set",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the current logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "sets the stage of a certain signer",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetSupportedToken",
          "params": [
            {
              "name": "_newToken",
              "solidityType": {
                "name": "IERC20",
                "userDefined": true,
                "references": [
                  "IERC20"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new token-contract"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "changes the supported token",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminSetSupportedToken(IERC20 _newToken) external onlyLogicContract returns (bool) {\n        require(address(_newToken) != address(0x0), \"0x0 is invalid\");\n        supportedToken = _newToken;\n        return true;\n    }",
          "start": {
            "line": 176,
            "column": 4
          },
          "end": {
            "line": 180,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newToken the new token-contract",
              "subAnnotation": {
                "name": "_newToken",
                "value": "the new token-contract",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the current logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "changes the supported token",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetTimeout",
          "params": [
            {
              "name": "_newTimeout",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new timeout"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "sets a new timeout for all node until they can recive their deposit",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminSetTimeout(uint _newTimeout) external onlyLogicContract returns (bool) {\n        timeout = _newTimeout;\n        return true;\n    }",
          "start": {
            "line": 186,
            "column": 4
          },
          "end": {
            "line": 189,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newTimeout the new timeout",
              "subAnnotation": {
                "name": "_newTimeout",
                "value": "the new timeout",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the current logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "sets a new timeout for all node until they can recive their deposit",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminTransferDeposit",
          "params": [
            {
              "name": "_to",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the address that shall receive tokens"
            },
            {
              "name": "_amount",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the amount of tokens to be transfered"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "transfers tokens to an address",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function adminTransferDeposit(address _to, uint _amount) external onlyLogicContract returns (bool) {\n        require(supportedToken.transfer(_to, _amount), \"ERC20 token transfer failed\");\n        return true;\n    }",
          "start": {
            "line": 197,
            "column": 4
          },
          "end": {
            "line": 200,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true when successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_amount the amount of tokens to be transfered",
              "subAnnotation": {
                "name": "_amount",
                "value": "the amount of tokens to be transfered",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_to the address that shall receive tokens",
              "subAnnotation": {
                "name": "_to",
                "value": "the address that shall receive tokens",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "used when returning deposit or rewarding successfull convicts",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "transfers tokens to an address",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "setConvict",
          "params": [
            {
              "name": "_hash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning."
            },
            {
              "name": "_caller",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the address for that called convict in the logic-contract"
            }
          ],
          "returnParams": [],
          "description": "writes a value to te convictMapping to be used later for revealConvict in the logic contract",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function setConvict(bytes32 _hash, address _caller) external onlyLogicContract {\n        convictMapping[_caller][_hash] = block.number;\n    }",
          "start": {
            "line": 205,
            "column": 4
          },
          "end": {
            "line": 207,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_caller the address for that called convict in the logic-contract",
              "subAnnotation": {
                "name": "_caller",
                "value": "the address for that called convict in the logic-contract",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
              "subAnnotation": {
                "name": "_hash",
                "value": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "writes a value to te convictMapping to be used later for revealConvict in the logic contract",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "registerNodeFor",
          "params": [
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url of the node, has to be unique"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "properties of the node"
            },
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer of the in3-node"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "how many requests per second the node is able to handle"
            },
            {
              "name": "_owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the owner of the node"
            },
            {
              "name": "_deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the deposit of the in3-node (in erc20 token)"
            },
            {
              "name": "_stage",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the stage of the in3-node"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "registers a new node in the nodeList",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        address _owner,\n        uint _deposit,\n        uint _stage\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // sets the information of the owner\n        SignerInformation storage si = signerIndex[_signer];\n\n        si.index = nodes.length;\n        si.owner = _owner;\n        si.stage = _stage;\n\n        // add new In3Node\n        In3Node memory m;\n        m.url = _url;\n        m.props = _props;\n        m.signer = _signer;\n        m.deposit = _deposit;\n        // solium-disable-next-line security/no-block-members\n        m.registerTime = uint64(block.timestamp); // solhint-disable-line not-rely-on-time\n        m.weight = _weight;\n\n        m.proofHash = _calcProofHashInternal(m);\n        nodes.push(m);\n\n        // sets the information of the url\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = _signer;\n        urlIndex[urlHash] = ui;\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n        return true;\n    }",
          "start": {
            "line": 219,
            "column": 4
          },
          "end": {
            "line": 268,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_stage the stage of the in3-node",
              "subAnnotation": {
                "name": "_stage",
                "value": "the stage of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_deposit the deposit of the in3-node (in erc20 token)",
              "subAnnotation": {
                "name": "_deposit",
                "value": "the deposit of the in3-node (in erc20 token)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_owner the owner of the node",
              "subAnnotation": {
                "name": "_owner",
                "value": "the owner of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_weight how many requests per second the node is able to handle",
              "subAnnotation": {
                "name": "_weight",
                "value": "how many requests per second the node is able to handle",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props properties of the node",
              "subAnnotation": {
                "name": "_props",
                "value": "properties of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url of the node, has to be unique",
              "subAnnotation": {
                "name": "_url",
                "value": "the url of the node, has to be unique",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "registers a new node in the nodeList",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transferOwnership",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node, used as an identifier"
            },
            {
              "name": "_newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new owner"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "changes the ownership of an in3-node",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function transferOwnership(address _signer, address _newOwner)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation storage si = signerIndex[_signer];\n        emit LogOwnershipChanged(_signer, si.owner, _newOwner);\n\n        si.owner = _newOwner;\n        return true;\n    }",
          "start": {
            "line": 275,
            "column": 4
          },
          "end": {
            "line": 285,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newOwner the new owner",
              "subAnnotation": {
                "name": "_newOwner",
                "value": "the new owner",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node, used as an identifier",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node, used as an identifier",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "changes the ownership of an in3-node",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "unregisteringNode",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer of the in3-node"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "removes a node from the registry",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function unregisteringNode(address _signer)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n\n        SignerInformation storage si = signerIndex[_signer];\n        In3Node memory n = nodes[si.index];\n        _unregisterNodeInternal(si, n);\n        return true;\n    }",
          "start": {
            "line": 291,
            "column": 4
          },
          "end": {
            "line": 301,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signer the signer of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "removes a node from the registry",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "updateNode",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node, used as an identifier"
            },
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url, will be changed if different from the current one"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new properties, will be changed if different from the current onec"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the amount of requests per second the node is able to handle"
            },
            {
              "name": "_deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the deposit of the in3-node"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "updates a node by adding the msg.value to the deposit and setting the props or timeout",
          "modifiers": [
            "onlyLogicContract",
            "external",
            null
          ],
          "source": "function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation memory si = signerIndex[_signer];\n\n        In3Node storage node = nodes[si.index];\n\n        bytes32 newURL = keccak256(bytes(_url));\n        bytes32 oldURL = keccak256(bytes(node.url));\n\n        // the url got changed\n        if (newURL != oldURL) {\n\n            // make sure the new url is not already in use\n            require(!urlIndex[newURL].used, \"url is already in use\");\n\n            UrlInformation memory ui;\n            ui.used = true;\n            ui.signer = node.signer;\n            urlIndex[newURL] = ui;\n            node.url = _url;\n\n            // deleting the old entry\n            delete urlIndex[oldURL];\n        }\n\n        if (_deposit != node.deposit) {\n            node.deposit = _deposit;\n        }\n\n        if (_props != node.props) {\n            node.props = _props;\n        }\n\n        if (_weight != node.weight) {\n            node.weight = _weight;\n        }\n\n        node.proofHash = _calcProofHashInternal(node);\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            node.deposit\n        );\n\n        return true;\n    }",
          "start": {
            "line": 312,
            "column": 4
          },
          "end": {
            "line": 368,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true if successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_deposit the deposit of the in3-node",
              "subAnnotation": {
                "name": "_deposit",
                "value": "the deposit of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_weight the amount of requests per second the node is able to handle",
              "subAnnotation": {
                "name": "_weight",
                "value": "the amount of requests per second the node is able to handle",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props the new properties, will be changed if different from the current onec",
              "subAnnotation": {
                "name": "_props",
                "value": "the new properties, will be changed if different from the current onec",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url, will be changed if different from the current one",
              "subAnnotation": {
                "name": "_url",
                "value": "the url, will be changed if different from the current one",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node, used as an identifier",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node, used as an identifier",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when trying to change the url to an already existing one",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "updates a node by adding the msg.value to the deposit and setting the props or timeout",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getIn3NodeInformation",
          "params": [
            {
              "name": "_index",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the position of the NodeInfo in the node-array"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "In3Node",
                "userDefined": true,
                "references": [
                  "In3Node"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "returns the In3Node-struct of a certain index",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function getIn3NodeInformation(uint _index) external view returns (In3Node memory) {\n        return nodes[_index];\n    }",
          "start": {
            "line": 373,
            "column": 4
          },
          "end": {
            "line": 375,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the In3Node for the index provided",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_index the position of the NodeInfo in the node-array",
              "subAnnotation": {
                "name": "_index",
                "value": "the position of the NodeInfo in the node-array",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "returns the In3Node-struct of a certain index",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getSignerInformation",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer for the information to get"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "SignerInformation",
                "userDefined": true,
                "references": [
                  "SignerInformation"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "returns the SignerInformation of a signer",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function getSignerInformation(address _signer) external view returns (SignerInformation memory) {\n        return signerIndex[_signer];\n    }",
          "start": {
            "line": 380,
            "column": 4
          },
          "end": {
            "line": 382,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the SignerInformation for the signer",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signer the signer for the information to get",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer for the information to get",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "returns the SignerInformation of a signer",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "getNodeInfromationBySigner",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer for the information to get"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "In3Node",
                "userDefined": true,
                "references": [
                  "In3Node"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "returns the In3Node-struct for a signer",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function getNodeInfromationBySigner(address _signer) external view returns (In3Node memory) {\n        return nodes[signerIndex[_signer].index];\n    }",
          "start": {
            "line": 387,
            "column": 4
          },
          "end": {
            "line": 389,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the In3Node-struct for that signer",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signer the signer for the information to get",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer for the information to get",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "returns the In3Node-struct for a signer",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "totalNodes",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "length of the nodelist",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function totalNodes() external view returns (uint) {\n        return nodes.length;\n    }",
          "start": {
            "line": 393,
            "column": 4
          },
          "end": {
            "line": 395,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the number of total in3-nodes",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "length of the nodelist",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminSetSignerInfo",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the address for the information to be set"
            },
            {
              "name": "_si",
              "solidityType": {
                "name": "SignerInformation",
                "userDefined": true,
                "references": [
                  "SignerInformation"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the new signerInformation"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "sets the signerInformation for a signer",
          "modifiers": [
            "onlyLogicContract",
            "public",
            null
          ],
          "source": "function adminSetSignerInfo(address _signer, SignerInformation memory _si) public onlyLogicContract returns (bool) {\n        signerIndex[_signer] = _si;\n        return true;\n    }",
          "start": {
            "line": 404,
            "column": 4
          },
          "end": {
            "line": 407,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "true when successfull",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_si the new signerInformation",
              "subAnnotation": {
                "name": "_si",
                "value": "the new signerInformation",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the address for the information to be set",
              "subAnnotation": {
                "name": "_signer",
                "value": "the address for the information to be set",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "public-visibility due to passing a struct to the function",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "gets used for updating the information after returning the deposit",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "only callable by the logic contract",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "sets the signerInformation for a signer",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "_calcProofHashInternal",
          "params": [
            {
              "name": "_node",
              "solidityType": {
                "name": "In3Node",
                "userDefined": true,
                "references": [
                  "In3Node"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the in3 node to calculate the hash from"
            }
          ],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "calculates the sha3 hash of the most important properties in order to make the proof more efficient",
          "modifiers": [
            "internal",
            "pure"
          ],
          "source": "function _calcProofHashInternal(In3Node memory _node) internal pure returns (bytes32) {\n\n        return keccak256(\n            abi.encodePacked(\n                _node.deposit,\n                _node.registerTime,\n                _node.props,\n                _node.weight,\n                _node.signer,\n                _node.url\n            )\n        );\n    }",
          "start": {
            "line": 412,
            "column": 4
          },
          "end": {
            "line": 424,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the hash of the properties of an in3-node",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_node the in3 node to calculate the hash from",
              "subAnnotation": {
                "name": "_node",
                "value": "the in3 node to calculate the hash from",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "calculates the sha3 hash of the most important properties in order to make the proof more efficient",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "_unregisterNodeInternal",
          "params": [
            {
              "name": "_si",
              "solidityType": {
                "name": "SignerInformation",
                "userDefined": true,
                "references": [
                  "SignerInformation"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "information of the signer"
            },
            {
              "name": "_n",
              "solidityType": {
                "name": "In3Node",
                "userDefined": true,
                "references": [
                  "In3Node"
                ],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "information of the in3-node"
            }
          ],
          "returnParams": [],
          "description": "Handles the setting of the unregister values for a node internally",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function _unregisterNodeInternal(SignerInformation  storage _si, In3Node memory _n) internal {\n\n        // solium-disable-next-line security/no-block-members\n        _si.lockedTime = uint64(block.timestamp + timeout);// solhint-disable-line not-rely-on-time\n        _si.depositAmount = _n.deposit;\n\n        _removeNodeInternal(_si.index);\n    }",
          "start": {
            "line": 429,
            "column": 4
          },
          "end": {
            "line": 436,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_n information of the in3-node",
              "subAnnotation": {
                "name": "_n",
                "value": "information of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_si information of the signer",
              "subAnnotation": {
                "name": "_si",
                "value": "information of the signer",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "Handles the setting of the unregister values for a node internally",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "_removeNodeInternal",
          "params": [
            {
              "name": "_nodeIndex",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the nodeIndex to be removed"
            }
          ],
          "returnParams": [],
          "description": "removes a node from the node-array",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function _removeNodeInternal(uint _nodeIndex) internal {\n\n        require(_nodeIndex < nodes.length, \"invalid node index provided\");\n        // trigger event\n        emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n        uint length = nodes.length;\n\n        assert(length > 0);\n\n        // we set the SignerIndex to an invalid index.\n        signerIndex[nodes[_nodeIndex].signer].index = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n        // move the last entry to the removed one.\n        In3Node memory m = nodes[length - 1];\n        nodes[_nodeIndex] = m;\n\n        SignerInformation storage si = signerIndex[m.signer];\n        si.index = _nodeIndex;\n        nodes.length--;\n    }",
          "start": {
            "line": 440,
            "column": 4
          },
          "end": {
            "line": 461,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_nodeIndex the nodeIndex to be removed",
              "subAnnotation": {
                "name": "_nodeIndex",
                "value": "the nodeIndex to be removed",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "removes a node from the node-array",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "title",
          "value": "Registry for IN3-nodes",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0xac1b824795e1eb1f6e609fe0da9b9af8beaab60f",
      "meta": null,
      "modifiers": [
        {
          "name": "onlyLogicContract",
          "params": []
        }
      ],
      "events": [
        {
          "name": "LogNodeRegistered",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNodeRemoved",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNodeUpdated",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogOwnershipChanged",
          "params": [
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "oldOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogDepositReturned",
          "params": [
            {
              "name": "nodeOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "amount",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryData {\n\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint props, address signer, uint deposit);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a user received its deposit back\n    event LogDepositReturned(address nodeOwner, uint amount);\n\n    struct In3Node {\n        string url;                         /// the url of the node\n\n        uint deposit;                       /// stored deposit\n\n        uint64 registerTime;                /// timestamp when the node was registered\n        uint192 props;                      /// a list of properties-flags representing the capabilities of the node\n\n        uint64 weight;                      ///  the flag for (future) incentivisation\n        address signer;                     /// the signer for requests\n\n        bytes32 proofHash;                  /// keccak(deposit,timeout,registerTime,props,signer,url)\n    }\n\n    /// information of a in3-node owner\n    struct SignerInformation {\n        uint64 lockedTime;                  /// timestamp until the deposit of an in3-node can not be withdrawn after the node was removed\n        address owner;                      /// the owner of the node\n\n        uint stage;                       /// state of the address\n\n        uint depositAmount;                 /// amount of deposit to be locked, used only after a node had been removed\n\n        uint index;                         /// current index-position of the node in the node-array\n    }\n\n    /// information of an url\n    struct UrlInformation {\n        bool used;                          /// flag whether the url is currently used\n        address signer;                     /// address of the owner of the url\n    }\n\n    /// node list of incubed nodes\n    In3Node[] public nodes;\n\n    /// id used for signing in3-requests and in order to prevent cross-chain convicts\n    /// in case a fork happens there is the possibility that a node can be convicted on the other fork,\n    /// because they would use the very same registryId. Nevertheless we cannot change the registryId.\n    /// So in case of a fork a node should chose one of the forks and unregister his nodes on the others.\n    /// In this case it is also recommend to not sign requests until the node get his deposits from the forked contracts\n    bytes32 public registryId;\n\n    /// timeout for all nodes until they can receive their deposit after unregistering\n    uint public timeout;\n\n    /// tokenContract to be used\n    IERC20 public supportedToken;\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n\n    /// Logic-contract that is allowed to call certain functions within the smart contract\n    address public ownerContract;\n\n    /// mapping for information of the owner\n    mapping (address => SignerInformation) public signerIndex;\n\n    /// mapping for the information of the url\n    /// can be used to access the SignerInformation-struct\n    mapping (bytes32 => UrlInformation) public urlIndex;\n\n    /// mapping for convicts: sender => convictHash => block number when the convict-tx had been mined)\n    mapping (address => mapping(bytes32 => uint)) public convictMapping;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyLogicContract {\n        require(ownerContract == msg.sender, \"not the owner\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        // solium-disable-next-line security/no-block-members\n        registryId = keccak256(abi.encodePacked(address(this), blockhash(block.number-1)));\n        timeout = 40 days;\n        ownerContract = msg.sender;\n    }\n\n    /// @notice removes an in3-node from the nodeList\n    /// @param _signer the signer-address of the in3-node\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyLogicContract\n    {\n        SignerInformation memory si = signerIndex[_signer];\n        _removeNodeInternal(si.index);\n\n    }\n\n    /// @notice sets the logic-address / owner of the contract\n    /// @dev used to update the corresponding logic contract\n    /// @dev only callable by the current logic contract\n    /// @param _newLogic the new logic-contract / owner\n    /// @return true if successfull\n    function adminSetLogic(address _newLogic) external onlyLogicContract returns (bool) {\n        require(address(_newLogic) != address(0x0), \"no address provided\");\n        ownerContract = _newLogic;\n        return true;\n    }\n\n    /// @notice sets the deposit of the node\n    /// @dev only callable by the logic contract\n    /// @dev used to delete the deposit after being being convicted\n    /// @param _signer the signer for the node\n    /// @param _newDeposit the new deposit\n    /// @return true if successfull\n    function adminSetNodeDeposit(address _signer, uint _newDeposit) external onlyLogicContract returns (bool) {\n        SignerInformation memory si = signerIndex[_signer];\n        In3Node storage node = nodes[si.index];\n        require(node.signer == _signer, \"not the correct signer of the in3-node\");\n        node.deposit = _newDeposit;\n        return true;\n    }\n\n    /// @notice sets the stage of a certain signer\n    /// @dev only callable by the current logic contract\n    /// @param _signer the signer-account for the stage to be set\n    /// @param _stage the new stage\n    /// @return true if successfull\n    function adminSetStage(address _signer, uint _stage) external onlyLogicContract returns (bool) {\n        SignerInformation storage si = signerIndex[_signer];\n        si.stage = _stage;\n        return true;\n    }\n\n    /// @notice changes the supported token\n    /// @dev only callable by the current logic contract\n    /// @param _newToken the new token-contract\n    /// @return true if successfull\n    function adminSetSupportedToken(IERC20 _newToken) external onlyLogicContract returns (bool) {\n        require(address(_newToken) != address(0x0), \"0x0 is invalid\");\n        supportedToken = _newToken;\n        return true;\n    }\n\n    /// @notice sets a new timeout for all node until they can recive their deposit\n    /// @dev only callable by the current logic contract\n    /// @param _newTimeout the new timeout\n    /// @return true if successfull\n    function adminSetTimeout(uint _newTimeout) external onlyLogicContract returns (bool) {\n        timeout = _newTimeout;\n        return true;\n    }\n\n    /// @notice transfers tokens to an address\n    /// @dev used when returning deposit or rewarding successfull convicts\n    /// @dev only callable by the logic contract\n    /// @param _to the address that shall receive tokens\n    /// @param _amount the amount of tokens to be transfered\n    /// @return true when successfull\n    function adminTransferDeposit(address _to, uint _amount) external onlyLogicContract returns (bool) {\n        require(supportedToken.transfer(_to, _amount), \"ERC20 token transfer failed\");\n        return true;\n    }\n\n    /// @notice writes a value to te convictMapping to be used later for revealConvict in the logic contract\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @param _caller the address for that called convict in the logic-contract\n    function setConvict(bytes32 _hash, address _caller) external onlyLogicContract {\n        convictMapping[_caller][_hash] = block.number;\n    }\n\n    /// @notice registers a new node in the nodeList\n    /// @dev only callable by the logic contract\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the in3-node (in erc20 token)\n    /// @param _stage the stage of the in3-node\n    /// @return true if successfull\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        address _owner,\n        uint _deposit,\n        uint _stage\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // sets the information of the owner\n        SignerInformation storage si = signerIndex[_signer];\n\n        si.index = nodes.length;\n        si.owner = _owner;\n        si.stage = _stage;\n\n        // add new In3Node\n        In3Node memory m;\n        m.url = _url;\n        m.props = _props;\n        m.signer = _signer;\n        m.deposit = _deposit;\n        // solium-disable-next-line security/no-block-members\n        m.registerTime = uint64(block.timestamp); // solhint-disable-line not-rely-on-time\n        m.weight = _weight;\n\n        m.proofHash = _calcProofHashInternal(m);\n        nodes.push(m);\n\n        // sets the information of the url\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = _signer;\n        urlIndex[urlHash] = ui;\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n        return true;\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @return true if successfull\n    function transferOwnership(address _signer, address _newOwner)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation storage si = signerIndex[_signer];\n        emit LogOwnershipChanged(_signer, si.owner, _newOwner);\n\n        si.owner = _newOwner;\n        return true;\n    }\n\n    /// @notice removes a node from the registry\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer of the in3-node\n    /// @return true if successfull\n    function unregisteringNode(address _signer)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n\n        SignerInformation storage si = signerIndex[_signer];\n        In3Node memory n = nodes[si.index];\n        _unregisterNodeInternal(si, n);\n        return true;\n    }\n\n    /// @notice updates a node by adding the msg.value to the deposit and setting the props or timeout\n    /// @dev reverts when trying to change the url to an already existing one\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _deposit the deposit of the in3-node\n    /// @return true if successfull\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation memory si = signerIndex[_signer];\n\n        In3Node storage node = nodes[si.index];\n\n        bytes32 newURL = keccak256(bytes(_url));\n        bytes32 oldURL = keccak256(bytes(node.url));\n\n        // the url got changed\n        if (newURL != oldURL) {\n\n            // make sure the new url is not already in use\n            require(!urlIndex[newURL].used, \"url is already in use\");\n\n            UrlInformation memory ui;\n            ui.used = true;\n            ui.signer = node.signer;\n            urlIndex[newURL] = ui;\n            node.url = _url;\n\n            // deleting the old entry\n            delete urlIndex[oldURL];\n        }\n\n        if (_deposit != node.deposit) {\n            node.deposit = _deposit;\n        }\n\n        if (_props != node.props) {\n            node.props = _props;\n        }\n\n        if (_weight != node.weight) {\n            node.weight = _weight;\n        }\n\n        node.proofHash = _calcProofHashInternal(node);\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            node.deposit\n        );\n\n        return true;\n    }\n\n    /// @notice returns the In3Node-struct of a certain index\n    /// @param _index the position of the NodeInfo in the node-array\n    /// @return the In3Node for the index provided\n    function getIn3NodeInformation(uint _index) external view returns (In3Node memory) {\n        return nodes[_index];\n    }\n\n    /// @notice returns the SignerInformation of a signer\n    /// @param _signer the signer for the information to get\n    /// @return the SignerInformation for the signer\n    function getSignerInformation(address _signer) external view returns (SignerInformation memory) {\n        return signerIndex[_signer];\n    }\n\n    /// @notice returns the In3Node-struct for a signer\n    /// @param _signer the signer for the information to get\n    /// @return the In3Node-struct for that signer\n    function getNodeInfromationBySigner(address _signer) external view returns (In3Node memory) {\n        return nodes[signerIndex[_signer].index];\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodes.length;\n    }\n\n    /// @notice sets the signerInformation for a signer\n    /// @dev only callable by the logic contract\n    /// @dev gets used for updating the information after returning the deposit\n    /// @dev public-visibility due to passing a struct to the function\n    /// @param _signer the address for the information to be set\n    /// @param _si the new signerInformation\n    /// @return true when successfull\n    function adminSetSignerInfo(address _signer, SignerInformation memory _si) public onlyLogicContract returns (bool) {\n        signerIndex[_signer] = _si;\n        return true;\n    }\n\n    /// @notice calculates the sha3 hash of the most important properties in order to make the proof more efficient\n    /// @param _node the in3 node to calculate the hash from\n    /// @return the hash of the properties of an in3-node\n    function _calcProofHashInternal(In3Node memory _node) internal pure returns (bytes32) {\n\n        return keccak256(\n            abi.encodePacked(\n                _node.deposit,\n                _node.registerTime,\n                _node.props,\n                _node.weight,\n                _node.signer,\n                _node.url\n            )\n        );\n    }\n\n    /// @notice Handles the setting of the unregister values for a node internally\n    /// @param _si information of the signer\n    /// @param _n information of the in3-node\n    function _unregisterNodeInternal(SignerInformation  storage _si, In3Node memory _n) internal {\n\n        // solium-disable-next-line security/no-block-members\n        _si.lockedTime = uint64(block.timestamp + timeout);// solhint-disable-line not-rely-on-time\n        _si.depositAmount = _n.deposit;\n\n        _removeNodeInternal(_si.index);\n    }\n\n    /// @notice removes a node from the node-array\n    /// @param _nodeIndex the nodeIndex to be removed\n    function _removeNodeInternal(uint _nodeIndex) internal {\n\n        require(_nodeIndex < nodes.length, \"invalid node index provided\");\n        // trigger event\n        emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n        uint length = nodes.length;\n\n        assert(length > 0);\n\n        // we set the SignerIndex to an invalid index.\n        signerIndex[nodes[_nodeIndex].signer].index = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n        // move the last entry to the removed one.\n        In3Node memory m = nodes[length - 1];\n        nodes[_nodeIndex] = m;\n\n        SignerInformation storage si = signerIndex[m.signer];\n        si.index = _nodeIndex;\n        nodes.length--;\n    }\n}\n",
      "inFile": "NodeRegistryData.sol",
      "references": [
        "In3Node",
        "IERC20",
        "SignerInformation",
        "UrlInformation"
      ],
      "isAbstract": false
    },
    {
      "elementType": 0,
      "name": "NodeRegistryLogic",
      "baseContracts": [],
      "enumerations": [
        {
          "name": "NodeRegistryLogic.Stages",
          "shortName": "Stages",
          "parentName": "NodeRegistryLogic",
          "elementType": 2,
          "entries": [
            {
              "name": "NotInUse",
              "index": 0
            },
            {
              "name": "Active",
              "index": 1
            },
            {
              "name": "Convicted",
              "index": 2
            },
            {
              "name": "DepositNotWithdrawn",
              "index": 3
            }
          ]
        }
      ],
      "structs": [],
      "stateVariables": [
        {
          "name": "blockRegistry",
          "solidityType": {
            "name": "BlockhashRegistry",
            "userDefined": true,
            "references": [
              "BlockhashRegistry"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "blockRegistry",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "BlockhashRegistry",
                  "userDefined": true,
                  "references": [
                    "BlockhashRegistry"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "nodeRegistryData",
          "solidityType": {
            "name": "NodeRegistryData",
            "userDefined": true,
            "references": [
              "NodeRegistryData"
            ],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "nodeRegistryData",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "NodeRegistryData",
                  "userDefined": true,
                  "references": [
                    "NodeRegistryData"
                  ],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "timestampAdminKeyActive",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "timestampAdminKeyActive",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "adminKey",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "adminKey",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "updateTimeout",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "updateTimeout",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "pendingNewLogic",
          "solidityType": {
            "name": "address",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "pendingNewLogic",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "address",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "YEAR_DEFINITION",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "internal",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [],
            "name": "YEAR_DEFINITION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "maxDepositFirstYear",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "maxDepositFirstYear",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "minDeposit",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "minDeposit",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        },
        {
          "name": "VERSION",
          "solidityType": {
            "name": "uint",
            "userDefined": false,
            "references": [],
            "isArray": false
          },
          "visibility": "public",
          "getter": {
            "annotations": null,
            "description": null,
            "end": null,
            "modifiers": [
              "view",
              "public"
            ],
            "name": "VERSION",
            "params": [],
            "returnParams": [
              {
                "name": "",
                "solidityType": {
                  "name": "uint",
                  "userDefined": false,
                  "references": [],
                  "isArray": false
                },
                "isStorage": false,
                "isIndexed": false,
                "description": null
              }
            ],
            "source": null,
            "start": null
          }
        }
      ],
      "functions": [
        {
          "name": "constructor",
          "params": [
            {
              "name": "_blockRegistry",
              "solidityType": {
                "name": "BlockhashRegistry",
                "userDefined": true,
                "references": [
                  "BlockhashRegistry"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "address of a BlockhashRegistry-contract"
            },
            {
              "name": "_nodeRegistryData",
              "solidityType": {
                "name": "NodeRegistryData",
                "userDefined": true,
                "references": [
                  "NodeRegistryData"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "address of the nodeRegistryData-contract"
            },
            {
              "name": "_minDeposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "returnParams": [],
          "description": "constructor",
          "modifiers": [
            "public",
            null
          ],
          "source": "constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }",
          "start": {
            "line": 100,
            "column": 4
          },
          "end": {
            "line": 113,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "cannot be deployed in a genesis block",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_nodeRegistryData address of the nodeRegistryData-contract",
              "subAnnotation": {
                "name": "_nodeRegistryData",
                "value": "address of the nodeRegistryData-contract",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_blockRegistry address of a BlockhashRegistry-contract",
              "subAnnotation": {
                "name": "_blockRegistry",
                "value": "address of a BlockhashRegistry-contract",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "constructor",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "activateNewLogic",
          "params": [],
          "returnParams": [],
          "description": "applies the pending update",
          "modifiers": [
            "external",
            null
          ],
          "source": "function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }",
          "start": {
            "line": 118,
            "column": 4
          },
          "end": {
            "line": 124,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "only callable after 47 since the new logicContract has been registered",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "this will remove the current contract as owner of the NodeRegistryData",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "applies the pending update",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminRemoveNodeFromRegistry",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node"
            }
          ],
          "returnParams": [],
          "description": "removes an in3-server from the registry",
          "modifiers": [
            "onlyAdmin",
            "external",
            null
          ],
          "source": "function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
          "start": {
            "line": 130,
            "column": 4
          },
          "end": {
            "line": 146,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "only callable in the 1st year after deployment",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "only callable by the adminKey-account",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "removes an in3-server from the registry",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "adminUpdateLogic",
          "params": [
            {
              "name": "_newLogic",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the address of the new logic contract"
            }
          ],
          "returnParams": [],
          "description": "",
          "modifiers": [
            "onlyAdmin",
            "external",
            null
          ],
          "source": "function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }",
          "start": {
            "line": 153,
            "column": 4
          },
          "end": {
            "line": 161,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_newLogic the address of the new logic contract",
              "subAnnotation": {
                "name": "_newLogic",
                "value": "the address of the new logic contract",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the owner of the contract",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "convict",
          "params": [
            {
              "name": "_hash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning."
            }
          ],
          "returnParams": [],
          "description": "must be called before revealConvict\ncommits a blocknumber and a hash",
          "modifiers": [
            "external",
            null
          ],
          "source": "function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }",
          "start": {
            "line": 167,
            "column": 4
          },
          "end": {
            "line": 169,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "The v,r,s paramaters are from the signature of the wrong blockhash that the node provided",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
              "subAnnotation": {
                "name": "_hash",
                "value": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "must be called before revealConvict",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "commits a blocknumber and a hash",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "registerNode",
          "params": [
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url of the node, has to be unique"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "properties of the node"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "how many requests per second the node is able to handle"
            },
            {
              "name": "_deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the deposit in erc20 tokens"
            }
          ],
          "returnParams": [],
          "description": "register a new node with the sender as owner",
          "modifiers": [
            "external",
            null
          ],
          "source": "function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }",
          "start": {
            "line": 177,
            "column": 4
          },
          "end": {
            "line": 194,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_deposit the deposit in erc20 tokens",
              "subAnnotation": {
                "name": "_deposit",
                "value": "the deposit in erc20 tokens",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_weight how many requests per second the node is able to handle",
              "subAnnotation": {
                "name": "_weight",
                "value": "how many requests per second the node is able to handle",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props properties of the node",
              "subAnnotation": {
                "name": "_props",
                "value": "properties of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url of the node, has to be unique",
              "subAnnotation": {
                "name": "_url",
                "value": "the url of the node, has to be unique",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "the supported tokens have to be approved by the owner first",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "register a new node with the sender as owner",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "registerNodeFor",
          "params": [
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url of the node, has to be unique"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "properties of the node"
            },
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer of the in3-node"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "how many requests per second the node is able to handle"
            },
            {
              "name": "_depositAmount",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "deposit in erc20 tokens"
            },
            {
              "name": "_v",
              "solidityType": {
                "name": "uint8",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "v of the signed message"
            },
            {
              "name": "_r",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "r of the signed message"
            },
            {
              "name": "_s",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "s of the signed message"
            }
          ],
          "returnParams": [],
          "description": "register a new node as a owner using a different signer address",
          "modifiers": [
            "external",
            null
          ],
          "source": "function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }",
          "start": {
            "line": 210,
            "column": 4
          },
          "end": {
            "line": 253,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "will revert when a wrong signature has been provided",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "which is calculated by the hash of the url, properties, weight and the owner",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "in order to prove that the owner has controll over the signer-address he has to sign a message",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "will call the registerNodeInteral function",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_s s of the signed message",
              "subAnnotation": {
                "name": "_s",
                "value": "s of the signed message",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_r r of the signed message",
              "subAnnotation": {
                "name": "_r",
                "value": "r of the signed message",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_v v of the signed message",
              "subAnnotation": {
                "name": "_v",
                "value": "v of the signed message",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_depositAmount deposit in erc20 tokens",
              "subAnnotation": {
                "name": "_depositAmount",
                "value": "deposit in erc20 tokens",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_weight how many requests per second the node is able to handle",
              "subAnnotation": {
                "name": "_weight",
                "value": "how many requests per second the node is able to handle",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props properties of the node",
              "subAnnotation": {
                "name": "_props",
                "value": "properties of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url of the node, has to be unique",
              "subAnnotation": {
                "name": "_url",
                "value": "the url of the node, has to be unique",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "the supported tokens have to be approved by the owner first",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "register a new node as a owner using a different signer address",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "returnDeposit",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the former signer"
            }
          ],
          "returnParams": [],
          "description": "returns the deposit of a former node after the timeout has passed",
          "modifiers": [
            "external",
            null
          ],
          "source": "function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }",
          "start": {
            "line": 258,
            "column": 4
          },
          "end": {
            "line": 282,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_signer the former signer",
              "subAnnotation": {
                "name": "_signer",
                "value": "the former signer",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "only callable by the owner of the former signer",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "returns the deposit of a former node after the timeout has passed",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "revealConvict",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the address that signed the wrong blockhash"
            },
            {
              "name": "_blockhash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the wrongly provided blockhash"
            },
            {
              "name": "_blockNumber",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "number of the wrongly provided blockhash"
            },
            {
              "name": "_v",
              "solidityType": {
                "name": "uint8",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "v of the signature"
            },
            {
              "name": "_r",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "r of the signature"
            },
            {
              "name": "_s",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "s of the signature"
            }
          ],
          "returnParams": [],
          "description": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
          "modifiers": [
            "external",
            null
          ],
          "source": "function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }",
          "start": {
            "line": 296,
            "column": 4
          },
          "end": {
            "line": 366,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "reverts when the wrong convict hash (see convict-function) is used",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when the _signer did not sign the block",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when trying to reveal immediately after calling convict",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when tryin to convict someone with a correct blockhash",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_s s of the signature",
              "subAnnotation": {
                "name": "_s",
                "value": "s of the signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_r r of the signature",
              "subAnnotation": {
                "name": "_r",
                "value": "r of the signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_v v of the signature",
              "subAnnotation": {
                "name": "_v",
                "value": "v of the signature",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_blockNumber number of the wrongly provided blockhash",
              "subAnnotation": {
                "name": "_blockNumber",
                "value": "number of the wrongly provided blockhash",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_blockhash the wrongly provided blockhash",
              "subAnnotation": {
                "name": "_blockhash",
                "value": "the wrongly provided blockhash",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the address that signed the wrong blockhash",
              "subAnnotation": {
                "name": "_signer",
                "value": "the address that signed the wrong blockhash",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "transferOwnership",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node, used as an identifier"
            },
            {
              "name": "_newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new owner"
            }
          ],
          "returnParams": [],
          "description": "changes the ownership of an in3-node",
          "modifiers": [
            "external",
            null
          ],
          "source": "function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }",
          "start": {
            "line": 374,
            "column": 4
          },
          "end": {
            "line": 388,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "reverts when the sender is not the current owner",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when trying to pass ownership to 0x0",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when trying to change ownership of an inactive node",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_newOwner the new owner",
              "subAnnotation": {
                "name": "_newOwner",
                "value": "the new owner",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node, used as an identifier",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node, used as an identifier",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "changes the ownership of an in3-node",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "unregisteringNode",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer of the in3-node"
            }
          ],
          "returnParams": [],
          "description": "doing so will also lock his deposit for the timeout of the node\na node owner can unregister a node, removing it from the nodeList",
          "modifiers": [
            "external",
            null
          ],
          "source": "function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
          "start": {
            "line": 396,
            "column": 4
          },
          "end": {
            "line": 412,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "reverts when the node is not active",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when not called by the owner of the node",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when the provided address is not an in3-signer",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_signer the signer of the in3-node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer of the in3-node",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "doing so will also lock his deposit for the timeout of the node",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "a node owner can unregister a node, removing it from the nodeList",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "updateNode",
          "params": [
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer-address of the in3-node, used as an identifier"
            },
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url, will be changed if different from the current one"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new properties, will be changed if different from the current onec"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the amount of requests per second the node is able to handle"
            },
            {
              "name": "_additionalDeposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the additional deposit in erc20-token"
            }
          ],
          "returnParams": [],
          "description": "updates a node by changing its props",
          "modifiers": [
            "external",
            null
          ],
          "source": "function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }",
          "start": {
            "line": 424,
            "column": 4
          },
          "end": {
            "line": 464,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "reverts when trying to change the url to an already existing one",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when the signer does not own a node",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "reverts when the sender is not the owner of the node",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_additionalDeposit the additional deposit in erc20-token",
              "subAnnotation": {
                "name": "_additionalDeposit",
                "value": "the additional deposit in erc20-token",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_weight the amount of requests per second the node is able to handle",
              "subAnnotation": {
                "name": "_weight",
                "value": "the amount of requests per second the node is able to handle",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props the new properties, will be changed if different from the current onec",
              "subAnnotation": {
                "name": "_props",
                "value": "the new properties, will be changed if different from the current onec",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url, will be changed if different from the current one",
              "subAnnotation": {
                "name": "_url",
                "value": "the url, will be changed if different from the current one",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer-address of the in3-node, used as an identifier",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer-address of the in3-node, used as an identifier",
                "subAnnotation": null
              }
            },
            {
              "name": "dev",
              "value": "if there is an additional deposit the owner has to approve the tokenTransfer before",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "updates a node by changing its props",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "supportedToken",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "IERC20",
                "userDefined": true,
                "references": [
                  "IERC20"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "returns the supported ERC20 token for registering a node",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }",
          "start": {
            "line": 468,
            "column": 4
          },
          "end": {
            "line": 470,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the supported ERC20 token",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "returns the supported ERC20 token for registering a node",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "totalNodes",
          "params": [],
          "returnParams": [
            {
              "name": null,
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": ""
            }
          ],
          "description": "length of the nodelist",
          "modifiers": [
            "external",
            "view"
          ],
          "source": "function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }",
          "start": {
            "line": 474,
            "column": 4
          },
          "end": {
            "line": 476,
            "column": 4
          },
          "annotations": [
            {
              "name": "return",
              "value": "the number of total in3-nodes",
              "subAnnotation": null
            },
            {
              "name": "notice",
              "value": "length of the nodelist",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "_checkNodePropertiesInternal",
          "params": [
            {
              "name": "_deposit",
              "solidityType": {
                "name": "uint256",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the new amount of deposit a server has"
            }
          ],
          "returnParams": [],
          "description": "function to check whether the allowed amount of deposit per server has been reached",
          "modifiers": [
            "internal",
            "view"
          ],
          "source": "function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }",
          "start": {
            "line": 482,
            "column": 4
          },
          "end": {
            "line": 490,
            "column": 4
          },
          "annotations": [
            {
              "name": "dev",
              "value": "will fail when the deposit is less than the minDeposit",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "will fail when the deposit is greater than the maxDepositFirstYear in the 1st year",
              "subAnnotation": null
            },
            {
              "name": "param",
              "value": "_deposit the new amount of deposit a server has",
              "subAnnotation": {
                "name": "_deposit",
                "value": "the new amount of deposit a server has",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "function to check whether the allowed amount of deposit per server has been reached",
              "subAnnotation": null
            }
          ]
        },
        {
          "name": "_registerNodeInternal",
          "params": [
            {
              "name": "_url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": true,
              "isIndexed": false,
              "description": "the url of the node"
            },
            {
              "name": "_props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the properties of the node"
            },
            {
              "name": "_signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the signer of the node"
            },
            {
              "name": "_owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the owner of the node"
            },
            {
              "name": "_deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the deposit of the node"
            },
            {
              "name": "_weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": "the weight of the node (# of requests per second he is able to handle)"
            }
          ],
          "returnParams": [],
          "description": "helper function for registering a node",
          "modifiers": [
            "internal",
            null
          ],
          "source": "function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }",
          "start": {
            "line": 499,
            "column": 4
          },
          "end": {
            "line": 541,
            "column": 4
          },
          "annotations": [
            {
              "name": "param",
              "value": "_weight the weight of the node (# of requests per second he is able to handle)",
              "subAnnotation": {
                "name": "_weight",
                "value": "the weight of the node (# of requests per second he is able to handle)",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_deposit the deposit of the node",
              "subAnnotation": {
                "name": "_deposit",
                "value": "the deposit of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_owner the owner of the node",
              "subAnnotation": {
                "name": "_owner",
                "value": "the owner of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_signer the signer of the node",
              "subAnnotation": {
                "name": "_signer",
                "value": "the signer of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_props the properties of the node",
              "subAnnotation": {
                "name": "_props",
                "value": "the properties of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "param",
              "value": "_url the url of the node",
              "subAnnotation": {
                "name": "_url",
                "value": "the url of the node",
                "subAnnotation": null
              }
            },
            {
              "name": "notice",
              "value": "helper function for registering a node",
              "subAnnotation": null
            }
          ]
        }
      ],
      "annotations": [
        {
          "name": "title",
          "value": "Registry for IN3-nodes",
          "subAnnotation": null
        }
      ],
      "deployedAt": "0x6C095A05764A23156eFD9D603eaDa144a9B1AF33",
      "meta": null,
      "modifiers": [
        {
          "name": "onlyAdmin",
          "params": []
        }
      ],
      "events": [
        {
          "name": "LogNodeRegistered",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNodeConvicted",
          "params": [
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNodeRemoved",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNodeUpdated",
          "params": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogOwnershipChanged",
          "params": [
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "oldOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "newOwner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogNewPendingContract",
          "params": [
            {
              "name": "newPendingContract",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        },
        {
          "name": "LogDepositReturned",
          "params": [
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            },
            {
              "name": "erc20Token",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isIndexed": false,
              "visibility": null
            }
          ]
        }
      ],
      "kind": "contract",
      "heritageDissolved": true,
      "inheritedStateVariables": [],
      "inheritedFunctions": [],
      "inheritedEvents": [],
      "inheritedModifiers": [],
      "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BlockhashRegistry.sol\";\nimport \"./NodeRegistryData.sol\";\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryLogic {\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint192 props, address signer, uint deposit);\n\n    /// a node was convicted\n    event LogNodeConvicted(address signer);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint192 props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a new logic contract got proposed\n    event LogNewPendingContract(address newPendingContract);\n\n    /// deposit has been returned\n    event LogDepositReturned(address signer, address owner, uint deposit, address erc20Token);\n\n    /// Different Stages a node can have\n    enum Stages {\n        NotInUse,                           /// node is not in use, so a new node with the same address can be registered\n        Active,                             /// node is active, so a new node with the same address cannot be registered\n        Convicted,                          /// node is convited, so he is inactive, but cannot be registered anymore\n        DepositNotWithdrawn                 /// node is not in use anymore, but still has some deposit stored within the contract\n    }\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n    /// blockhash registry address\n    BlockhashRegistry public blockRegistry;\n\n    /// address for the data of the nodeRegistry\n    NodeRegistryData public nodeRegistryData;\n\n    /// timestamp until the unregisterKey is active\n    uint public timestampAdminKeyActive;\n\n    /// admin-key to remove some server, only usable within the 1st year\n    address public adminKey;\n\n    /// timestamp when an update of the logic-contract can be applied\n    uint public updateTimeout;\n\n    /// address of an updated logic contract to be applied\n    address public pendingNewLogic;\n\n    /// capping the max deposit timeout on 1 year\n    uint constant internal YEAR_DEFINITION = 1 days * 365;\n\n    /// limit for ether per node in the 1st year\n    uint public maxDepositFirstYear;\n\n    /// min deposit required for registering a node\n    uint public minDeposit;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyAdmin {\n        require(msg.sender == adminKey, \"not the admin\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @param _blockRegistry address of a BlockhashRegistry-contract\n    /// @param _nodeRegistryData address of the nodeRegistryData-contract\n    /// @dev cannot be deployed in a genesis block\n    constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }\n\n    /// @notice applies the pending update\n    /// @dev this will remove the current contract as owner of the NodeRegistryData\n    /// @dev only callable after 47 since the new logicContract has been registered\n    function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }\n\n    /// @notice removes an in3-server from the registry\n    /// @param _signer the signer-address of the in3-node\n    /// @dev only callable by the adminKey-account\n    /// @dev only callable in the 1st year after deployment\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice sets the address for a new (pending) logic\n    ///         the update can only be applied after 47 days,\n    ///         giving all the nodes enough time to unregister their node if they dislike the update\n    /// @dev only callable by the owner of the contract\n    /// @param _newLogic the address of the new logic contract\n    function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }\n\n    /// @notice commits a blocknumber and a hash\n    /// @notice must be called before revealConvict\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @dev The v,r,s paramaters are from the signature of the wrong blockhash that the node provided\n    function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }\n\n    /// @notice register a new node with the sender as owner\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _deposit the deposit in erc20 tokens\n    function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }\n\n    /// @notice register a new node as a owner using a different signer address\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _depositAmount deposit in erc20 tokens\n    /// @param _v v of the signed message\n    /// @param _r r of the signed message\n    /// @param _s s of the signed message\n    /// @dev will call the registerNodeInteral function\n    /// @dev in order to prove that the owner has controll over the signer-address he has to sign a message\n    /// @dev which is calculated by the hash of the url, properties, weight and the owner\n    /// @dev will revert when a wrong signature has been provided\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }\n\n    /// @notice returns the deposit of a former node after the timeout has passed\n    /// @dev only callable by the owner of the former signer\n    /// @param _signer the former signer\n    function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }\n\n    /// @notice reveals the wrongly provided blockhash, so that the node-owner will lose its deposit\n    /// @param _signer the address that signed the wrong blockhash\n    /// @param _blockhash the wrongly provided blockhash\n    /// @param _blockNumber number of the wrongly provided blockhash\n    /// @param _v v of the signature\n    /// @param _r r of the signature\n    /// @param _s s of the signature\n    /// @dev reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry\n    /// @dev reverts when tryin to convict someone with a correct blockhash\n    /// @dev reverts when trying to reveal immediately after calling convict\n    /// @dev reverts when the _signer did not sign the block\n    /// @dev reverts when the wrong convict hash (see convict-function) is used\n    function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @dev reverts when trying to change ownership of an inactive node\n    /// @dev reverts when trying to pass ownership to 0x0\n    /// @dev reverts when the sender is not the current owner\n    function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }\n\n    /// @notice a node owner can unregister a node, removing it from the nodeList\n    /// @notice doing so will also lock his deposit for the timeout of the node\n    /// @param _signer the signer of the in3-node\n    /// @dev reverts when the provided address is not an in3-signer\n    /// @dev reverts when not called by the owner of the node\n    /// @dev reverts when the node is not active\n    function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice updates a node by changing its props\n    /// @dev if there is an additional deposit the owner has to approve the tokenTransfer before\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _additionalDeposit the additional deposit in erc20-token\n    /// @dev reverts when the sender is not the owner of the node\n    /// @dev reverts when the signer does not own a node\n    /// @dev reverts when trying to change the url to an already existing one\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }\n\n    /// @notice returns the supported ERC20 token for registering a node\n    /// @return the supported ERC20 token\n    function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }\n\n    /// @notice function to check whether the allowed amount of deposit per server has been reached\n    /// @param _deposit the new amount of deposit a server has\n    /// @dev will fail when the deposit is greater than the maxDepositFirstYear in the 1st year\n    /// @dev will fail when the deposit is less than the minDeposit\n    function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }\n\n    /// @notice helper function for registering a node\n    /// @param _url the url of the node\n    /// @param _props the properties of the node\n    /// @param _signer the signer of the node\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the node\n    /// @param _weight the weight of the node (# of requests per second he is able to handle)\n    function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }\n\n}\n",
      "inFile": "NodeRegistryLogic.sol",
      "references": [
        "BlockhashRegistry",
        "NodeRegistryData",
        "NodeRegistryData.SignerInformation",
        "NodeRegistryData.In3Node",
        "IERC20"
      ],
      "isAbstract": false
    }
  ],
  "graph": {
    "graph": {
      "cells": [
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 320
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "f678d29c-3e88-466f-b5e0-5a09afaa0c35",
          "z": 1,
          "attrs": {
            "text": {
              "text": "IERC20",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 260
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "3fa201c7-e22f-44b1-be7e-c318ec97474f",
          "z": 2,
          "attrs": {
            "text": {
              "text": "BlockhashRegistry",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 120
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae",
          "z": 3,
          "attrs": {
            "text": {
              "text": "NodeRegistryData",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node node-highlighted",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 60
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91",
          "z": 4,
          "attrs": {
            "text": {
              "text": "In3Node",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 120
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "829863af-68c5-4416-8fc3-b18334a11bcc",
          "z": 5,
          "attrs": {
            "text": {
              "text": "SignerInformation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 180
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d",
          "z": 6,
          "attrs": {
            "text": {
              "text": "UrlInformation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc",
          "z": 7,
          "attrs": {
            "text": {
              "text": "NodeRegistryLogic",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2d2200c5-773c-4796-aed2-ce7604588263",
          "z": 8,
          "attrs": {
            "text": {
              "text": "Stages",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/list-ol.svg"
            },
            "rect": {
              "class": "enum-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "2d2200c5-773c-4796-aed2-ce7604588263"
          },
          "target": {
            "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "0b853a5c-a91d-4657-ac81-4b1b4df05630",
          "z": 27,
          "attrs": {
            ".marker-target": {
              "stroke": "#8e8e8e",
              "fill": "#8e8e8e",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 2,
              "stroke": "#8e8e8e"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91"
          },
          "target": {
            "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "e3cadb4a-6a41-460c-a34f-becf610d1a6f",
          "z": 28,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "829863af-68c5-4416-8fc3-b18334a11bcc"
          },
          "target": {
            "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "bfabef6e-f1e0-4d4a-ba23-d2b88b4e8ab6",
          "z": 29,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        },
        {
          "type": "link",
          "source": {
            "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d"
          },
          "target": {
            "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
          },
          "router": {
            "name": "manhattan",
            "args": {}
          },
          "connector": {
            "name": "normal"
          },
          "id": "f7ba4607-0566-4919-abcd-160adf85b736",
          "z": 30,
          "attrs": {
            ".marker-target": {
              "stroke": "#fe8550",
              "fill": "#fe8550",
              "d": "M 10 0 L 0 5 L 10 10 z"
            },
            ".connection": {
              "stroke-width": 4,
              "stroke": "#fe8550"
            }
          }
        }
      ]
    },
    "inheritanceLinks": [],
    "otherLinks": [
      {
        "type": "link",
        "source": {
          "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91"
        },
        "target": {
          "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "e3cadb4a-6a41-460c-a34f-becf610d1a6f",
        "z": 28,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "829863af-68c5-4416-8fc3-b18334a11bcc"
        },
        "target": {
          "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "bfabef6e-f1e0-4d4a-ba23-d2b88b4e8ab6",
        "z": 29,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d"
        },
        "target": {
          "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "f7ba4607-0566-4919-abcd-160adf85b736",
        "z": 30,
        "attrs": {
          ".marker-target": {
            "stroke": "#8e8e8e",
            "fill": "#8e8e8e",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 2,
            "stroke": "#8e8e8e"
          }
        }
      },
      {
        "type": "link",
        "source": {
          "id": "2d2200c5-773c-4796-aed2-ce7604588263"
        },
        "target": {
          "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc"
        },
        "router": {
          "name": "manhattan",
          "args": {}
        },
        "connector": {
          "name": "normal"
        },
        "id": "0b853a5c-a91d-4657-ac81-4b1b4df05630",
        "z": 31,
        "attrs": {
          ".marker-target": {
            "stroke": "#fe8550",
            "fill": "#fe8550",
            "d": "M 10 0 L 0 5 L 10 10 z"
          },
          ".connection": {
            "stroke-width": 4,
            "stroke": "#fe8550"
          }
        }
      }
    ],
    "nodeIdNamePairs": [
      {
        "nodeElement": {
          "elementType": 0,
          "name": "IERC20",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [],
          "functions": [
            {
              "name": "approve",
              "params": [
                {
                  "name": "spender",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function approve(address spender, uint256 amount) external returns (bool);",
              "start": {
                "line": 25,
                "column": 4
              },
              "end": {
                "line": 25,
                "column": 77
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "Emits an `Approval` event.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transfer",
              "params": [
                {
                  "name": "recipient",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function transfer(address recipient, uint256 amount) external returns (bool);",
              "start": {
                "line": 34,
                "column": 4
              },
              "end": {
                "line": 34,
                "column": 80
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "Emits a `Transfer` event.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transferFrom",
              "params": [
                {
                  "name": "sender",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "recipient",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                null
              ],
              "source": "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);",
              "start": {
                "line": 45,
                "column": 4
              },
              "end": {
                "line": 45,
                "column": 100
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "Emits a `Transfer` event.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "allowance",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "spender",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function allowance(address owner, address spender) external view returns (uint256);",
              "start": {
                "line": 54,
                "column": 4
              },
              "end": {
                "line": 54,
                "column": 86
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "*",
                  "value": "This value changes when `approve` or `transferFrom` are called.",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "totalSupply",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function totalSupply() external view returns (uint256);",
              "start": {
                "line": 59,
                "column": 4
              },
              "end": {
                "line": 59,
                "column": 58
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns the amount of tokens in existence.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "balanceOf",
              "params": [
                {
                  "name": "account",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function balanceOf(address account) external view returns (uint256);",
              "start": {
                "line": 64,
                "column": 4
              },
              "end": {
                "line": 64,
                "column": 71
              },
              "annotations": [
                {
                  "name": "*",
                  "value": "*/",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "Returns the amount of tokens owned by `account`.",
                  "subAnnotation": null
                },
                {
                  "name": "/*",
                  "value": "/**",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "*",
              "value": "*/",
              "subAnnotation": null
            },
            {
              "name": "*",
              "value": "the optional functions; to access them see `ERC20Detailed`.",
              "subAnnotation": null
            },
            {
              "name": "dev",
              "value": "Interface of the ERC20 standard as defined in the EIP. Does not include",
              "subAnnotation": null
            },
            {
              "name": "/*",
              "value": "/**",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "Transfer",
              "params": [
                {
                  "name": "from",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "Approval",
              "params": [
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "spender",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "interface",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "pragma solidity 0.5.10;\n\n// file taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value); // solhint-disable-line\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
          "inFile": "IERC20.sol",
          "references": [],
          "isAbstract": true
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 320
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "f678d29c-3e88-466f-b5e0-5a09afaa0c35",
          "z": 1,
          "attrs": {
            "text": {
              "text": "IERC20",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-alt.svg"
            },
            "rect": {
              "class": "interface-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "BlockhashRegistry",
          "baseContracts": [],
          "enumerations": [],
          "structs": [],
          "stateVariables": [
            {
              "name": "blockhashMapping",
              "solidityType": {
                "name": "(uint => bytes32)",
                "mapping": {
                  "key": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "blockhashMapping",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor() public {\n        snapshot();\n    }",
              "start": {
                "line": 35,
                "column": 4
              },
              "end": {
                "line": 37,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "cannot be deployed in a genesis block",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "searchForAvailableBlock",
              "params": [
                {
                  "name": "_startNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the blocknumber to start searching"
                },
                {
                  "name": "_numBlocks",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the number of blocks to search for"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "searches for an already existing snapshot",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n        uint target = _startNumber + _numBlocks;\n\n        require(target <= block.number || target < _startNumber, \"invalid search\");\n\n        for (uint i = _startNumber; i <= target; i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }",
              "start": {
                "line": 43,
                "column": 4
              },
              "end": {
                "line": 53,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the closes snapshot of found within the given range, 0 else",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_numBlocks the number of blocks to search for",
                  "subAnnotation": {
                    "name": "_numBlocks",
                    "value": "the number of blocks to search for",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_startNumber the blocknumber to start searching",
                  "subAnnotation": {
                    "name": "_startNumber",
                    "value": "the blocknumber to start searching",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "searches for an already existing snapshot",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "recreateBlockheaders",
              "params": [
                {
                  "name": "_blockNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the block number to start recreation from"
                },
                {
                  "name": "_blockheaders",
                  "solidityType": {
                    "name": "bytes[]",
                    "pureName": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)"
                }
              ],
              "returnParams": [],
              "description": "if successfull the last blockhash of the header will be added to the smart contract\nit will be checked whether the provided chain is correct by using the reCalculateBlockheaders function\nonly usable when the given blocknumber is already in the smart contract\nstarts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks",
              "modifiers": [
                "public",
                null
              ],
              "source": "function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n        require(_blockNumber > _blockheaders.length, \"too many blockheaders provided\");\n        require(_blockNumber < block.number, \"cannot recreate a not yet existing block\");\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n\n        uint bnr = _blockNumber - _blockheaders.length;\n        require(blockhashMapping[bnr] == 0x0, \"block already stored\");\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        /// if the blocknumber we want to store is within the last 256 blocks, we use the evm hash\n        if (bnr > block.number-256) {\n            saveBlockNumber(bnr);\n            return;\n        }\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash, _blockNumber);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }",
              "start": {
                "line": 64,
                "column": 4
              },
              "end": {
                "line": 88,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "function is public due to the usage of a dynamic bytes array (not yet supported for external functions)",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when the chain of headers is incorrect",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when there is not parent block already stored in the contract",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_blockheaders array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)",
                  "subAnnotation": {
                    "name": "_blockheaders",
                    "value": "array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_blockNumber the block number to start recreation from",
                  "subAnnotation": {
                    "name": "_blockNumber",
                    "value": "the block number to start recreation from",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "if successfull the last blockhash of the header will be added to the smart contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "it will be checked whether the provided chain is correct by using the reCalculateBlockheaders function",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "only usable when the given blocknumber is already in the smart contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "starts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "saveBlockNumber",
              "params": [
                {
                  "name": "_blockNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the blocknumber to be stored"
                }
              ],
              "returnParams": [],
              "description": "stores a certain blockhash to the state",
              "modifiers": [
                "public",
                null
              ],
              "source": "function saveBlockNumber(uint _blockNumber) public {\n\n        require(blockhashMapping[_blockNumber] == 0x0, \"block already stored\");\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }",
              "start": {
                "line": 93,
                "column": 4
              },
              "end": {
                "line": 103,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "reverts if the block can't be found inside the evm",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_blockNumber the blocknumber to be stored",
                  "subAnnotation": {
                    "name": "_blockNumber",
                    "value": "the blocknumber to be stored",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "stores a certain blockhash to the state",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "snapshot",
              "params": [],
              "returnParams": [],
              "description": "stores the currentBlock-1 in the smart contract",
              "modifiers": [
                "public",
                null
              ],
              "source": "function snapshot() public {\n        /// blockhash cannot return the current block, so we use the previous block\n        saveBlockNumber(block.number-1);\n    }",
              "start": {
                "line": 106,
                "column": 4
              },
              "end": {
                "line": 109,
                "column": 4
              },
              "annotations": [
                {
                  "name": "notice",
                  "value": "stores the currentBlock-1 in the smart contract",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getRlpUint",
              "params": [
                {
                  "name": "_data",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "rlp encoded data"
                },
                {
                  "name": "_offset",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the offset"
                }
              ],
              "returnParams": [
                {
                  "name": "value",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "",
              "modifiers": [
                "public",
                "pure"
              ],
              "source": "function getRlpUint(bytes memory _data, uint _offset) public pure returns (uint value) {\n        /// get the byte at offset to figure out the length of the value\n        uint8 c = uint8(_data[_offset]);\n\n        /// we will not accept values above 0xa0, since this would mean we either have a list\n        /// or we have a value with a length greater 32 bytes\n        /// for the use cases (getting the blockNumber or difficulty) we can accept these limits.\n        require(c < 0xa1, \"lists or long fields are not supported\");\n        if (c < 0x80)  // single byte-item\n            return uint(c); // value = byte\n\n        // length of the value\n        uint len = c - 0x80;\n        // we skip the first 32 bytes since they contain the legth and add 1 because this byte contains the length of the value.\n        uint dataOffset = _offset + 33;\n\n        /// check the range\n        require(_offset + len <= _data.length, \"invalid offset\");\n\n        /// we are using assembly because we need to get the value of the next `len` bytes\n        /// This is done by copying the bytes in the \"scratch space\" so we can take the first 32 bytes as value afterwards.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0x0, 0) // clean memory in the \"scratch space\"\n            mstore(\n                sub (0x20, len), // we move the position so the first bytes from rlp are the last bytes within the 32 bytes\n                mload(\n                    add ( _data, dataOffset ) // load the data from rlp-data\n                )\n            )\n            value:=mload(0x0)\n        }\n        return value;\n    }",
              "start": {
                "line": 116,
                "column": 4
              },
              "end": {
                "line": 149,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the value",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_offset the offset",
                  "subAnnotation": {
                    "name": "_offset",
                    "value": "the offset",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_data rlp encoded data",
                  "subAnnotation": {
                    "name": "_data",
                    "value": "rlp encoded data",
                    "subAnnotation": null
                  }
                }
              ]
            },
            {
              "name": "getParentAndBlockhash",
              "params": [
                {
                  "name": "_blockheader",
                  "solidityType": {
                    "name": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "a serialized (rlp-encoded) blockheader"
                }
              ],
              "returnParams": [
                {
                  "name": "parentHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "bhash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                },
                {
                  "name": "blockNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "returns the blockhash and the parent blockhash from the provided blockheader",
              "modifiers": [
                "public",
                "pure"
              ],
              "source": "function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash, uint blockNumber) {\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n        uint8 first = uint8(_blockheader[0]);\n\n        /// calculates the offset\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n        require(first > 0xf7, \"invalid offset\");\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n        uint offset = first - 0xf7 + 2;\n        require(offset+32 < _blockheader.length, \"invalid length\");\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // we load the provided blockheader\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        _blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n        // verify parentHash\n        require(parentHash != 0x0, \"invalid parentHash\");\n        bhash = keccak256(_blockheader);\n\n        // get the blockNumber\n        // we set the offset to the difficulty field which is fixed since all fields between them have a fixed length.\n        offset += 444;\n\n        // we get the first byte for the difficulty field ( which is a field with a dynamic length)\n        // and calculate the length, because the next field is the blockNumber\n        uint8 c = uint8(_blockheader[offset]);\n        require(c < 0xa1, \"lists or long fields are not supported for difficulty\");\n        offset += c < 0x80 ? 1 : (c - 0x80 + 1);\n\n        // we fetch the blockNumber from the calculated offset\n        blockNumber = getRlpUint(_blockheader, offset);\n    }",
              "start": {
                "line": 154,
                "column": 4
              },
              "end": {
                "line": 198,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the parent blockhash and the keccak256 of the provided blockheader (= the corresponding blockhash)",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_blockheader a serialized (rlp-encoded) blockheader",
                  "subAnnotation": {
                    "name": "_blockheader",
                    "value": "a serialized (rlp-encoded) blockheader",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "returns the blockhash and the parent blockhash from the provided blockheader",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "reCalculateBlockheaders",
              "params": [
                {
                  "name": "_blockheaders",
                  "solidityType": {
                    "name": "bytes[]",
                    "pureName": "bytes",
                    "userDefined": false,
                    "references": [],
                    "isArray": true
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "array with serialized blockheaders in reverse order, i.e. from youngest to oldest"
                },
                {
                  "name": "_bHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "blockhash of the 1st element of the _blockheaders-array"
                },
                {
                  "name": "_blockNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader"
                }
              ],
              "returnParams": [
                {
                  "name": "bhash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])\nstarts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks",
              "modifiers": [
                "public",
                "view"
              ],
              "source": "function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash, uint _blockNumber) public view returns (bytes32 bhash) {\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n        require(_bHash != 0x0, \"invalid blockhash provided\");\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n        uint calcBlockNumber = 0;\n        uint currentBlockNumber = _blockNumber;\n\n        /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n        for (uint i = 0; i < _blockheaders.length; i++) {\n            /// we alway need to verify the blockHash and parentHash\n            /// but in addition we also verify the blockNumber.\n            /// This is just safety-check in case of detected hash collision which makes it almost impossible\n            /// to add an invalid header which might create the correct hash.\n            (calcParent, calcBlockhash, calcBlockNumber) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash || calcParent == 0x0 || calcBlockNumber != currentBlockNumber) {\n                return 0x0;\n            }\n\n            uint currentBlock = block.number > 256 ? block.number : 256;\n\n            if (currentBlock - 256 < calcBlockNumber) {\n                if (calcBlockhash != blockhash(calcBlockNumber)) {\n                    return 0x0;\n                }\n            }\n            currentBlockhash = calcParent;\n            currentBlockNumber--;\n        }\n\n        return currentBlockhash;\n    }",
              "start": {
                "line": 206,
                "column": 4
              },
              "end": {
                "line": 239,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "0x0 if the functions detects a wrong chaining of blocks, blockhash of the last element of the array otherwhise",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_blockNumber blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader",
                  "subAnnotation": {
                    "name": "_blockNumber",
                    "value": "blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_bHash blockhash of the 1st element of the _blockheaders-array",
                  "subAnnotation": {
                    "name": "_bHash",
                    "value": "blockhash of the 1st element of the _blockheaders-array",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_blockheaders array with serialized blockheaders in reverse order, i.e. from youngest to oldest",
                  "subAnnotation": {
                    "name": "_blockheaders",
                    "value": "array with serialized blockheaders in reverse order, i.e. from youngest to oldest",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "starts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "title",
              "value": "Registry for blockhashes",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x7fC74751ef749707B4968091d7ddB53ef7Aa322F",
          "meta": null,
          "modifiers": [],
          "events": [
            {
              "name": "LogBlockhashAdded",
              "params": [
                {
                  "name": "blockNr",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                },
                {
                  "name": "bhash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": true,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\n\n/// @title Registry for blockhashes\ncontract BlockhashRegistry {\n\n    /// a new blockhash and its number has been added to the contract\n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    /// maps the blocknumber to its blockhash\n    mapping(uint => bytes32) public blockhashMapping;\n\n    /// constructor, calls snapshot-function when contract get deployed as entry point\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        snapshot();\n    }\n\n    /// @notice searches for an already existing snapshot\n    /// @param _startNumber the blocknumber to start searching\n    /// @param _numBlocks the number of blocks to search for\n    /// @return the closes snapshot of found within the given range, 0 else\n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n        uint target = _startNumber + _numBlocks;\n\n        require(target <= block.number || target < _startNumber, \"invalid search\");\n\n        for (uint i = _startNumber; i <= target; i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    /// @notice starts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice only usable when the given blocknumber is already in the smart contract\n    /// @notice it will be checked whether the provided chain is correct by using the reCalculateBlockheaders function\n    /// @notice if successfull the last blockhash of the header will be added to the smart contract\n    /// @param _blockNumber the block number to start recreation from\n    /// @param _blockheaders array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)\n    /// @dev reverts when there is not parent block already stored in the contract\n    /// @dev reverts when the chain of headers is incorrect\n    /// @dev function is public due to the usage of a dynamic bytes array (not yet supported for external functions)\n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n        require(_blockNumber > _blockheaders.length, \"too many blockheaders provided\");\n        require(_blockNumber < block.number, \"cannot recreate a not yet existing block\");\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n\n        uint bnr = _blockNumber - _blockheaders.length;\n        require(blockhashMapping[bnr] == 0x0, \"block already stored\");\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        /// if the blocknumber we want to store is within the last 256 blocks, we use the evm hash\n        if (bnr > block.number-256) {\n            saveBlockNumber(bnr);\n            return;\n        }\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash, _blockNumber);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    /// @notice stores a certain blockhash to the state\n    /// @param _blockNumber the blocknumber to be stored\n    /// @dev reverts if the block can't be found inside the evm\n    function saveBlockNumber(uint _blockNumber) public {\n\n        require(blockhashMapping[_blockNumber] == 0x0, \"block already stored\");\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    /// @notice stores the currentBlock-1 in the smart contract\n    function snapshot() public {\n        /// blockhash cannot return the current block, so we use the previous block\n        saveBlockNumber(block.number-1);\n    }\n\n    /// @notice returns the value from rlp encoded data.\n    ///         This function is limited to only value up to 32 bytes length!\n    /// @param _data rlp encoded data\n    /// @param _offset the offset\n    /// @return the value\n    function getRlpUint(bytes memory _data, uint _offset) public pure returns (uint value) {\n        /// get the byte at offset to figure out the length of the value\n        uint8 c = uint8(_data[_offset]);\n\n        /// we will not accept values above 0xa0, since this would mean we either have a list\n        /// or we have a value with a length greater 32 bytes\n        /// for the use cases (getting the blockNumber or difficulty) we can accept these limits.\n        require(c < 0xa1, \"lists or long fields are not supported\");\n        if (c < 0x80)  // single byte-item\n            return uint(c); // value = byte\n\n        // length of the value\n        uint len = c - 0x80;\n        // we skip the first 32 bytes since they contain the legth and add 1 because this byte contains the length of the value.\n        uint dataOffset = _offset + 33;\n\n        /// check the range\n        require(_offset + len <= _data.length, \"invalid offset\");\n\n        /// we are using assembly because we need to get the value of the next `len` bytes\n        /// This is done by copying the bytes in the \"scratch space\" so we can take the first 32 bytes as value afterwards.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0x0, 0) // clean memory in the \"scratch space\"\n            mstore(\n                sub (0x20, len), // we move the position so the first bytes from rlp are the last bytes within the 32 bytes\n                mload(\n                    add ( _data, dataOffset ) // load the data from rlp-data\n                )\n            )\n            value:=mload(0x0)\n        }\n        return value;\n    }\n\n    /// @notice returns the blockhash and the parent blockhash from the provided blockheader\n    /// @param _blockheader a serialized (rlp-encoded) blockheader\n    /// @return the parent blockhash and the keccak256 of the provided blockheader (= the corresponding blockhash)\n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash, uint blockNumber) {\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n        uint8 first = uint8(_blockheader[0]);\n\n        /// calculates the offset\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n        require(first > 0xf7, \"invalid offset\");\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n        uint offset = first - 0xf7 + 2;\n        require(offset+32 < _blockheader.length, \"invalid length\");\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // we load the provided blockheader\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        _blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n        // verify parentHash\n        require(parentHash != 0x0, \"invalid parentHash\");\n        bhash = keccak256(_blockheader);\n\n        // get the blockNumber\n        // we set the offset to the difficulty field which is fixed since all fields between them have a fixed length.\n        offset += 444;\n\n        // we get the first byte for the difficulty field ( which is a field with a dynamic length)\n        // and calculate the length, because the next field is the blockNumber\n        uint8 c = uint8(_blockheader[offset]);\n        require(c < 0xa1, \"lists or long fields are not supported for difficulty\");\n        offset += c < 0x80 ? 1 : (c - 0x80 + 1);\n\n        // we fetch the blockNumber from the calculated offset\n        blockNumber = getRlpUint(_blockheader, offset);\n    }\n\n    /// @notice starts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])\n    /// @param _blockheaders array with serialized blockheaders in reverse order, i.e. from youngest to oldest\n    /// @param _bHash blockhash of the 1st element of the _blockheaders-array\n    /// @param _blockNumber blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader\n    /// @return 0x0 if the functions detects a wrong chaining of blocks, blockhash of the last element of the array otherwhise\n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash, uint _blockNumber) public view returns (bytes32 bhash) {\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n        require(_bHash != 0x0, \"invalid blockhash provided\");\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n        uint calcBlockNumber = 0;\n        uint currentBlockNumber = _blockNumber;\n\n        /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n        for (uint i = 0; i < _blockheaders.length; i++) {\n            /// we alway need to verify the blockHash and parentHash\n            /// but in addition we also verify the blockNumber.\n            /// This is just safety-check in case of detected hash collision which makes it almost impossible\n            /// to add an invalid header which might create the correct hash.\n            (calcParent, calcBlockhash, calcBlockNumber) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash || calcParent == 0x0 || calcBlockNumber != currentBlockNumber) {\n                return 0x0;\n            }\n\n            uint currentBlock = block.number > 256 ? block.number : 256;\n\n            if (currentBlock - 256 < calcBlockNumber) {\n                if (calcBlockhash != blockhash(calcBlockNumber)) {\n                    return 0x0;\n                }\n            }\n            currentBlockhash = calcParent;\n            currentBlockNumber--;\n        }\n\n        return currentBlockhash;\n    }\n}\n",
          "inFile": "BlockhashRegistry.sol",
          "references": [],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 260
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "3fa201c7-e22f-44b1-be7e-c318ec97474f",
          "z": 2,
          "attrs": {
            "text": {
              "text": "BlockhashRegistry",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": []
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "NodeRegistryData",
          "baseContracts": [],
          "enumerations": [],
          "structs": [
            {
              "name": "NodeRegistryData.In3Node",
              "shortName": "In3Node",
              "parentName": "NodeRegistryData",
              "elementType": 1,
              "fields": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "registerTime",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "proofHash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                }
              ]
            },
            {
              "name": "NodeRegistryData.SignerInformation",
              "shortName": "SignerInformation",
              "parentName": "NodeRegistryData",
              "elementType": 1,
              "fields": [
                {
                  "name": "lockedTime",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "stage",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "depositAmount",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "index",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                }
              ]
            },
            {
              "name": "NodeRegistryData.UrlInformation",
              "shortName": "UrlInformation",
              "parentName": "NodeRegistryData",
              "elementType": 1,
              "fields": [
                {
                  "name": "used",
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "visibility": null
                }
              ]
            }
          ],
          "stateVariables": [
            {
              "name": "nodes",
              "solidityType": {
                "name": "In3Node[]",
                "pureName": "In3Node",
                "userDefined": true,
                "references": [],
                "isArray": true
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "nodes",
                "params": [
                  {
                    "solidityType": {
                      "isArray": false,
                      "name": "uint256",
                      "references": [],
                      "userDefined": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "In3Node",
                      "userDefined": true,
                      "references": [
                        "In3Node"
                      ],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "In3Node",
                      "userDefined": true,
                      "references": [
                        "In3Node"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "registryId",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "registryId",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "timeout",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "timeout",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "supportedToken",
              "solidityType": {
                "name": "IERC20",
                "userDefined": true,
                "references": [
                  "IERC20"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "supportedToken",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "IERC20",
                      "userDefined": true,
                      "references": [
                        "IERC20"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "ownerContract",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "ownerContract",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "signerIndex",
              "solidityType": {
                "name": "(address => SignerInformation)",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "SignerInformation",
                    "userDefined": true,
                    "references": [
                      "SignerInformation"
                    ],
                    "isArray": false
                  }
                },
                "userDefined": true,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "signerIndex",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "SignerInformation",
                      "userDefined": true,
                      "references": [
                        "SignerInformation"
                      ],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "SignerInformation",
                      "userDefined": true,
                      "references": [
                        "SignerInformation"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "urlIndex",
              "solidityType": {
                "name": "(bytes32 => UrlInformation)",
                "mapping": {
                  "key": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "UrlInformation",
                    "userDefined": true,
                    "references": [
                      "UrlInformation"
                    ],
                    "isArray": false
                  }
                },
                "userDefined": true,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "urlIndex",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "UrlInformation",
                      "userDefined": true,
                      "references": [
                        "UrlInformation"
                      ],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "UrlInformation",
                      "userDefined": true,
                      "references": [
                        "UrlInformation"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "convictMapping",
              "solidityType": {
                "name": "(address => (bytes32 => uint))",
                "mapping": {
                  "key": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "value": {
                    "name": "(bytes32 => uint)",
                    "mapping": {
                      "key": {
                        "name": "bytes32",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      },
                      "value": {
                        "name": "uint",
                        "userDefined": false,
                        "references": [],
                        "isArray": false
                      }
                    },
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  }
                },
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "convictMapping",
                "params": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "(bytes32 => uint)",
                      "mapping": {
                        "key": {
                          "name": "bytes32",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        },
                        "value": {
                          "name": "uint",
                          "userDefined": false,
                          "references": [],
                          "isArray": false
                        }
                      },
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  },
                  {
                    "name": "",
                    "solidityType": {
                      "name": "bytes32",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null,
                    "lastType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    }
                  }
                ],
                "returnParams": [
                  {
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [],
              "returnParams": [],
              "description": "constructor",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor() public {\n        // solium-disable-next-line security/no-block-members\n        registryId = keccak256(abi.encodePacked(address(this), blockhash(block.number-1)));\n        timeout = 40 days;\n        ownerContract = msg.sender;\n    }",
              "start": {
                "line": 118,
                "column": 4
              },
              "end": {
                "line": 123,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "cannot be deployed in a genesis block",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "constructor",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminRemoveNodeFromRegistry",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node"
                }
              ],
              "returnParams": [],
              "description": "removes an in3-node from the nodeList",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyLogicContract\n    {\n        SignerInformation memory si = signerIndex[_signer];\n        _removeNodeInternal(si.index);\n\n    }",
              "start": {
                "line": 127,
                "column": 4
              },
              "end": {
                "line": 134,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "removes an in3-node from the nodeList",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetLogic",
              "params": [
                {
                  "name": "_newLogic",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new logic-contract / owner"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "sets the logic-address / owner of the contract",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminSetLogic(address _newLogic) external onlyLogicContract returns (bool) {\n        require(address(_newLogic) != address(0x0), \"no address provided\");\n        ownerContract = _newLogic;\n        return true;\n    }",
              "start": {
                "line": 141,
                "column": 4
              },
              "end": {
                "line": 145,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newLogic the new logic-contract / owner",
                  "subAnnotation": {
                    "name": "_newLogic",
                    "value": "the new logic-contract / owner",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the current logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "used to update the corresponding logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "sets the logic-address / owner of the contract",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetNodeDeposit",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer for the node"
                },
                {
                  "name": "_newDeposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new deposit"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "sets the deposit of the node",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminSetNodeDeposit(address _signer, uint _newDeposit) external onlyLogicContract returns (bool) {\n        SignerInformation memory si = signerIndex[_signer];\n        In3Node storage node = nodes[si.index];\n        require(node.signer == _signer, \"not the correct signer of the in3-node\");\n        node.deposit = _newDeposit;\n        return true;\n    }",
              "start": {
                "line": 153,
                "column": 4
              },
              "end": {
                "line": 159,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newDeposit the new deposit",
                  "subAnnotation": {
                    "name": "_newDeposit",
                    "value": "the new deposit",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer for the node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer for the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "used to delete the deposit after being being convicted",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "sets the deposit of the node",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetStage",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-account for the stage to be set"
                },
                {
                  "name": "_stage",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new stage"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "sets the stage of a certain signer",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminSetStage(address _signer, uint _stage) external onlyLogicContract returns (bool) {\n        SignerInformation storage si = signerIndex[_signer];\n        si.stage = _stage;\n        return true;\n    }",
              "start": {
                "line": 166,
                "column": 4
              },
              "end": {
                "line": 170,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_stage the new stage",
                  "subAnnotation": {
                    "name": "_stage",
                    "value": "the new stage",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer-account for the stage to be set",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-account for the stage to be set",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the current logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "sets the stage of a certain signer",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetSupportedToken",
              "params": [
                {
                  "name": "_newToken",
                  "solidityType": {
                    "name": "IERC20",
                    "userDefined": true,
                    "references": [
                      "IERC20"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new token-contract"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "changes the supported token",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminSetSupportedToken(IERC20 _newToken) external onlyLogicContract returns (bool) {\n        require(address(_newToken) != address(0x0), \"0x0 is invalid\");\n        supportedToken = _newToken;\n        return true;\n    }",
              "start": {
                "line": 176,
                "column": 4
              },
              "end": {
                "line": 180,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newToken the new token-contract",
                  "subAnnotation": {
                    "name": "_newToken",
                    "value": "the new token-contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the current logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "changes the supported token",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetTimeout",
              "params": [
                {
                  "name": "_newTimeout",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new timeout"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "sets a new timeout for all node until they can recive their deposit",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminSetTimeout(uint _newTimeout) external onlyLogicContract returns (bool) {\n        timeout = _newTimeout;\n        return true;\n    }",
              "start": {
                "line": 186,
                "column": 4
              },
              "end": {
                "line": 189,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newTimeout the new timeout",
                  "subAnnotation": {
                    "name": "_newTimeout",
                    "value": "the new timeout",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the current logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "sets a new timeout for all node until they can recive their deposit",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminTransferDeposit",
              "params": [
                {
                  "name": "_to",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the address that shall receive tokens"
                },
                {
                  "name": "_amount",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the amount of tokens to be transfered"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "transfers tokens to an address",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function adminTransferDeposit(address _to, uint _amount) external onlyLogicContract returns (bool) {\n        require(supportedToken.transfer(_to, _amount), \"ERC20 token transfer failed\");\n        return true;\n    }",
              "start": {
                "line": 197,
                "column": 4
              },
              "end": {
                "line": 200,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true when successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_amount the amount of tokens to be transfered",
                  "subAnnotation": {
                    "name": "_amount",
                    "value": "the amount of tokens to be transfered",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_to the address that shall receive tokens",
                  "subAnnotation": {
                    "name": "_to",
                    "value": "the address that shall receive tokens",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "used when returning deposit or rewarding successfull convicts",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "transfers tokens to an address",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "setConvict",
              "params": [
                {
                  "name": "_hash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning."
                },
                {
                  "name": "_caller",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the address for that called convict in the logic-contract"
                }
              ],
              "returnParams": [],
              "description": "writes a value to te convictMapping to be used later for revealConvict in the logic contract",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function setConvict(bytes32 _hash, address _caller) external onlyLogicContract {\n        convictMapping[_caller][_hash] = block.number;\n    }",
              "start": {
                "line": 205,
                "column": 4
              },
              "end": {
                "line": 207,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_caller the address for that called convict in the logic-contract",
                  "subAnnotation": {
                    "name": "_caller",
                    "value": "the address for that called convict in the logic-contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                  "subAnnotation": {
                    "name": "_hash",
                    "value": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "writes a value to te convictMapping to be used later for revealConvict in the logic contract",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "registerNodeFor",
              "params": [
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url of the node, has to be unique"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "properties of the node"
                },
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer of the in3-node"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "how many requests per second the node is able to handle"
                },
                {
                  "name": "_owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the owner of the node"
                },
                {
                  "name": "_deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the deposit of the in3-node (in erc20 token)"
                },
                {
                  "name": "_stage",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the stage of the in3-node"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "registers a new node in the nodeList",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        address _owner,\n        uint _deposit,\n        uint _stage\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // sets the information of the owner\n        SignerInformation storage si = signerIndex[_signer];\n\n        si.index = nodes.length;\n        si.owner = _owner;\n        si.stage = _stage;\n\n        // add new In3Node\n        In3Node memory m;\n        m.url = _url;\n        m.props = _props;\n        m.signer = _signer;\n        m.deposit = _deposit;\n        // solium-disable-next-line security/no-block-members\n        m.registerTime = uint64(block.timestamp); // solhint-disable-line not-rely-on-time\n        m.weight = _weight;\n\n        m.proofHash = _calcProofHashInternal(m);\n        nodes.push(m);\n\n        // sets the information of the url\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = _signer;\n        urlIndex[urlHash] = ui;\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n        return true;\n    }",
              "start": {
                "line": 219,
                "column": 4
              },
              "end": {
                "line": 268,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_stage the stage of the in3-node",
                  "subAnnotation": {
                    "name": "_stage",
                    "value": "the stage of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_deposit the deposit of the in3-node (in erc20 token)",
                  "subAnnotation": {
                    "name": "_deposit",
                    "value": "the deposit of the in3-node (in erc20 token)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_owner the owner of the node",
                  "subAnnotation": {
                    "name": "_owner",
                    "value": "the owner of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_weight how many requests per second the node is able to handle",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "how many requests per second the node is able to handle",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props properties of the node",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "properties of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url of the node, has to be unique",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url of the node, has to be unique",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "registers a new node in the nodeList",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transferOwnership",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node, used as an identifier"
                },
                {
                  "name": "_newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new owner"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "changes the ownership of an in3-node",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function transferOwnership(address _signer, address _newOwner)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation storage si = signerIndex[_signer];\n        emit LogOwnershipChanged(_signer, si.owner, _newOwner);\n\n        si.owner = _newOwner;\n        return true;\n    }",
              "start": {
                "line": 275,
                "column": 4
              },
              "end": {
                "line": 285,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newOwner the new owner",
                  "subAnnotation": {
                    "name": "_newOwner",
                    "value": "the new owner",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node, used as an identifier",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node, used as an identifier",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "changes the ownership of an in3-node",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "unregisteringNode",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer of the in3-node"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "removes a node from the registry",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function unregisteringNode(address _signer)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n\n        SignerInformation storage si = signerIndex[_signer];\n        In3Node memory n = nodes[si.index];\n        _unregisterNodeInternal(si, n);\n        return true;\n    }",
              "start": {
                "line": 291,
                "column": 4
              },
              "end": {
                "line": 301,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signer the signer of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "removes a node from the registry",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "updateNode",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node, used as an identifier"
                },
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url, will be changed if different from the current one"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new properties, will be changed if different from the current onec"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the amount of requests per second the node is able to handle"
                },
                {
                  "name": "_deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the deposit of the in3-node"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "updates a node by adding the msg.value to the deposit and setting the props or timeout",
              "modifiers": [
                "onlyLogicContract",
                "external",
                null
              ],
              "source": "function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation memory si = signerIndex[_signer];\n\n        In3Node storage node = nodes[si.index];\n\n        bytes32 newURL = keccak256(bytes(_url));\n        bytes32 oldURL = keccak256(bytes(node.url));\n\n        // the url got changed\n        if (newURL != oldURL) {\n\n            // make sure the new url is not already in use\n            require(!urlIndex[newURL].used, \"url is already in use\");\n\n            UrlInformation memory ui;\n            ui.used = true;\n            ui.signer = node.signer;\n            urlIndex[newURL] = ui;\n            node.url = _url;\n\n            // deleting the old entry\n            delete urlIndex[oldURL];\n        }\n\n        if (_deposit != node.deposit) {\n            node.deposit = _deposit;\n        }\n\n        if (_props != node.props) {\n            node.props = _props;\n        }\n\n        if (_weight != node.weight) {\n            node.weight = _weight;\n        }\n\n        node.proofHash = _calcProofHashInternal(node);\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            node.deposit\n        );\n\n        return true;\n    }",
              "start": {
                "line": 312,
                "column": 4
              },
              "end": {
                "line": 368,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true if successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_deposit the deposit of the in3-node",
                  "subAnnotation": {
                    "name": "_deposit",
                    "value": "the deposit of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_weight the amount of requests per second the node is able to handle",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "the amount of requests per second the node is able to handle",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props the new properties, will be changed if different from the current onec",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "the new properties, will be changed if different from the current onec",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url, will be changed if different from the current one",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url, will be changed if different from the current one",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node, used as an identifier",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node, used as an identifier",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when trying to change the url to an already existing one",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "updates a node by adding the msg.value to the deposit and setting the props or timeout",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getIn3NodeInformation",
              "params": [
                {
                  "name": "_index",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the position of the NodeInfo in the node-array"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "In3Node",
                    "userDefined": true,
                    "references": [
                      "In3Node"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "returns the In3Node-struct of a certain index",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function getIn3NodeInformation(uint _index) external view returns (In3Node memory) {\n        return nodes[_index];\n    }",
              "start": {
                "line": 373,
                "column": 4
              },
              "end": {
                "line": 375,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the In3Node for the index provided",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_index the position of the NodeInfo in the node-array",
                  "subAnnotation": {
                    "name": "_index",
                    "value": "the position of the NodeInfo in the node-array",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "returns the In3Node-struct of a certain index",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getSignerInformation",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer for the information to get"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "SignerInformation",
                    "userDefined": true,
                    "references": [
                      "SignerInformation"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "returns the SignerInformation of a signer",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function getSignerInformation(address _signer) external view returns (SignerInformation memory) {\n        return signerIndex[_signer];\n    }",
              "start": {
                "line": 380,
                "column": 4
              },
              "end": {
                "line": 382,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the SignerInformation for the signer",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signer the signer for the information to get",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer for the information to get",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "returns the SignerInformation of a signer",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "getNodeInfromationBySigner",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer for the information to get"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "In3Node",
                    "userDefined": true,
                    "references": [
                      "In3Node"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "returns the In3Node-struct for a signer",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function getNodeInfromationBySigner(address _signer) external view returns (In3Node memory) {\n        return nodes[signerIndex[_signer].index];\n    }",
              "start": {
                "line": 387,
                "column": 4
              },
              "end": {
                "line": 389,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the In3Node-struct for that signer",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signer the signer for the information to get",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer for the information to get",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "returns the In3Node-struct for a signer",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "totalNodes",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "length of the nodelist",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function totalNodes() external view returns (uint) {\n        return nodes.length;\n    }",
              "start": {
                "line": 393,
                "column": 4
              },
              "end": {
                "line": 395,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the number of total in3-nodes",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "length of the nodelist",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminSetSignerInfo",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the address for the information to be set"
                },
                {
                  "name": "_si",
                  "solidityType": {
                    "name": "SignerInformation",
                    "userDefined": true,
                    "references": [
                      "SignerInformation"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the new signerInformation"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bool",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "sets the signerInformation for a signer",
              "modifiers": [
                "onlyLogicContract",
                "public",
                null
              ],
              "source": "function adminSetSignerInfo(address _signer, SignerInformation memory _si) public onlyLogicContract returns (bool) {\n        signerIndex[_signer] = _si;\n        return true;\n    }",
              "start": {
                "line": 404,
                "column": 4
              },
              "end": {
                "line": 407,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "true when successfull",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_si the new signerInformation",
                  "subAnnotation": {
                    "name": "_si",
                    "value": "the new signerInformation",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the address for the information to be set",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the address for the information to be set",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "public-visibility due to passing a struct to the function",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "gets used for updating the information after returning the deposit",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "only callable by the logic contract",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "sets the signerInformation for a signer",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "_calcProofHashInternal",
              "params": [
                {
                  "name": "_node",
                  "solidityType": {
                    "name": "In3Node",
                    "userDefined": true,
                    "references": [
                      "In3Node"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the in3 node to calculate the hash from"
                }
              ],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "calculates the sha3 hash of the most important properties in order to make the proof more efficient",
              "modifiers": [
                "internal",
                "pure"
              ],
              "source": "function _calcProofHashInternal(In3Node memory _node) internal pure returns (bytes32) {\n\n        return keccak256(\n            abi.encodePacked(\n                _node.deposit,\n                _node.registerTime,\n                _node.props,\n                _node.weight,\n                _node.signer,\n                _node.url\n            )\n        );\n    }",
              "start": {
                "line": 412,
                "column": 4
              },
              "end": {
                "line": 424,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the hash of the properties of an in3-node",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_node the in3 node to calculate the hash from",
                  "subAnnotation": {
                    "name": "_node",
                    "value": "the in3 node to calculate the hash from",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "calculates the sha3 hash of the most important properties in order to make the proof more efficient",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "_unregisterNodeInternal",
              "params": [
                {
                  "name": "_si",
                  "solidityType": {
                    "name": "SignerInformation",
                    "userDefined": true,
                    "references": [
                      "SignerInformation"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "information of the signer"
                },
                {
                  "name": "_n",
                  "solidityType": {
                    "name": "In3Node",
                    "userDefined": true,
                    "references": [
                      "In3Node"
                    ],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "information of the in3-node"
                }
              ],
              "returnParams": [],
              "description": "Handles the setting of the unregister values for a node internally",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function _unregisterNodeInternal(SignerInformation  storage _si, In3Node memory _n) internal {\n\n        // solium-disable-next-line security/no-block-members\n        _si.lockedTime = uint64(block.timestamp + timeout);// solhint-disable-line not-rely-on-time\n        _si.depositAmount = _n.deposit;\n\n        _removeNodeInternal(_si.index);\n    }",
              "start": {
                "line": 429,
                "column": 4
              },
              "end": {
                "line": 436,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_n information of the in3-node",
                  "subAnnotation": {
                    "name": "_n",
                    "value": "information of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_si information of the signer",
                  "subAnnotation": {
                    "name": "_si",
                    "value": "information of the signer",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "Handles the setting of the unregister values for a node internally",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "_removeNodeInternal",
              "params": [
                {
                  "name": "_nodeIndex",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the nodeIndex to be removed"
                }
              ],
              "returnParams": [],
              "description": "removes a node from the node-array",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function _removeNodeInternal(uint _nodeIndex) internal {\n\n        require(_nodeIndex < nodes.length, \"invalid node index provided\");\n        // trigger event\n        emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n        uint length = nodes.length;\n\n        assert(length > 0);\n\n        // we set the SignerIndex to an invalid index.\n        signerIndex[nodes[_nodeIndex].signer].index = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n        // move the last entry to the removed one.\n        In3Node memory m = nodes[length - 1];\n        nodes[_nodeIndex] = m;\n\n        SignerInformation storage si = signerIndex[m.signer];\n        si.index = _nodeIndex;\n        nodes.length--;\n    }",
              "start": {
                "line": 440,
                "column": 4
              },
              "end": {
                "line": 461,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_nodeIndex the nodeIndex to be removed",
                  "subAnnotation": {
                    "name": "_nodeIndex",
                    "value": "the nodeIndex to be removed",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "removes a node from the node-array",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "title",
              "value": "Registry for IN3-nodes",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0xac1b824795e1eb1f6e609fe0da9b9af8beaab60f",
          "meta": null,
          "modifiers": [
            {
              "name": "onlyLogicContract",
              "params": []
            }
          ],
          "events": [
            {
              "name": "LogNodeRegistered",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "props",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNodeRemoved",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNodeUpdated",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "props",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogOwnershipChanged",
              "params": [
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "oldOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogDepositReturned",
              "params": [
                {
                  "name": "nodeOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "amount",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryData {\n\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint props, address signer, uint deposit);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a user received its deposit back\n    event LogDepositReturned(address nodeOwner, uint amount);\n\n    struct In3Node {\n        string url;                         /// the url of the node\n\n        uint deposit;                       /// stored deposit\n\n        uint64 registerTime;                /// timestamp when the node was registered\n        uint192 props;                      /// a list of properties-flags representing the capabilities of the node\n\n        uint64 weight;                      ///  the flag for (future) incentivisation\n        address signer;                     /// the signer for requests\n\n        bytes32 proofHash;                  /// keccak(deposit,timeout,registerTime,props,signer,url)\n    }\n\n    /// information of a in3-node owner\n    struct SignerInformation {\n        uint64 lockedTime;                  /// timestamp until the deposit of an in3-node can not be withdrawn after the node was removed\n        address owner;                      /// the owner of the node\n\n        uint stage;                       /// state of the address\n\n        uint depositAmount;                 /// amount of deposit to be locked, used only after a node had been removed\n\n        uint index;                         /// current index-position of the node in the node-array\n    }\n\n    /// information of an url\n    struct UrlInformation {\n        bool used;                          /// flag whether the url is currently used\n        address signer;                     /// address of the owner of the url\n    }\n\n    /// node list of incubed nodes\n    In3Node[] public nodes;\n\n    /// id used for signing in3-requests and in order to prevent cross-chain convicts\n    /// in case a fork happens there is the possibility that a node can be convicted on the other fork,\n    /// because they would use the very same registryId. Nevertheless we cannot change the registryId.\n    /// So in case of a fork a node should chose one of the forks and unregister his nodes on the others.\n    /// In this case it is also recommend to not sign requests until the node get his deposits from the forked contracts\n    bytes32 public registryId;\n\n    /// timeout for all nodes until they can receive their deposit after unregistering\n    uint public timeout;\n\n    /// tokenContract to be used\n    IERC20 public supportedToken;\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n\n    /// Logic-contract that is allowed to call certain functions within the smart contract\n    address public ownerContract;\n\n    /// mapping for information of the owner\n    mapping (address => SignerInformation) public signerIndex;\n\n    /// mapping for the information of the url\n    /// can be used to access the SignerInformation-struct\n    mapping (bytes32 => UrlInformation) public urlIndex;\n\n    /// mapping for convicts: sender => convictHash => block number when the convict-tx had been mined)\n    mapping (address => mapping(bytes32 => uint)) public convictMapping;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyLogicContract {\n        require(ownerContract == msg.sender, \"not the owner\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        // solium-disable-next-line security/no-block-members\n        registryId = keccak256(abi.encodePacked(address(this), blockhash(block.number-1)));\n        timeout = 40 days;\n        ownerContract = msg.sender;\n    }\n\n    /// @notice removes an in3-node from the nodeList\n    /// @param _signer the signer-address of the in3-node\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyLogicContract\n    {\n        SignerInformation memory si = signerIndex[_signer];\n        _removeNodeInternal(si.index);\n\n    }\n\n    /// @notice sets the logic-address / owner of the contract\n    /// @dev used to update the corresponding logic contract\n    /// @dev only callable by the current logic contract\n    /// @param _newLogic the new logic-contract / owner\n    /// @return true if successfull\n    function adminSetLogic(address _newLogic) external onlyLogicContract returns (bool) {\n        require(address(_newLogic) != address(0x0), \"no address provided\");\n        ownerContract = _newLogic;\n        return true;\n    }\n\n    /// @notice sets the deposit of the node\n    /// @dev only callable by the logic contract\n    /// @dev used to delete the deposit after being being convicted\n    /// @param _signer the signer for the node\n    /// @param _newDeposit the new deposit\n    /// @return true if successfull\n    function adminSetNodeDeposit(address _signer, uint _newDeposit) external onlyLogicContract returns (bool) {\n        SignerInformation memory si = signerIndex[_signer];\n        In3Node storage node = nodes[si.index];\n        require(node.signer == _signer, \"not the correct signer of the in3-node\");\n        node.deposit = _newDeposit;\n        return true;\n    }\n\n    /// @notice sets the stage of a certain signer\n    /// @dev only callable by the current logic contract\n    /// @param _signer the signer-account for the stage to be set\n    /// @param _stage the new stage\n    /// @return true if successfull\n    function adminSetStage(address _signer, uint _stage) external onlyLogicContract returns (bool) {\n        SignerInformation storage si = signerIndex[_signer];\n        si.stage = _stage;\n        return true;\n    }\n\n    /// @notice changes the supported token\n    /// @dev only callable by the current logic contract\n    /// @param _newToken the new token-contract\n    /// @return true if successfull\n    function adminSetSupportedToken(IERC20 _newToken) external onlyLogicContract returns (bool) {\n        require(address(_newToken) != address(0x0), \"0x0 is invalid\");\n        supportedToken = _newToken;\n        return true;\n    }\n\n    /// @notice sets a new timeout for all node until they can recive their deposit\n    /// @dev only callable by the current logic contract\n    /// @param _newTimeout the new timeout\n    /// @return true if successfull\n    function adminSetTimeout(uint _newTimeout) external onlyLogicContract returns (bool) {\n        timeout = _newTimeout;\n        return true;\n    }\n\n    /// @notice transfers tokens to an address\n    /// @dev used when returning deposit or rewarding successfull convicts\n    /// @dev only callable by the logic contract\n    /// @param _to the address that shall receive tokens\n    /// @param _amount the amount of tokens to be transfered\n    /// @return true when successfull\n    function adminTransferDeposit(address _to, uint _amount) external onlyLogicContract returns (bool) {\n        require(supportedToken.transfer(_to, _amount), \"ERC20 token transfer failed\");\n        return true;\n    }\n\n    /// @notice writes a value to te convictMapping to be used later for revealConvict in the logic contract\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @param _caller the address for that called convict in the logic-contract\n    function setConvict(bytes32 _hash, address _caller) external onlyLogicContract {\n        convictMapping[_caller][_hash] = block.number;\n    }\n\n    /// @notice registers a new node in the nodeList\n    /// @dev only callable by the logic contract\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the in3-node (in erc20 token)\n    /// @param _stage the stage of the in3-node\n    /// @return true if successfull\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        address _owner,\n        uint _deposit,\n        uint _stage\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // sets the information of the owner\n        SignerInformation storage si = signerIndex[_signer];\n\n        si.index = nodes.length;\n        si.owner = _owner;\n        si.stage = _stage;\n\n        // add new In3Node\n        In3Node memory m;\n        m.url = _url;\n        m.props = _props;\n        m.signer = _signer;\n        m.deposit = _deposit;\n        // solium-disable-next-line security/no-block-members\n        m.registerTime = uint64(block.timestamp); // solhint-disable-line not-rely-on-time\n        m.weight = _weight;\n\n        m.proofHash = _calcProofHashInternal(m);\n        nodes.push(m);\n\n        // sets the information of the url\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = _signer;\n        urlIndex[urlHash] = ui;\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n        return true;\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @return true if successfull\n    function transferOwnership(address _signer, address _newOwner)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation storage si = signerIndex[_signer];\n        emit LogOwnershipChanged(_signer, si.owner, _newOwner);\n\n        si.owner = _newOwner;\n        return true;\n    }\n\n    /// @notice removes a node from the registry\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer of the in3-node\n    /// @return true if successfull\n    function unregisteringNode(address _signer)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n\n        SignerInformation storage si = signerIndex[_signer];\n        In3Node memory n = nodes[si.index];\n        _unregisterNodeInternal(si, n);\n        return true;\n    }\n\n    /// @notice updates a node by adding the msg.value to the deposit and setting the props or timeout\n    /// @dev reverts when trying to change the url to an already existing one\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _deposit the deposit of the in3-node\n    /// @return true if successfull\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation memory si = signerIndex[_signer];\n\n        In3Node storage node = nodes[si.index];\n\n        bytes32 newURL = keccak256(bytes(_url));\n        bytes32 oldURL = keccak256(bytes(node.url));\n\n        // the url got changed\n        if (newURL != oldURL) {\n\n            // make sure the new url is not already in use\n            require(!urlIndex[newURL].used, \"url is already in use\");\n\n            UrlInformation memory ui;\n            ui.used = true;\n            ui.signer = node.signer;\n            urlIndex[newURL] = ui;\n            node.url = _url;\n\n            // deleting the old entry\n            delete urlIndex[oldURL];\n        }\n\n        if (_deposit != node.deposit) {\n            node.deposit = _deposit;\n        }\n\n        if (_props != node.props) {\n            node.props = _props;\n        }\n\n        if (_weight != node.weight) {\n            node.weight = _weight;\n        }\n\n        node.proofHash = _calcProofHashInternal(node);\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            node.deposit\n        );\n\n        return true;\n    }\n\n    /// @notice returns the In3Node-struct of a certain index\n    /// @param _index the position of the NodeInfo in the node-array\n    /// @return the In3Node for the index provided\n    function getIn3NodeInformation(uint _index) external view returns (In3Node memory) {\n        return nodes[_index];\n    }\n\n    /// @notice returns the SignerInformation of a signer\n    /// @param _signer the signer for the information to get\n    /// @return the SignerInformation for the signer\n    function getSignerInformation(address _signer) external view returns (SignerInformation memory) {\n        return signerIndex[_signer];\n    }\n\n    /// @notice returns the In3Node-struct for a signer\n    /// @param _signer the signer for the information to get\n    /// @return the In3Node-struct for that signer\n    function getNodeInfromationBySigner(address _signer) external view returns (In3Node memory) {\n        return nodes[signerIndex[_signer].index];\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodes.length;\n    }\n\n    /// @notice sets the signerInformation for a signer\n    /// @dev only callable by the logic contract\n    /// @dev gets used for updating the information after returning the deposit\n    /// @dev public-visibility due to passing a struct to the function\n    /// @param _signer the address for the information to be set\n    /// @param _si the new signerInformation\n    /// @return true when successfull\n    function adminSetSignerInfo(address _signer, SignerInformation memory _si) public onlyLogicContract returns (bool) {\n        signerIndex[_signer] = _si;\n        return true;\n    }\n\n    /// @notice calculates the sha3 hash of the most important properties in order to make the proof more efficient\n    /// @param _node the in3 node to calculate the hash from\n    /// @return the hash of the properties of an in3-node\n    function _calcProofHashInternal(In3Node memory _node) internal pure returns (bytes32) {\n\n        return keccak256(\n            abi.encodePacked(\n                _node.deposit,\n                _node.registerTime,\n                _node.props,\n                _node.weight,\n                _node.signer,\n                _node.url\n            )\n        );\n    }\n\n    /// @notice Handles the setting of the unregister values for a node internally\n    /// @param _si information of the signer\n    /// @param _n information of the in3-node\n    function _unregisterNodeInternal(SignerInformation  storage _si, In3Node memory _n) internal {\n\n        // solium-disable-next-line security/no-block-members\n        _si.lockedTime = uint64(block.timestamp + timeout);// solhint-disable-line not-rely-on-time\n        _si.depositAmount = _n.deposit;\n\n        _removeNodeInternal(_si.index);\n    }\n\n    /// @notice removes a node from the node-array\n    /// @param _nodeIndex the nodeIndex to be removed\n    function _removeNodeInternal(uint _nodeIndex) internal {\n\n        require(_nodeIndex < nodes.length, \"invalid node index provided\");\n        // trigger event\n        emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n        uint length = nodes.length;\n\n        assert(length > 0);\n\n        // we set the SignerIndex to an invalid index.\n        signerIndex[nodes[_nodeIndex].signer].index = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n        // move the last entry to the removed one.\n        In3Node memory m = nodes[length - 1];\n        nodes[_nodeIndex] = m;\n\n        SignerInformation storage si = signerIndex[m.signer];\n        si.index = _nodeIndex;\n        nodes.length--;\n    }\n}\n",
          "inFile": "NodeRegistryData.sol",
          "references": [
            "In3Node",
            "IERC20",
            "SignerInformation",
            "UrlInformation"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 120
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae",
          "z": 3,
          "attrs": {
            "text": {
              "text": "NodeRegistryData",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "e3cadb4a-6a41-460c-a34f-becf610d1a6f",
            "z": 28,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "829863af-68c5-4416-8fc3-b18334a11bcc"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "bfabef6e-f1e0-4d4a-ba23-d2b88b4e8ab6",
            "z": 29,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          },
          {
            "type": "link",
            "source": {
              "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "f7ba4607-0566-4919-abcd-160adf85b736",
            "z": 30,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "name": "NodeRegistryData.In3Node",
          "shortName": "In3Node",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "url",
              "solidityType": {
                "name": "string",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "deposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "registerTime",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "props",
              "solidityType": {
                "name": "uint192",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "weight",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "proofHash",
              "solidityType": {
                "name": "bytes32",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 60
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91",
          "z": 4,
          "attrs": {
            "text": {
              "text": "In3Node",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "e7613f2a-4cdf-4855-ae98-8f7fff707e91"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "e3cadb4a-6a41-460c-a34f-becf610d1a6f",
            "z": 28,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "name": "NodeRegistryData.SignerInformation",
          "shortName": "SignerInformation",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "lockedTime",
              "solidityType": {
                "name": "uint64",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "owner",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "stage",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "depositAmount",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "index",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 120
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "829863af-68c5-4416-8fc3-b18334a11bcc",
          "z": 5,
          "attrs": {
            "text": {
              "text": "SignerInformation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "829863af-68c5-4416-8fc3-b18334a11bcc"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "bfabef6e-f1e0-4d4a-ba23-d2b88b4e8ab6",
            "z": 29,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "name": "NodeRegistryData.UrlInformation",
          "shortName": "UrlInformation",
          "parentName": "NodeRegistryData",
          "elementType": 1,
          "fields": [
            {
              "name": "used",
              "solidityType": {
                "name": "bool",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            },
            {
              "name": "signer",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": null
            }
          ]
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 180
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d",
          "z": 6,
          "attrs": {
            "text": {
              "text": "UrlInformation",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/stream-solid.svg"
            },
            "rect": {
              "class": "struct-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "ec2d2ec4-27e7-4cc5-a0cb-563b9007548d"
            },
            "target": {
              "id": "cce0c0e4-7be0-4723-aea8-4698a6d2a4ae"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "f7ba4607-0566-4919-abcd-160adf85b736",
            "z": 30,
            "attrs": {
              ".marker-target": {
                "stroke": "#8e8e8e",
                "fill": "#8e8e8e",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 2,
                "stroke": "#8e8e8e"
              }
            }
          }
        ]
      },
      {
        "nodeElement": {
          "elementType": 0,
          "name": "NodeRegistryLogic",
          "baseContracts": [],
          "enumerations": [
            {
              "name": "NodeRegistryLogic.Stages",
              "shortName": "Stages",
              "parentName": "NodeRegistryLogic",
              "elementType": 2,
              "entries": [
                {
                  "name": "NotInUse",
                  "index": 0
                },
                {
                  "name": "Active",
                  "index": 1
                },
                {
                  "name": "Convicted",
                  "index": 2
                },
                {
                  "name": "DepositNotWithdrawn",
                  "index": 3
                }
              ]
            }
          ],
          "structs": [],
          "stateVariables": [
            {
              "name": "blockRegistry",
              "solidityType": {
                "name": "BlockhashRegistry",
                "userDefined": true,
                "references": [
                  "BlockhashRegistry"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "blockRegistry",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "BlockhashRegistry",
                      "userDefined": true,
                      "references": [
                        "BlockhashRegistry"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "nodeRegistryData",
              "solidityType": {
                "name": "NodeRegistryData",
                "userDefined": true,
                "references": [
                  "NodeRegistryData"
                ],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "nodeRegistryData",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "NodeRegistryData",
                      "userDefined": true,
                      "references": [
                        "NodeRegistryData"
                      ],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "timestampAdminKeyActive",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "timestampAdminKeyActive",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "adminKey",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "adminKey",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "updateTimeout",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "updateTimeout",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "pendingNewLogic",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "pendingNewLogic",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "address",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "YEAR_DEFINITION",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "internal",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [],
                "name": "YEAR_DEFINITION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "maxDepositFirstYear",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "maxDepositFirstYear",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "minDeposit",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "minDeposit",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            },
            {
              "name": "VERSION",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "visibility": "public",
              "getter": {
                "annotations": null,
                "description": null,
                "end": null,
                "modifiers": [
                  "view",
                  "public"
                ],
                "name": "VERSION",
                "params": [],
                "returnParams": [
                  {
                    "name": "",
                    "solidityType": {
                      "name": "uint",
                      "userDefined": false,
                      "references": [],
                      "isArray": false
                    },
                    "isStorage": false,
                    "isIndexed": false,
                    "description": null
                  }
                ],
                "source": null,
                "start": null
              }
            }
          ],
          "functions": [
            {
              "name": "constructor",
              "params": [
                {
                  "name": "_blockRegistry",
                  "solidityType": {
                    "name": "BlockhashRegistry",
                    "userDefined": true,
                    "references": [
                      "BlockhashRegistry"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "address of a BlockhashRegistry-contract"
                },
                {
                  "name": "_nodeRegistryData",
                  "solidityType": {
                    "name": "NodeRegistryData",
                    "userDefined": true,
                    "references": [
                      "NodeRegistryData"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "address of the nodeRegistryData-contract"
                },
                {
                  "name": "_minDeposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "returnParams": [],
              "description": "constructor",
              "modifiers": [
                "public",
                null
              ],
              "source": "constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }",
              "start": {
                "line": 100,
                "column": 4
              },
              "end": {
                "line": 113,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "cannot be deployed in a genesis block",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_nodeRegistryData address of the nodeRegistryData-contract",
                  "subAnnotation": {
                    "name": "_nodeRegistryData",
                    "value": "address of the nodeRegistryData-contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_blockRegistry address of a BlockhashRegistry-contract",
                  "subAnnotation": {
                    "name": "_blockRegistry",
                    "value": "address of a BlockhashRegistry-contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "constructor",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "activateNewLogic",
              "params": [],
              "returnParams": [],
              "description": "applies the pending update",
              "modifiers": [
                "external",
                null
              ],
              "source": "function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }",
              "start": {
                "line": 118,
                "column": 4
              },
              "end": {
                "line": 124,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "only callable after 47 since the new logicContract has been registered",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "this will remove the current contract as owner of the NodeRegistryData",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "applies the pending update",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminRemoveNodeFromRegistry",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node"
                }
              ],
              "returnParams": [],
              "description": "removes an in3-server from the registry",
              "modifiers": [
                "onlyAdmin",
                "external",
                null
              ],
              "source": "function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
              "start": {
                "line": 130,
                "column": 4
              },
              "end": {
                "line": 146,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "only callable in the 1st year after deployment",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "only callable by the adminKey-account",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "removes an in3-server from the registry",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "adminUpdateLogic",
              "params": [
                {
                  "name": "_newLogic",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the address of the new logic contract"
                }
              ],
              "returnParams": [],
              "description": "",
              "modifiers": [
                "onlyAdmin",
                "external",
                null
              ],
              "source": "function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }",
              "start": {
                "line": 153,
                "column": 4
              },
              "end": {
                "line": 161,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_newLogic the address of the new logic contract",
                  "subAnnotation": {
                    "name": "_newLogic",
                    "value": "the address of the new logic contract",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the owner of the contract",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "convict",
              "params": [
                {
                  "name": "_hash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning."
                }
              ],
              "returnParams": [],
              "description": "must be called before revealConvict\ncommits a blocknumber and a hash",
              "modifiers": [
                "external",
                null
              ],
              "source": "function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }",
              "start": {
                "line": 167,
                "column": 4
              },
              "end": {
                "line": 169,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "The v,r,s paramaters are from the signature of the wrong blockhash that the node provided",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                  "subAnnotation": {
                    "name": "_hash",
                    "value": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "must be called before revealConvict",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "commits a blocknumber and a hash",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "registerNode",
              "params": [
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url of the node, has to be unique"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "properties of the node"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "how many requests per second the node is able to handle"
                },
                {
                  "name": "_deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the deposit in erc20 tokens"
                }
              ],
              "returnParams": [],
              "description": "register a new node with the sender as owner",
              "modifiers": [
                "external",
                null
              ],
              "source": "function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }",
              "start": {
                "line": 177,
                "column": 4
              },
              "end": {
                "line": 194,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_deposit the deposit in erc20 tokens",
                  "subAnnotation": {
                    "name": "_deposit",
                    "value": "the deposit in erc20 tokens",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_weight how many requests per second the node is able to handle",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "how many requests per second the node is able to handle",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props properties of the node",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "properties of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url of the node, has to be unique",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url of the node, has to be unique",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "the supported tokens have to be approved by the owner first",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "register a new node with the sender as owner",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "registerNodeFor",
              "params": [
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url of the node, has to be unique"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "properties of the node"
                },
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer of the in3-node"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "how many requests per second the node is able to handle"
                },
                {
                  "name": "_depositAmount",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "deposit in erc20 tokens"
                },
                {
                  "name": "_v",
                  "solidityType": {
                    "name": "uint8",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "v of the signed message"
                },
                {
                  "name": "_r",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "r of the signed message"
                },
                {
                  "name": "_s",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "s of the signed message"
                }
              ],
              "returnParams": [],
              "description": "register a new node as a owner using a different signer address",
              "modifiers": [
                "external",
                null
              ],
              "source": "function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }",
              "start": {
                "line": 210,
                "column": 4
              },
              "end": {
                "line": 253,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "will revert when a wrong signature has been provided",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "which is calculated by the hash of the url, properties, weight and the owner",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "in order to prove that the owner has controll over the signer-address he has to sign a message",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "will call the registerNodeInteral function",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_s s of the signed message",
                  "subAnnotation": {
                    "name": "_s",
                    "value": "s of the signed message",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_r r of the signed message",
                  "subAnnotation": {
                    "name": "_r",
                    "value": "r of the signed message",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_v v of the signed message",
                  "subAnnotation": {
                    "name": "_v",
                    "value": "v of the signed message",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_depositAmount deposit in erc20 tokens",
                  "subAnnotation": {
                    "name": "_depositAmount",
                    "value": "deposit in erc20 tokens",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_weight how many requests per second the node is able to handle",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "how many requests per second the node is able to handle",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props properties of the node",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "properties of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url of the node, has to be unique",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url of the node, has to be unique",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "the supported tokens have to be approved by the owner first",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "register a new node as a owner using a different signer address",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "returnDeposit",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the former signer"
                }
              ],
              "returnParams": [],
              "description": "returns the deposit of a former node after the timeout has passed",
              "modifiers": [
                "external",
                null
              ],
              "source": "function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }",
              "start": {
                "line": 258,
                "column": 4
              },
              "end": {
                "line": 282,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_signer the former signer",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the former signer",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "only callable by the owner of the former signer",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "returns the deposit of a former node after the timeout has passed",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "revealConvict",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the address that signed the wrong blockhash"
                },
                {
                  "name": "_blockhash",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the wrongly provided blockhash"
                },
                {
                  "name": "_blockNumber",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "number of the wrongly provided blockhash"
                },
                {
                  "name": "_v",
                  "solidityType": {
                    "name": "uint8",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "v of the signature"
                },
                {
                  "name": "_r",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "r of the signature"
                },
                {
                  "name": "_s",
                  "solidityType": {
                    "name": "bytes32",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "s of the signature"
                }
              ],
              "returnParams": [],
              "description": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
              "modifiers": [
                "external",
                null
              ],
              "source": "function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }",
              "start": {
                "line": 296,
                "column": 4
              },
              "end": {
                "line": 366,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "reverts when the wrong convict hash (see convict-function) is used",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when the _signer did not sign the block",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when trying to reveal immediately after calling convict",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when tryin to convict someone with a correct blockhash",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_s s of the signature",
                  "subAnnotation": {
                    "name": "_s",
                    "value": "s of the signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_r r of the signature",
                  "subAnnotation": {
                    "name": "_r",
                    "value": "r of the signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_v v of the signature",
                  "subAnnotation": {
                    "name": "_v",
                    "value": "v of the signature",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_blockNumber number of the wrongly provided blockhash",
                  "subAnnotation": {
                    "name": "_blockNumber",
                    "value": "number of the wrongly provided blockhash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_blockhash the wrongly provided blockhash",
                  "subAnnotation": {
                    "name": "_blockhash",
                    "value": "the wrongly provided blockhash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the address that signed the wrong blockhash",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the address that signed the wrong blockhash",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "transferOwnership",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node, used as an identifier"
                },
                {
                  "name": "_newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new owner"
                }
              ],
              "returnParams": [],
              "description": "changes the ownership of an in3-node",
              "modifiers": [
                "external",
                null
              ],
              "source": "function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }",
              "start": {
                "line": 374,
                "column": 4
              },
              "end": {
                "line": 388,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "reverts when the sender is not the current owner",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when trying to pass ownership to 0x0",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when trying to change ownership of an inactive node",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_newOwner the new owner",
                  "subAnnotation": {
                    "name": "_newOwner",
                    "value": "the new owner",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node, used as an identifier",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node, used as an identifier",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "changes the ownership of an in3-node",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "unregisteringNode",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer of the in3-node"
                }
              ],
              "returnParams": [],
              "description": "doing so will also lock his deposit for the timeout of the node\na node owner can unregister a node, removing it from the nodeList",
              "modifiers": [
                "external",
                null
              ],
              "source": "function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
              "start": {
                "line": 396,
                "column": 4
              },
              "end": {
                "line": 412,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "reverts when the node is not active",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when not called by the owner of the node",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when the provided address is not an in3-signer",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_signer the signer of the in3-node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer of the in3-node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "doing so will also lock his deposit for the timeout of the node",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "a node owner can unregister a node, removing it from the nodeList",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "updateNode",
              "params": [
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer-address of the in3-node, used as an identifier"
                },
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url, will be changed if different from the current one"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new properties, will be changed if different from the current onec"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the amount of requests per second the node is able to handle"
                },
                {
                  "name": "_additionalDeposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the additional deposit in erc20-token"
                }
              ],
              "returnParams": [],
              "description": "updates a node by changing its props",
              "modifiers": [
                "external",
                null
              ],
              "source": "function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }",
              "start": {
                "line": 424,
                "column": 4
              },
              "end": {
                "line": 464,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "reverts when trying to change the url to an already existing one",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when the signer does not own a node",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "reverts when the sender is not the owner of the node",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_additionalDeposit the additional deposit in erc20-token",
                  "subAnnotation": {
                    "name": "_additionalDeposit",
                    "value": "the additional deposit in erc20-token",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_weight the amount of requests per second the node is able to handle",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "the amount of requests per second the node is able to handle",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props the new properties, will be changed if different from the current onec",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "the new properties, will be changed if different from the current onec",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url, will be changed if different from the current one",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url, will be changed if different from the current one",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer-address of the in3-node, used as an identifier",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer-address of the in3-node, used as an identifier",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "dev",
                  "value": "if there is an additional deposit the owner has to approve the tokenTransfer before",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "updates a node by changing its props",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "supportedToken",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "IERC20",
                    "userDefined": true,
                    "references": [
                      "IERC20"
                    ],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "returns the supported ERC20 token for registering a node",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }",
              "start": {
                "line": 468,
                "column": 4
              },
              "end": {
                "line": 470,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the supported ERC20 token",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "returns the supported ERC20 token for registering a node",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "totalNodes",
              "params": [],
              "returnParams": [
                {
                  "name": null,
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": ""
                }
              ],
              "description": "length of the nodelist",
              "modifiers": [
                "external",
                "view"
              ],
              "source": "function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }",
              "start": {
                "line": 474,
                "column": 4
              },
              "end": {
                "line": 476,
                "column": 4
              },
              "annotations": [
                {
                  "name": "return",
                  "value": "the number of total in3-nodes",
                  "subAnnotation": null
                },
                {
                  "name": "notice",
                  "value": "length of the nodelist",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "_checkNodePropertiesInternal",
              "params": [
                {
                  "name": "_deposit",
                  "solidityType": {
                    "name": "uint256",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the new amount of deposit a server has"
                }
              ],
              "returnParams": [],
              "description": "function to check whether the allowed amount of deposit per server has been reached",
              "modifiers": [
                "internal",
                "view"
              ],
              "source": "function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }",
              "start": {
                "line": 482,
                "column": 4
              },
              "end": {
                "line": 490,
                "column": 4
              },
              "annotations": [
                {
                  "name": "dev",
                  "value": "will fail when the deposit is less than the minDeposit",
                  "subAnnotation": null
                },
                {
                  "name": "dev",
                  "value": "will fail when the deposit is greater than the maxDepositFirstYear in the 1st year",
                  "subAnnotation": null
                },
                {
                  "name": "param",
                  "value": "_deposit the new amount of deposit a server has",
                  "subAnnotation": {
                    "name": "_deposit",
                    "value": "the new amount of deposit a server has",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "function to check whether the allowed amount of deposit per server has been reached",
                  "subAnnotation": null
                }
              ]
            },
            {
              "name": "_registerNodeInternal",
              "params": [
                {
                  "name": "_url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": true,
                  "isIndexed": false,
                  "description": "the url of the node"
                },
                {
                  "name": "_props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the properties of the node"
                },
                {
                  "name": "_signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the signer of the node"
                },
                {
                  "name": "_owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the owner of the node"
                },
                {
                  "name": "_deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the deposit of the node"
                },
                {
                  "name": "_weight",
                  "solidityType": {
                    "name": "uint64",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isStorage": false,
                  "isIndexed": false,
                  "description": "the weight of the node (# of requests per second he is able to handle)"
                }
              ],
              "returnParams": [],
              "description": "helper function for registering a node",
              "modifiers": [
                "internal",
                null
              ],
              "source": "function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }",
              "start": {
                "line": 499,
                "column": 4
              },
              "end": {
                "line": 541,
                "column": 4
              },
              "annotations": [
                {
                  "name": "param",
                  "value": "_weight the weight of the node (# of requests per second he is able to handle)",
                  "subAnnotation": {
                    "name": "_weight",
                    "value": "the weight of the node (# of requests per second he is able to handle)",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_deposit the deposit of the node",
                  "subAnnotation": {
                    "name": "_deposit",
                    "value": "the deposit of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_owner the owner of the node",
                  "subAnnotation": {
                    "name": "_owner",
                    "value": "the owner of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_signer the signer of the node",
                  "subAnnotation": {
                    "name": "_signer",
                    "value": "the signer of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_props the properties of the node",
                  "subAnnotation": {
                    "name": "_props",
                    "value": "the properties of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "param",
                  "value": "_url the url of the node",
                  "subAnnotation": {
                    "name": "_url",
                    "value": "the url of the node",
                    "subAnnotation": null
                  }
                },
                {
                  "name": "notice",
                  "value": "helper function for registering a node",
                  "subAnnotation": null
                }
              ]
            }
          ],
          "annotations": [
            {
              "name": "title",
              "value": "Registry for IN3-nodes",
              "subAnnotation": null
            }
          ],
          "deployedAt": "0x6C095A05764A23156eFD9D603eaDa144a9B1AF33",
          "meta": null,
          "modifiers": [
            {
              "name": "onlyAdmin",
              "params": []
            }
          ],
          "events": [
            {
              "name": "LogNodeRegistered",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNodeConvicted",
              "params": [
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNodeRemoved",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNodeUpdated",
              "params": [
                {
                  "name": "url",
                  "solidityType": {
                    "name": "string",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "props",
                  "solidityType": {
                    "name": "uint192",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogOwnershipChanged",
              "params": [
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "oldOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "newOwner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogNewPendingContract",
              "params": [
                {
                  "name": "newPendingContract",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            },
            {
              "name": "LogDepositReturned",
              "params": [
                {
                  "name": "signer",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "owner",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "deposit",
                  "solidityType": {
                    "name": "uint",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                },
                {
                  "name": "erc20Token",
                  "solidityType": {
                    "name": "address",
                    "userDefined": false,
                    "references": [],
                    "isArray": false
                  },
                  "isIndexed": false,
                  "visibility": null
                }
              ]
            }
          ],
          "kind": "contract",
          "heritageDissolved": true,
          "inheritedStateVariables": [],
          "inheritedFunctions": [],
          "inheritedEvents": [],
          "inheritedModifiers": [],
          "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BlockhashRegistry.sol\";\nimport \"./NodeRegistryData.sol\";\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryLogic {\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint192 props, address signer, uint deposit);\n\n    /// a node was convicted\n    event LogNodeConvicted(address signer);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint192 props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a new logic contract got proposed\n    event LogNewPendingContract(address newPendingContract);\n\n    /// deposit has been returned\n    event LogDepositReturned(address signer, address owner, uint deposit, address erc20Token);\n\n    /// Different Stages a node can have\n    enum Stages {\n        NotInUse,                           /// node is not in use, so a new node with the same address can be registered\n        Active,                             /// node is active, so a new node with the same address cannot be registered\n        Convicted,                          /// node is convited, so he is inactive, but cannot be registered anymore\n        DepositNotWithdrawn                 /// node is not in use anymore, but still has some deposit stored within the contract\n    }\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n    /// blockhash registry address\n    BlockhashRegistry public blockRegistry;\n\n    /// address for the data of the nodeRegistry\n    NodeRegistryData public nodeRegistryData;\n\n    /// timestamp until the unregisterKey is active\n    uint public timestampAdminKeyActive;\n\n    /// admin-key to remove some server, only usable within the 1st year\n    address public adminKey;\n\n    /// timestamp when an update of the logic-contract can be applied\n    uint public updateTimeout;\n\n    /// address of an updated logic contract to be applied\n    address public pendingNewLogic;\n\n    /// capping the max deposit timeout on 1 year\n    uint constant internal YEAR_DEFINITION = 1 days * 365;\n\n    /// limit for ether per node in the 1st year\n    uint public maxDepositFirstYear;\n\n    /// min deposit required for registering a node\n    uint public minDeposit;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyAdmin {\n        require(msg.sender == adminKey, \"not the admin\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @param _blockRegistry address of a BlockhashRegistry-contract\n    /// @param _nodeRegistryData address of the nodeRegistryData-contract\n    /// @dev cannot be deployed in a genesis block\n    constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }\n\n    /// @notice applies the pending update\n    /// @dev this will remove the current contract as owner of the NodeRegistryData\n    /// @dev only callable after 47 since the new logicContract has been registered\n    function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }\n\n    /// @notice removes an in3-server from the registry\n    /// @param _signer the signer-address of the in3-node\n    /// @dev only callable by the adminKey-account\n    /// @dev only callable in the 1st year after deployment\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice sets the address for a new (pending) logic\n    ///         the update can only be applied after 47 days,\n    ///         giving all the nodes enough time to unregister their node if they dislike the update\n    /// @dev only callable by the owner of the contract\n    /// @param _newLogic the address of the new logic contract\n    function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }\n\n    /// @notice commits a blocknumber and a hash\n    /// @notice must be called before revealConvict\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @dev The v,r,s paramaters are from the signature of the wrong blockhash that the node provided\n    function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }\n\n    /// @notice register a new node with the sender as owner\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _deposit the deposit in erc20 tokens\n    function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }\n\n    /// @notice register a new node as a owner using a different signer address\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _depositAmount deposit in erc20 tokens\n    /// @param _v v of the signed message\n    /// @param _r r of the signed message\n    /// @param _s s of the signed message\n    /// @dev will call the registerNodeInteral function\n    /// @dev in order to prove that the owner has controll over the signer-address he has to sign a message\n    /// @dev which is calculated by the hash of the url, properties, weight and the owner\n    /// @dev will revert when a wrong signature has been provided\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }\n\n    /// @notice returns the deposit of a former node after the timeout has passed\n    /// @dev only callable by the owner of the former signer\n    /// @param _signer the former signer\n    function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }\n\n    /// @notice reveals the wrongly provided blockhash, so that the node-owner will lose its deposit\n    /// @param _signer the address that signed the wrong blockhash\n    /// @param _blockhash the wrongly provided blockhash\n    /// @param _blockNumber number of the wrongly provided blockhash\n    /// @param _v v of the signature\n    /// @param _r r of the signature\n    /// @param _s s of the signature\n    /// @dev reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry\n    /// @dev reverts when tryin to convict someone with a correct blockhash\n    /// @dev reverts when trying to reveal immediately after calling convict\n    /// @dev reverts when the _signer did not sign the block\n    /// @dev reverts when the wrong convict hash (see convict-function) is used\n    function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @dev reverts when trying to change ownership of an inactive node\n    /// @dev reverts when trying to pass ownership to 0x0\n    /// @dev reverts when the sender is not the current owner\n    function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }\n\n    /// @notice a node owner can unregister a node, removing it from the nodeList\n    /// @notice doing so will also lock his deposit for the timeout of the node\n    /// @param _signer the signer of the in3-node\n    /// @dev reverts when the provided address is not an in3-signer\n    /// @dev reverts when not called by the owner of the node\n    /// @dev reverts when the node is not active\n    function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice updates a node by changing its props\n    /// @dev if there is an additional deposit the owner has to approve the tokenTransfer before\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _additionalDeposit the additional deposit in erc20-token\n    /// @dev reverts when the sender is not the owner of the node\n    /// @dev reverts when the signer does not own a node\n    /// @dev reverts when trying to change the url to an already existing one\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }\n\n    /// @notice returns the supported ERC20 token for registering a node\n    /// @return the supported ERC20 token\n    function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }\n\n    /// @notice function to check whether the allowed amount of deposit per server has been reached\n    /// @param _deposit the new amount of deposit a server has\n    /// @dev will fail when the deposit is greater than the maxDepositFirstYear in the 1st year\n    /// @dev will fail when the deposit is less than the minDeposit\n    function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }\n\n    /// @notice helper function for registering a node\n    /// @param _url the url of the node\n    /// @param _props the properties of the node\n    /// @param _signer the signer of the node\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the node\n    /// @param _weight the weight of the node (# of requests per second he is able to handle)\n    function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }\n\n}\n",
          "inFile": "NodeRegistryLogic.sol",
          "references": [
            "BlockhashRegistry",
            "NodeRegistryData",
            "NodeRegistryData.SignerInformation",
            "NodeRegistryData.In3Node",
            "IERC20"
          ],
          "isAbstract": false
        },
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 200,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc",
          "z": 7,
          "attrs": {
            "text": {
              "text": "NodeRegistryLogic",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/file-contract-solid.svg"
            },
            "rect": {
              "class": "contract-node node-highlighted",
              "rx": 1,
              "ry": 2
            }
          }
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "2d2200c5-773c-4796-aed2-ce7604588263"
            },
            "target": {
              "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "0b853a5c-a91d-4657-ac81-4b1b4df05630",
            "z": 31,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          }
        ]
      },
      {
        "jointjsNode": {
          "type": "basic.Rect",
          "position": {
            "x": 0,
            "y": 0
          },
          "size": {
            "width": 150,
            "height": 40
          },
          "angle": 0,
          "id": "2d2200c5-773c-4796-aed2-ce7604588263",
          "z": 8,
          "attrs": {
            "text": {
              "text": "Stages",
              "font-size": 12,
              "class": "node-text"
            },
            "image": {
              "xlink:href": "assets/list-ol.svg"
            },
            "rect": {
              "class": "enum-node",
              "rx": 5,
              "ry": 10
            }
          }
        },
        "nodeElement": {
          "name": "NodeRegistryLogic.Stages",
          "shortName": "Stages",
          "parentName": "NodeRegistryLogic",
          "elementType": 2,
          "entries": [
            {
              "name": "NotInUse",
              "index": 0
            },
            {
              "name": "Active",
              "index": 1
            },
            {
              "name": "Convicted",
              "index": 2
            },
            {
              "name": "DepositNotWithdrawn",
              "index": 3
            }
          ]
        },
        "inheritanceLinks": [],
        "otherLinks": [
          {
            "type": "link",
            "source": {
              "id": "2d2200c5-773c-4796-aed2-ce7604588263"
            },
            "target": {
              "id": "2b406bb9-963e-4b84-95e4-dee4b0d4c9cc"
            },
            "router": {
              "name": "manhattan",
              "args": {}
            },
            "connector": {
              "name": "normal"
            },
            "id": "0b853a5c-a91d-4657-ac81-4b1b4df05630",
            "z": 31,
            "attrs": {
              ".marker-target": {
                "stroke": "#fe8550",
                "fill": "#fe8550",
                "d": "M 10 0 L 0 5 L 10 10 z"
              },
              ".connection": {
                "stroke-width": 4,
                "stroke": "#fe8550"
              }
            }
          }
        ]
      }
    ]
  },
  "selectedElement": {
    "elementType": 0,
    "name": "NodeRegistryLogic",
    "baseContracts": [],
    "enumerations": [
      {
        "name": "NodeRegistryLogic.Stages",
        "shortName": "Stages",
        "parentName": "NodeRegistryLogic",
        "elementType": 2,
        "entries": [
          {
            "name": "NotInUse",
            "index": 0
          },
          {
            "name": "Active",
            "index": 1
          },
          {
            "name": "Convicted",
            "index": 2
          },
          {
            "name": "DepositNotWithdrawn",
            "index": 3
          }
        ]
      }
    ],
    "structs": [],
    "stateVariables": [
      {
        "name": "blockRegistry",
        "solidityType": {
          "name": "BlockhashRegistry",
          "userDefined": true,
          "references": [
            "BlockhashRegistry"
          ],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "blockRegistry",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "BlockhashRegistry",
                "userDefined": true,
                "references": [
                  "BlockhashRegistry"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "nodeRegistryData",
        "solidityType": {
          "name": "NodeRegistryData",
          "userDefined": true,
          "references": [
            "NodeRegistryData"
          ],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "nodeRegistryData",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "NodeRegistryData",
                "userDefined": true,
                "references": [
                  "NodeRegistryData"
                ],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "timestampAdminKeyActive",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "timestampAdminKeyActive",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "adminKey",
        "solidityType": {
          "name": "address",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "adminKey",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "updateTimeout",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "updateTimeout",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "pendingNewLogic",
        "solidityType": {
          "name": "address",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "pendingNewLogic",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "address",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "YEAR_DEFINITION",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "internal",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [],
          "name": "YEAR_DEFINITION",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "maxDepositFirstYear",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "maxDepositFirstYear",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "minDeposit",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "minDeposit",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      },
      {
        "name": "VERSION",
        "solidityType": {
          "name": "uint",
          "userDefined": false,
          "references": [],
          "isArray": false
        },
        "visibility": "public",
        "getter": {
          "annotations": null,
          "description": null,
          "end": null,
          "modifiers": [
            "view",
            "public"
          ],
          "name": "VERSION",
          "params": [],
          "returnParams": [
            {
              "name": "",
              "solidityType": {
                "name": "uint",
                "userDefined": false,
                "references": [],
                "isArray": false
              },
              "isStorage": false,
              "isIndexed": false,
              "description": null
            }
          ],
          "source": null,
          "start": null
        }
      }
    ],
    "functions": [
      {
        "name": "constructor",
        "params": [
          {
            "name": "_blockRegistry",
            "solidityType": {
              "name": "BlockhashRegistry",
              "userDefined": true,
              "references": [
                "BlockhashRegistry"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "address of a BlockhashRegistry-contract"
          },
          {
            "name": "_nodeRegistryData",
            "solidityType": {
              "name": "NodeRegistryData",
              "userDefined": true,
              "references": [
                "NodeRegistryData"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "address of the nodeRegistryData-contract"
          },
          {
            "name": "_minDeposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "returnParams": [],
        "description": "constructor",
        "modifiers": [
          "public",
          null
        ],
        "source": "constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }",
        "start": {
          "line": 100,
          "column": 4
        },
        "end": {
          "line": 113,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "cannot be deployed in a genesis block",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_nodeRegistryData address of the nodeRegistryData-contract",
            "subAnnotation": {
              "name": "_nodeRegistryData",
              "value": "address of the nodeRegistryData-contract",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_blockRegistry address of a BlockhashRegistry-contract",
            "subAnnotation": {
              "name": "_blockRegistry",
              "value": "address of a BlockhashRegistry-contract",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "constructor",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "activateNewLogic",
        "params": [],
        "returnParams": [],
        "description": "applies the pending update",
        "modifiers": [
          "external",
          null
        ],
        "source": "function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }",
        "start": {
          "line": 118,
          "column": 4
        },
        "end": {
          "line": 124,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "only callable after 47 since the new logicContract has been registered",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "this will remove the current contract as owner of the NodeRegistryData",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "applies the pending update",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "adminRemoveNodeFromRegistry",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer-address of the in3-node"
          }
        ],
        "returnParams": [],
        "description": "removes an in3-server from the registry",
        "modifiers": [
          "onlyAdmin",
          "external",
          null
        ],
        "source": "function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
        "start": {
          "line": 130,
          "column": 4
        },
        "end": {
          "line": 146,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "only callable in the 1st year after deployment",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "only callable by the adminKey-account",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_signer the signer-address of the in3-node",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer-address of the in3-node",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "removes an in3-server from the registry",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "adminUpdateLogic",
        "params": [
          {
            "name": "_newLogic",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the address of the new logic contract"
          }
        ],
        "returnParams": [],
        "description": "",
        "modifiers": [
          "onlyAdmin",
          "external",
          null
        ],
        "source": "function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }",
        "start": {
          "line": 153,
          "column": 4
        },
        "end": {
          "line": 161,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_newLogic the address of the new logic contract",
            "subAnnotation": {
              "name": "_newLogic",
              "value": "the address of the new logic contract",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "only callable by the owner of the contract",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "convict",
        "params": [
          {
            "name": "_hash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning."
          }
        ],
        "returnParams": [],
        "description": "must be called before revealConvict\ncommits a blocknumber and a hash",
        "modifiers": [
          "external",
          null
        ],
        "source": "function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }",
        "start": {
          "line": 167,
          "column": 4
        },
        "end": {
          "line": 169,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "The v,r,s paramaters are from the signature of the wrong blockhash that the node provided",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
            "subAnnotation": {
              "name": "_hash",
              "value": "keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "must be called before revealConvict",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "commits a blocknumber and a hash",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "registerNode",
        "params": [
          {
            "name": "_url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "the url of the node, has to be unique"
          },
          {
            "name": "_props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "properties of the node"
          },
          {
            "name": "_weight",
            "solidityType": {
              "name": "uint64",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "how many requests per second the node is able to handle"
          },
          {
            "name": "_deposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the deposit in erc20 tokens"
          }
        ],
        "returnParams": [],
        "description": "register a new node with the sender as owner",
        "modifiers": [
          "external",
          null
        ],
        "source": "function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }",
        "start": {
          "line": 177,
          "column": 4
        },
        "end": {
          "line": 194,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_deposit the deposit in erc20 tokens",
            "subAnnotation": {
              "name": "_deposit",
              "value": "the deposit in erc20 tokens",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_weight how many requests per second the node is able to handle",
            "subAnnotation": {
              "name": "_weight",
              "value": "how many requests per second the node is able to handle",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_props properties of the node",
            "subAnnotation": {
              "name": "_props",
              "value": "properties of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_url the url of the node, has to be unique",
            "subAnnotation": {
              "name": "_url",
              "value": "the url of the node, has to be unique",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "the supported tokens have to be approved by the owner first",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "register a new node with the sender as owner",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "registerNodeFor",
        "params": [
          {
            "name": "_url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "the url of the node, has to be unique"
          },
          {
            "name": "_props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "properties of the node"
          },
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer of the in3-node"
          },
          {
            "name": "_weight",
            "solidityType": {
              "name": "uint64",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "how many requests per second the node is able to handle"
          },
          {
            "name": "_depositAmount",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "deposit in erc20 tokens"
          },
          {
            "name": "_v",
            "solidityType": {
              "name": "uint8",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "v of the signed message"
          },
          {
            "name": "_r",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "r of the signed message"
          },
          {
            "name": "_s",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "s of the signed message"
          }
        ],
        "returnParams": [],
        "description": "register a new node as a owner using a different signer address",
        "modifiers": [
          "external",
          null
        ],
        "source": "function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }",
        "start": {
          "line": 210,
          "column": 4
        },
        "end": {
          "line": 253,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "will revert when a wrong signature has been provided",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "which is calculated by the hash of the url, properties, weight and the owner",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "in order to prove that the owner has controll over the signer-address he has to sign a message",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "will call the registerNodeInteral function",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_s s of the signed message",
            "subAnnotation": {
              "name": "_s",
              "value": "s of the signed message",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_r r of the signed message",
            "subAnnotation": {
              "name": "_r",
              "value": "r of the signed message",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_v v of the signed message",
            "subAnnotation": {
              "name": "_v",
              "value": "v of the signed message",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_depositAmount deposit in erc20 tokens",
            "subAnnotation": {
              "name": "_depositAmount",
              "value": "deposit in erc20 tokens",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_weight how many requests per second the node is able to handle",
            "subAnnotation": {
              "name": "_weight",
              "value": "how many requests per second the node is able to handle",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_signer the signer of the in3-node",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer of the in3-node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_props properties of the node",
            "subAnnotation": {
              "name": "_props",
              "value": "properties of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_url the url of the node, has to be unique",
            "subAnnotation": {
              "name": "_url",
              "value": "the url of the node, has to be unique",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "the supported tokens have to be approved by the owner first",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "register a new node as a owner using a different signer address",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "returnDeposit",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the former signer"
          }
        ],
        "returnParams": [],
        "description": "returns the deposit of a former node after the timeout has passed",
        "modifiers": [
          "external",
          null
        ],
        "source": "function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }",
        "start": {
          "line": 258,
          "column": 4
        },
        "end": {
          "line": 282,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_signer the former signer",
            "subAnnotation": {
              "name": "_signer",
              "value": "the former signer",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "only callable by the owner of the former signer",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "returns the deposit of a former node after the timeout has passed",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "revealConvict",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the address that signed the wrong blockhash"
          },
          {
            "name": "_blockhash",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the wrongly provided blockhash"
          },
          {
            "name": "_blockNumber",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "number of the wrongly provided blockhash"
          },
          {
            "name": "_v",
            "solidityType": {
              "name": "uint8",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "v of the signature"
          },
          {
            "name": "_r",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "r of the signature"
          },
          {
            "name": "_s",
            "solidityType": {
              "name": "bytes32",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "s of the signature"
          }
        ],
        "returnParams": [],
        "description": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
        "modifiers": [
          "external",
          null
        ],
        "source": "function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }",
        "start": {
          "line": 296,
          "column": 4
        },
        "end": {
          "line": 366,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "reverts when the wrong convict hash (see convict-function) is used",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when the _signer did not sign the block",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when trying to reveal immediately after calling convict",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when tryin to convict someone with a correct blockhash",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_s s of the signature",
            "subAnnotation": {
              "name": "_s",
              "value": "s of the signature",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_r r of the signature",
            "subAnnotation": {
              "name": "_r",
              "value": "r of the signature",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_v v of the signature",
            "subAnnotation": {
              "name": "_v",
              "value": "v of the signature",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_blockNumber number of the wrongly provided blockhash",
            "subAnnotation": {
              "name": "_blockNumber",
              "value": "number of the wrongly provided blockhash",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_blockhash the wrongly provided blockhash",
            "subAnnotation": {
              "name": "_blockhash",
              "value": "the wrongly provided blockhash",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_signer the address that signed the wrong blockhash",
            "subAnnotation": {
              "name": "_signer",
              "value": "the address that signed the wrong blockhash",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "reveals the wrongly provided blockhash, so that the node-owner will lose its deposit",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "transferOwnership",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer-address of the in3-node, used as an identifier"
          },
          {
            "name": "_newOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the new owner"
          }
        ],
        "returnParams": [],
        "description": "changes the ownership of an in3-node",
        "modifiers": [
          "external",
          null
        ],
        "source": "function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }",
        "start": {
          "line": 374,
          "column": 4
        },
        "end": {
          "line": 388,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "reverts when the sender is not the current owner",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when trying to pass ownership to 0x0",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when trying to change ownership of an inactive node",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_newOwner the new owner",
            "subAnnotation": {
              "name": "_newOwner",
              "value": "the new owner",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_signer the signer-address of the in3-node, used as an identifier",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer-address of the in3-node, used as an identifier",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "changes the ownership of an in3-node",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "unregisteringNode",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer of the in3-node"
          }
        ],
        "returnParams": [],
        "description": "doing so will also lock his deposit for the timeout of the node\na node owner can unregister a node, removing it from the nodeList",
        "modifiers": [
          "external",
          null
        ],
        "source": "function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }",
        "start": {
          "line": 396,
          "column": 4
        },
        "end": {
          "line": 412,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "reverts when the node is not active",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when not called by the owner of the node",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when the provided address is not an in3-signer",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_signer the signer of the in3-node",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer of the in3-node",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "doing so will also lock his deposit for the timeout of the node",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "a node owner can unregister a node, removing it from the nodeList",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "updateNode",
        "params": [
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer-address of the in3-node, used as an identifier"
          },
          {
            "name": "_url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "the url, will be changed if different from the current one"
          },
          {
            "name": "_props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the new properties, will be changed if different from the current onec"
          },
          {
            "name": "_weight",
            "solidityType": {
              "name": "uint64",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the amount of requests per second the node is able to handle"
          },
          {
            "name": "_additionalDeposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the additional deposit in erc20-token"
          }
        ],
        "returnParams": [],
        "description": "updates a node by changing its props",
        "modifiers": [
          "external",
          null
        ],
        "source": "function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }",
        "start": {
          "line": 424,
          "column": 4
        },
        "end": {
          "line": 464,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "reverts when trying to change the url to an already existing one",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when the signer does not own a node",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "reverts when the sender is not the owner of the node",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_additionalDeposit the additional deposit in erc20-token",
            "subAnnotation": {
              "name": "_additionalDeposit",
              "value": "the additional deposit in erc20-token",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_weight the amount of requests per second the node is able to handle",
            "subAnnotation": {
              "name": "_weight",
              "value": "the amount of requests per second the node is able to handle",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_props the new properties, will be changed if different from the current onec",
            "subAnnotation": {
              "name": "_props",
              "value": "the new properties, will be changed if different from the current onec",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_url the url, will be changed if different from the current one",
            "subAnnotation": {
              "name": "_url",
              "value": "the url, will be changed if different from the current one",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_signer the signer-address of the in3-node, used as an identifier",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer-address of the in3-node, used as an identifier",
              "subAnnotation": null
            }
          },
          {
            "name": "dev",
            "value": "if there is an additional deposit the owner has to approve the tokenTransfer before",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "updates a node by changing its props",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "supportedToken",
        "params": [],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "IERC20",
              "userDefined": true,
              "references": [
                "IERC20"
              ],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "returns the supported ERC20 token for registering a node",
        "modifiers": [
          "external",
          "view"
        ],
        "source": "function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }",
        "start": {
          "line": 468,
          "column": 4
        },
        "end": {
          "line": 470,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "the supported ERC20 token",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "returns the supported ERC20 token for registering a node",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "totalNodes",
        "params": [],
        "returnParams": [
          {
            "name": null,
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": ""
          }
        ],
        "description": "length of the nodelist",
        "modifiers": [
          "external",
          "view"
        ],
        "source": "function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }",
        "start": {
          "line": 474,
          "column": 4
        },
        "end": {
          "line": 476,
          "column": 4
        },
        "annotations": [
          {
            "name": "return",
            "value": "the number of total in3-nodes",
            "subAnnotation": null
          },
          {
            "name": "notice",
            "value": "length of the nodelist",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "_checkNodePropertiesInternal",
        "params": [
          {
            "name": "_deposit",
            "solidityType": {
              "name": "uint256",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the new amount of deposit a server has"
          }
        ],
        "returnParams": [],
        "description": "function to check whether the allowed amount of deposit per server has been reached",
        "modifiers": [
          "internal",
          "view"
        ],
        "source": "function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }",
        "start": {
          "line": 482,
          "column": 4
        },
        "end": {
          "line": 490,
          "column": 4
        },
        "annotations": [
          {
            "name": "dev",
            "value": "will fail when the deposit is less than the minDeposit",
            "subAnnotation": null
          },
          {
            "name": "dev",
            "value": "will fail when the deposit is greater than the maxDepositFirstYear in the 1st year",
            "subAnnotation": null
          },
          {
            "name": "param",
            "value": "_deposit the new amount of deposit a server has",
            "subAnnotation": {
              "name": "_deposit",
              "value": "the new amount of deposit a server has",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "function to check whether the allowed amount of deposit per server has been reached",
            "subAnnotation": null
          }
        ]
      },
      {
        "name": "_registerNodeInternal",
        "params": [
          {
            "name": "_url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": true,
            "isIndexed": false,
            "description": "the url of the node"
          },
          {
            "name": "_props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the properties of the node"
          },
          {
            "name": "_signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the signer of the node"
          },
          {
            "name": "_owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the owner of the node"
          },
          {
            "name": "_deposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the deposit of the node"
          },
          {
            "name": "_weight",
            "solidityType": {
              "name": "uint64",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isStorage": false,
            "isIndexed": false,
            "description": "the weight of the node (# of requests per second he is able to handle)"
          }
        ],
        "returnParams": [],
        "description": "helper function for registering a node",
        "modifiers": [
          "internal",
          null
        ],
        "source": "function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }",
        "start": {
          "line": 499,
          "column": 4
        },
        "end": {
          "line": 541,
          "column": 4
        },
        "annotations": [
          {
            "name": "param",
            "value": "_weight the weight of the node (# of requests per second he is able to handle)",
            "subAnnotation": {
              "name": "_weight",
              "value": "the weight of the node (# of requests per second he is able to handle)",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_deposit the deposit of the node",
            "subAnnotation": {
              "name": "_deposit",
              "value": "the deposit of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_owner the owner of the node",
            "subAnnotation": {
              "name": "_owner",
              "value": "the owner of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_signer the signer of the node",
            "subAnnotation": {
              "name": "_signer",
              "value": "the signer of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_props the properties of the node",
            "subAnnotation": {
              "name": "_props",
              "value": "the properties of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "param",
            "value": "_url the url of the node",
            "subAnnotation": {
              "name": "_url",
              "value": "the url of the node",
              "subAnnotation": null
            }
          },
          {
            "name": "notice",
            "value": "helper function for registering a node",
            "subAnnotation": null
          }
        ]
      }
    ],
    "annotations": [
      {
        "name": "title",
        "value": "Registry for IN3-nodes",
        "subAnnotation": null
      }
    ],
    "deployedAt": "0x6C095A05764A23156eFD9D603eaDa144a9B1AF33",
    "meta": null,
    "modifiers": [
      {
        "name": "onlyAdmin",
        "params": []
      }
    ],
    "events": [
      {
        "name": "LogNodeRegistered",
        "params": [
          {
            "name": "url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "deposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogNodeConvicted",
        "params": [
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogNodeRemoved",
        "params": [
          {
            "name": "url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogNodeUpdated",
        "params": [
          {
            "name": "url",
            "solidityType": {
              "name": "string",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "props",
            "solidityType": {
              "name": "uint192",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "deposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogOwnershipChanged",
        "params": [
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "oldOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "newOwner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogNewPendingContract",
        "params": [
          {
            "name": "newPendingContract",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      },
      {
        "name": "LogDepositReturned",
        "params": [
          {
            "name": "signer",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "owner",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "deposit",
            "solidityType": {
              "name": "uint",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          },
          {
            "name": "erc20Token",
            "solidityType": {
              "name": "address",
              "userDefined": false,
              "references": [],
              "isArray": false
            },
            "isIndexed": false,
            "visibility": null
          }
        ]
      }
    ],
    "kind": "contract",
    "heritageDissolved": true,
    "inheritedStateVariables": [],
    "inheritedFunctions": [],
    "inheritedEvents": [],
    "inheritedModifiers": [],
    "source": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BlockhashRegistry.sol\";\nimport \"./NodeRegistryData.sol\";\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryLogic {\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint192 props, address signer, uint deposit);\n\n    /// a node was convicted\n    event LogNodeConvicted(address signer);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint192 props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a new logic contract got proposed\n    event LogNewPendingContract(address newPendingContract);\n\n    /// deposit has been returned\n    event LogDepositReturned(address signer, address owner, uint deposit, address erc20Token);\n\n    /// Different Stages a node can have\n    enum Stages {\n        NotInUse,                           /// node is not in use, so a new node with the same address can be registered\n        Active,                             /// node is active, so a new node with the same address cannot be registered\n        Convicted,                          /// node is convited, so he is inactive, but cannot be registered anymore\n        DepositNotWithdrawn                 /// node is not in use anymore, but still has some deposit stored within the contract\n    }\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n    /// blockhash registry address\n    BlockhashRegistry public blockRegistry;\n\n    /// address for the data of the nodeRegistry\n    NodeRegistryData public nodeRegistryData;\n\n    /// timestamp until the unregisterKey is active\n    uint public timestampAdminKeyActive;\n\n    /// admin-key to remove some server, only usable within the 1st year\n    address public adminKey;\n\n    /// timestamp when an update of the logic-contract can be applied\n    uint public updateTimeout;\n\n    /// address of an updated logic contract to be applied\n    address public pendingNewLogic;\n\n    /// capping the max deposit timeout on 1 year\n    uint constant internal YEAR_DEFINITION = 1 days * 365;\n\n    /// limit for ether per node in the 1st year\n    uint public maxDepositFirstYear;\n\n    /// min deposit required for registering a node\n    uint public minDeposit;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyAdmin {\n        require(msg.sender == adminKey, \"not the admin\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @param _blockRegistry address of a BlockhashRegistry-contract\n    /// @param _nodeRegistryData address of the nodeRegistryData-contract\n    /// @dev cannot be deployed in a genesis block\n    constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }\n\n    /// @notice applies the pending update\n    /// @dev this will remove the current contract as owner of the NodeRegistryData\n    /// @dev only callable after 47 since the new logicContract has been registered\n    function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }\n\n    /// @notice removes an in3-server from the registry\n    /// @param _signer the signer-address of the in3-node\n    /// @dev only callable by the adminKey-account\n    /// @dev only callable in the 1st year after deployment\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice sets the address for a new (pending) logic\n    ///         the update can only be applied after 47 days,\n    ///         giving all the nodes enough time to unregister their node if they dislike the update\n    /// @dev only callable by the owner of the contract\n    /// @param _newLogic the address of the new logic contract\n    function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }\n\n    /// @notice commits a blocknumber and a hash\n    /// @notice must be called before revealConvict\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @dev The v,r,s paramaters are from the signature of the wrong blockhash that the node provided\n    function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }\n\n    /// @notice register a new node with the sender as owner\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _deposit the deposit in erc20 tokens\n    function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }\n\n    /// @notice register a new node as a owner using a different signer address\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _depositAmount deposit in erc20 tokens\n    /// @param _v v of the signed message\n    /// @param _r r of the signed message\n    /// @param _s s of the signed message\n    /// @dev will call the registerNodeInteral function\n    /// @dev in order to prove that the owner has controll over the signer-address he has to sign a message\n    /// @dev which is calculated by the hash of the url, properties, weight and the owner\n    /// @dev will revert when a wrong signature has been provided\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }\n\n    /// @notice returns the deposit of a former node after the timeout has passed\n    /// @dev only callable by the owner of the former signer\n    /// @param _signer the former signer\n    function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }\n\n    /// @notice reveals the wrongly provided blockhash, so that the node-owner will lose its deposit\n    /// @param _signer the address that signed the wrong blockhash\n    /// @param _blockhash the wrongly provided blockhash\n    /// @param _blockNumber number of the wrongly provided blockhash\n    /// @param _v v of the signature\n    /// @param _r r of the signature\n    /// @param _s s of the signature\n    /// @dev reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry\n    /// @dev reverts when tryin to convict someone with a correct blockhash\n    /// @dev reverts when trying to reveal immediately after calling convict\n    /// @dev reverts when the _signer did not sign the block\n    /// @dev reverts when the wrong convict hash (see convict-function) is used\n    function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @dev reverts when trying to change ownership of an inactive node\n    /// @dev reverts when trying to pass ownership to 0x0\n    /// @dev reverts when the sender is not the current owner\n    function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }\n\n    /// @notice a node owner can unregister a node, removing it from the nodeList\n    /// @notice doing so will also lock his deposit for the timeout of the node\n    /// @param _signer the signer of the in3-node\n    /// @dev reverts when the provided address is not an in3-signer\n    /// @dev reverts when not called by the owner of the node\n    /// @dev reverts when the node is not active\n    function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice updates a node by changing its props\n    /// @dev if there is an additional deposit the owner has to approve the tokenTransfer before\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _additionalDeposit the additional deposit in erc20-token\n    /// @dev reverts when the sender is not the owner of the node\n    /// @dev reverts when the signer does not own a node\n    /// @dev reverts when trying to change the url to an already existing one\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }\n\n    /// @notice returns the supported ERC20 token for registering a node\n    /// @return the supported ERC20 token\n    function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }\n\n    /// @notice function to check whether the allowed amount of deposit per server has been reached\n    /// @param _deposit the new amount of deposit a server has\n    /// @dev will fail when the deposit is greater than the maxDepositFirstYear in the 1st year\n    /// @dev will fail when the deposit is less than the minDeposit\n    function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }\n\n    /// @notice helper function for registering a node\n    /// @param _url the url of the node\n    /// @param _props the properties of the node\n    /// @param _signer the signer of the node\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the node\n    /// @param _weight the weight of the node (# of requests per second he is able to handle)\n    function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }\n\n}\n",
    "inFile": "NodeRegistryLogic.sol",
    "references": [
      "BlockhashRegistry",
      "NodeRegistryData",
      "NodeRegistryData.SignerInformation",
      "NodeRegistryData.In3Node",
      "IERC20"
    ],
    "isAbstract": false
  }
}